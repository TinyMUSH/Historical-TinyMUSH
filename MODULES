DYNAMICALLY LOADABLE MODULES

TinyMUSH versions 3.1 and higher provide an interface for dynamically
loadable modules. This allows server administrators to write and install
"hardcode" that extends the functionality of the server, without creating
undue difficulties with future upgrades.

If you are writing a module, or you are installing a module written by
someone else, please be forewarned: Modules muck directly with the
server's internals. Using a module is, for all practical purposes,
exactly like directly hacking the server.  Thus, the safeguards that
exist with softcode do not exist with modules; if modules contain
bugs, they could cause severe issues with instability and database
corruption.

If you are writing a module, you should be fluent in reading and
writing the C programming language. You should take the time to
carefully study the existing server code. It's assumed you can
read code to figure out things that aren't explicitly documented
(which is just about everything not directly related to module
interface). It's also assumed that you understand how dynamic
loading works.

-----------------------------------------------------------------------------

HOW TO BUILD A MODULE

Every module has a one-word name, such as "hello", or "space3d",
referred to generically as '<name>' in the rest of this document. 
This is the name of the .c file in the modules directory.

The source for modules should be placed in the src/modules directory.
The shared objects for modules go in the game/modules directory.

Modules are made as follows, in a Makefile (assuming that CC is set
to some compiler, LD is set to some loader, and OPTIM is set to the
optimization flags):

mod_<name>: <name>.c
	$(CC) $(OPTIM) -c <name>.c
	$(LD) -shared -o <name>.so <name>.o
	cp <name>.so ../../game/modules

Getting the server to load a module is simple. For each module, add
the following line to your netmush.conf file:
module <name>

Modules can only be loaded when the game is started.

CAUTION: If you are changing a dynamically-loaded module while the
game is running, do NOT overwrite the old shared object. Move
the old game/modules/<name>.so to game/modules/<name>.so~ before
moving the new shared object into place. If you don't, the game
will crash hard when you attempt to @restart, and do horrible
things to your database.

-----------------------------------------------------------------------------

MODULE NAMES AND SYMBOLS

Everything within a module should occupy a unique namespace. Functions
names, non-static global variables, and other public entities should
be named 'mod_<name>_<regular name>'. Macros and constants should be named
MOD_<name>_<regular name>. This avoids potential namespace collisions.

All modules should begin with the following line:
#include "../api.h"

Including this file should get you access to the commonplace structures
and functions in the MUSH server, as well as specific module API things.
Please note that if you plan to use any symbol that's not defined within
api.h or a file that is #include'd by api.h, you will either need to
declare it extern within your module's .c file, or #include the 
appropriate main server .h file, as appropriate. 

CAUTION: Not all operating system's dlopen() calls properly check for
unresolved references. On such a system, if you reference a symbol that
your module cannot locate because it's not local and it wasn't declared
as extern, the server will crash when it tries to resolve the symbol.

-----------------------------------------------------------------------------

MODULE CONFIGURATION

The module configuration should come next, since the rest of your module
will use this information.

You should declare a configuration structure for your module as follows:

struct mod_<name>_confstorage {
	<type1> <name1>;
	<typeN> <nameN>;
} mod_<name>_config;

Then, you should declare a configuration table, as follows:

CONF mod_<name>_conftable[] = {
{(char *)"<name>_alias",	cf_alias,	<set perms>,	<read perms>,
	(int *)&mod_<name>_<table>_htab,	(long)"<description>"},
{(char *)"<boolean option>",	cf_bool,	<set perms>,	<read perms>,
	&mod_<name>_config.<bool_param>,	(long)"<yes/no assertion>"},
{(char *)"<read-only param>",	cf_const,	CA_STATIC,	<read perms>,
	&mod_<name>_config.<const_param>,	(long)<as appropriate>},
{(char *)"<integer param>",	cf_int,		<set perms>,	<read perms>,
	&mod_<name>_config.<int_param>,		<maximum value or 0>},
{(char *)"<options flagword>",	cf_modify_bits,	
	&mod_<name>_config.<options_param>,	(long)<name table>},
{(char *)"<nametable>_access",	cf_ntab_access,	<set perms>,	CA_DISABLED,
	(int *)<table>,				(long)access_nametab}, 
{(char *)"<word option>",	cf_option,	<set perms>,	<read perms>,
	&mod_<name>_config.<int_param>,		(long)<option nametable>},
{(char *)"<whatever>_flags",	cf_set_flags,	<set perms>,	<read perms>,
	(int *)&mod_<name>_config.<flag_param>,	0},
{(char *)"<word>",		cf_string,	<set perms>,	<read perms>,
	(int *)mod_name_config.<string_buffer>,	<maximum length>},
{ NULL,				NULL,		0,		0,
	NULL,					0}};

Note that the table must always end with a null entry.

In the conf file, any config parameters for a module must, of course,
be placed after module directive loading that module.

-----------------------------------------------------------------------------

MODULE INITIALIZATION

The module initialization function goes LAST in your module's .c file.
It should read as follows:

void mod_<name>_init()
{
	/* Initialize local configuration to default values. */ 

	mod_<name>_config.<bool_param> = <0 or 1>; 
	mod_<name>_config.<int_param> = <integer>;
	StringCopy(mod_<name>_config.<string_param>, <string>);

	/* Load tables. */

	register_hashtables(mod_<name>_hashtable, mod_<name>_nhashtable);
	register_commands(mod_<name>_cmdtable);
	register_functions(mod_<name>_functable);

	/* Any other initialization you need to do. */
}

If you have no hashtables, numeric hashtables, commands, and/or functions,
you should still call these functions, with a parameter of NULL.

Note that there is no main() function in a module.

-----------------------------------------------------------------------------

DEFINING COMMANDS

Commands fall into four categories of syntax:

TYPE		SYNTAX PATTERN			EXAMPLE
NO_ARG		<cmd>				@stats
ONE_ARG		<cmd> <argument>		think <message>
TWO_ARG		<cmd> <arg 1> = <arg 2>		@parent <object> = <parent>
TWO_ARG_ARGV	<cmd> <arg 1> = <arg 2a>,<...>	@trig <obj>/<attr> = <p1>,<..>

api.h defines a number of macros used to declare command handlers. 
These should be largely self-explanatory. The syntax of a command
handler is:

DO_CMD_<type>(mod_<name>_do_<handler name>)
{
	/* code goes here */
}

To write a handler for "@hello", a command with one argument in a module
called "hello", for example, you would write:

DO_CMD_ONE_ARG(mod_hello_do_hello)
{
	/* code goes here */
}

Once you have declared all of your handlers, you must place the
handlers in the command table, which takes the following format:

CMDENT mod_<name>_cmdtable[] = {
{(char *)"<command1>",		<switches>,	<permissions>,
	0,		CS_<handler type>,
	NULL,		NULL,	NULL,		<handler function>},
{(char *)"<command2>",		<switches>,	<permissions>,
	0,		CS_<handler type>,
	NULL,		NULL,	NULL,		<handler function>},
{(char *)NULL,			NULL,		0,
	0,		0,
	NULL,		NULL,	NULL,		NULL}};

You can put as many commands into this table as you'd like. Make
sure it ends with the "null" entry, though.

<switches> is the name of a switch table, described below.

<permissions> consist of an OR'd ('|') list of permissions, such as
CA_PUBLIC, CA_WIZARD, and CA_GOD.

<handler type> is the same as the <handler function> type. For
example, if you have DO_CMD_NO_ARG(mod_hello_do_heythere), then you
will have CS_CMD_NO_ARG for <handler type>. Your <handler function>
will be mod_hello_do_heythere.

A switch table takes the following form:

NAMETAB mod_<name>_<command>_sw[] = {
{(char *)"switch1",	<letters>,	<permissions>,	<key>},
{(char *)"switch2",	<letters>,	<permissions>,	<key>},
{ NULL,			0,		0,		0}};

A command can take an arbitrary number of switches, so each of these
switch tables can be as large as you like. Make sure the switch table
ends with the "null" entry, though.

<letters> is the number of unique letters of the switch that someone
has to type. For example, if your switch name is "foobar", and
<letters> is 3, then '/foo' is sufficient.

<permissions> consist of an OR'd ('|') list of permissions, such as
CA_PUBLIC, CA_WIZARD, and CA_GOD, just like in the main command table.

<key> is a bit key; handler functions check 'key & <key>' to modify
their behavior based on any switches the user passed. If you want
a command to be able to take multiple switches as the same time, you
should add '|SW_MULTIPLE' to <key>.

Switch tables should be placed BEFORE the command table, in your
module's .c file.

-----------------------------------------------------------------------------

DEFINING FUNCTIONS

A function handler takes the following form:

FUNCTION(mod_<name>_fun_<function name>)
{
	/* code goes here */
}

See functions.h for what this macro'd function prototype expands to.
See the server's fun*.c files for some examples of how to write functions.

Once you have declared all of your function handlers, you must place
them in the function table, which takes the following format:

FUN mod_<name>_functable[] = {
{"FUNCTION1",	<handler>,	<args>, <flags>,	<permissions>},
{"FUNCTION2",	<handler>,	<args>, <flags>,	<permissions>},
{NULL,		NULL,		0,	0,		0}};

You can put as many functions into this table as you'd like. Make
sure it ends with the "null" entry, though.

<handler> is the name of the function handler (the name of the C function
that's handling the function call: mod_<name>_<fun>_<whatever>).

<args> is the number of arguments that the function should take.
If this is variable, use 0.

<flags> are any special function-handling flags, OR'd ('|') together.
Functions taking a variable number of arguments get a FN_VARARGS flag.
Functions whose arguments should be passed unevaluated get a FN_NO_EVAL
flag.

<permissions> consist of an OR'd ('|') list of permissions, such as
CA_PUBLIC, CA_WIZARD, and CA_GOD, just like in the main command table.

-----------------------------------------------------------------------------

DEFINING HASH TABLES

HASHTAB mod_<name>_<htabname1>;
HASHTAB mod_<name>_<htabnameN>;

MODHASHES mod_<name>_hashtable[] = {
{ "htabname1",	&mod_<name>_<htabname1>,	<size factor>,	<minimum>},
{ "htabnameN",	&mod_<name>_<htabnameN>,	<size factor>,	<minimum>},
{ NULL,		NULL,				0}};

NHSHTAB mod_<name>_<nhtabname1>;
NHSHTAB mod_<name>_<nhtabnameN>;

MODNHASHES mod_<name>_nhashtable[] = {
{ "nhtabname1",	&mod_<name>_<nhtabname1>,	<size factor>,	<minimum>},
{ "nhtabnameN",	&mod_<name>_<nhtabnameN>,	<size factor>,	<minimum>},
{ NULL,		NULL,				0}};

The initial size factor will be multiplied by the hash factor.
The minimum is the absolute smallest size of the hash table, which
must be a power of 2.

-----------------------------------------------------------------------------

EXTENDING THE DATABASE

Though modules have access to the db structure, modules cannot add their
own data types to that db structure.

Thus, if you need to store a piece of data for every object in the 
database, your module needs to have its own parallel db structure,
as follows:

typedef struct mod_<name>_dbobj MOD_<name>_OBJ;
struct mod_<name>_dbobj {
	<type1> <name1>;
	<type2> <nameN>;
};

MOD_<name>_OBJ *mod_<name>_db = NULL;

#define OBJ_INIT_MODULE(x) \
	mod_<name>_db[x].<name1> = <value1>; \
        mod_<name>_db[x].<nameN> = <valueN>;

void mod_<name>_db_grow(newsize)
	int newsize;
{
	DB_GROW_MODULE(mod_<name>_db, newsize, MOD_<name>_OBJ);
}

-----------------------------------------------------------------------------

MODULE API FUNCTIONS

The following are "hooks" into the server. If you place these functions
in your module's .c file, they will automatically be called at the
appropriate time.

void mod_<name>_create_obj(dbref player, dbref obj)
	Run when an object is created, after other initialization is done.
	Passes the creating player and the object dbref created.

void mod_<name>_destroy_obj(dbref player, dbref obj)
	Run when an object is destroyed, before the player is compensated
	for its destruction, is notified of its destruction, and the 
	object is wiped out.
	Passes the destroying player and the object dbref being destroyed.
	Note that the destroying player may be NOTHING.

void mod_<name>_create_player(dbref creator, dbref player,
				int isrobot, int isguest)
	Run when a player is created, after create_obj() has been run.

void mod_<name>_destroy_player(dbref player, dbref victim)
	Run after the player basics have been cleared out, but before
	destroy_obj() has been run.

void mod_<name>_announce_connect(dbref player)
	Run when a player connects, before the player looks at his current
	location, but after all other connect stuff has been executed.

void mod_<name>_announce_disconnect(dbref player, const char *reason)
	Run when a player disconnects, after all other disconnect stuff
	has been executed, but before the descriptor has been deleted.

void mod_<name>_make_minimal(void)
	Run if making a minimal database is specified.

void mod_<name>_load_database(void)
	Load database specific to module.

void mod_<name>_dump_database(void)
	Dump database specific to module.

void mod_<name>_cleanup_startup(void)
	Run after the restart database is read, but before @startups
	on objects are done.

-----------------------------------------------------------------------------

MODULE API FUNCTION: process_command

int mod_<name>_process_command(dbref player, dbref cause, int interactive,
				char *command, char *args[], int nargs)

	Run when any object tries to execute a command, before any 
	built-in commands or softcoded commands are checked.

	Returns a number: 0 on failure, something greater than 0 on
	success, and something less than 0 on failure that should stop
	further matching of commands.

	This handler tries to run on each module in sequence. If the
	handler is not defined for a module, or 0 is returned, it tries
	the next module. A return of a number other than 0 will result
	in not running this handler on the other modules, this time 
	around.

	The calling server function considers a result greater than 0 to
	be a successful	command match, and will consider the command
	taken care of.

	The 'player' and 'cause' parameters are the dbrefs of the objects
	taking the action, and which caused the action (the enactor): the
	equivalent of %! and %#, respectively.

	The 'interactive' parameter is passed as 1 if the command was
	entered from the keyboard (i.e., received over the network),
	and 0 otherwise.

	The 'command' parameter is a pointer to the command entered,
	space-compressed if space compression is turned on. This
	string SHOULD NOT be destructively modified.

	The 'args' parameter consists of the stack (%0 - %9) and the
	'nargs' parameter is the number of arguments on the stack.

-----------------------------------------------------------------------------

MODULE API FUNCTION: process_no_match

int mod_<name>_process_no_match(dbref player, dbref cause, int interactive,
				char *eval_cmd, char *raw_cmd,
				char *args[], int nargs)

	Run when any object tries to execute a command, after all built-in
	and softcoded commands are checked. This occurs right before a
	"Huh?" message is given.

	Returns a number: 0 on failure, something greater than 0 on
	success, and something less than 0 on failure that should stop
	further matching of commands.

	This handler tries to run on each module in sequence, most
	recently-loaded module first, to least recently-loaded module
	last. If the handler is not defined for a module, or 0 is
	returned, it tries the next module. A return of a number other
	than 0 will result in not running this handler on the other
	modules, this time around.

	The calling server function considers a non-zero result to
	be a successful	command match, and will consider the command
	taken care of. (Note that this is different from process_command,
	which considers only results greater than zero to be successful.)

	The 'player' and 'cause' parameters are the dbrefs of the objects
	taking the action, and which caused the action (the enactor): the
	equivalent of %! and %#, respectively.

	The 'interactive' parameter is passed as 1 if the command was
	entered from the keyboard (i.e., received over the network),
	and 0 otherwise.

	The 'eval_cmd' parameter is a pointer to the command, after it
	has gone through percent-substitutions and other evaluations.

	The 'raw_cmd' parameter is a pointer to the command entered,
	space-compressed if space compression is turned on, but not
	otherwise evaluated.

	The 'args' parameter consists of the stack (%0 - %9) and the
	'nargs' parameter is the number of arguments on the stack.
