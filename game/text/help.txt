& help
 
  This is the TinyMUSH 3.0 online help facility.
 
  Notes on help descriptions: 
        [text] - Text enclosed in []'s is optional.  The []'s are never typed
                 in as part of the command.
        <parameter> - Information parameter for a command.  The <>'s are
                      never typed in as part of the command.
 
  Syntax of help command:
    help [<command>]
 
  Some things to start with:
     help topics		(Main help topics)
     help command list		(List of commands) 	(@list commands)
     help flag list		(List of flags)		(@list flags)
     help function list		(List of functions)	(@list functions)
 
  Also see "help About TinyMUSH".
 
& COMMANDS
  Flag: COMMANDS ($)
 
  When set on an object, when a command match is done, it checks the 
  object for attributes of the form '$<pattern>:<commandlist>'. If the 
  command matches the pattern, then <commandlist> is executed.
 
  In other words, it checks the object for arbitrary user-defined 
  $commands.
 
  Depending on your MUSH configuration, this flag might or might not
  be necessary for Arbitrary Commands to be checked.
 
  See 'help Arbitrary Commands' for more details.
 
& command list
  Help available for MUSH Commands:
 
  drop         enter        examine      get          give         goto
  help         inventory    kill         leave        LOGOUT       look
  move         news         OUTPUTPREFIX OUTPUTSUFFIX page         pose
  PUEBLOCLIENT QUIT         read         say          score        SESSION
  take         throw        use          version      whisper      WHO
  "            :            ;            &            #            \\
 
  @@           @chown       @clone       @cpattr      @create      @cron
  @crondel     @crontab     @decompile   @destroy     @dig         @doing
  @dolist      @drain       @edit        @emit        @entrances   @eval
  @femit       @find        @force       @fpose       @fsay        @halt
  @last        @link        @list        @listmotd    @lock        @mvattr
  @mail        @malias      @name        @notify      @npemit      @oemit
  @open        @parent      @password    @pemit       @program     @ps
  @quitprog    @quota       @robot       @search      @set         @sql
  @stats       @sweep       @switch      @teleport    @trigger     @unlink
  @unlock      @verb        @wait        @wipe
 
{ 'help commands2' for more }
& commands2
  Help available for MUSH Commands (continued):
 
  @aahear      @aclone      @aconnect    @adescribe   @adfail      @adisconnect
  @adrop       @aefail      @aenter      @afail       @agfail      @ahear
  @akill       @aleave      @alfail      @alias       @amhear      @amove
  @apay        @arfail      @asuccess    @atfail      @atofail     @atport
  @aufail      @ause        @away        @charges     @conformat   @cost
  @daily       @describe    @dfail       @drop        @ealias      @efail
  @enter       @exitformat  @exitto      @fail        @filter
  @forwardlist @gfail       @htdesc      @idesc       @idle        @infilter
  @inprefix    @kill        @lalias      @leave       @lfail       @listen
  @move        @odescribe   @odfail      @odrop       @oefail      @oenter
  @ofail       @ogfail      @okill       @oleave      @olfail      @omove
  @opay        @orfail      @osuccess    @otfail      @otofail     @otport
  @oufail      @ouse        @oxenter     @oxleave     @oxtport     @pay
  @prefix      @reject      @rfail       @runout      @sex         @startup
  @success     @tfail       @tofail      @tport       @ufail       @use
  @vrml_url
 
& topics
 
  Help available on the following Topics:
 
	ARBITRARY COMMANDS	ATTRIBUTE OWNERSHIP	BEING KILLED
	BOGUS COMMANDS		BOOLEAN VALUES		COMMAND EVALUATION
	COMSYS			CONTROL			COSTS		
	CREDITS			DELIMITERS		DROP-TO
	ENACTOR      		EXITS			FAILURE	
	FLAG LIST		FLAGS			FUNCTION LIST
	FUNCTIONS		GENDER			GOALS		
	HERE			HOMES			LINKING
	LISTENING		LISTS			LOOPING
	ME			MONEY			MOVING
	OBJECT TYPES		PARENT OBJECTS		PATCHLEVEL
	PIPING			PUEBLO			PUPPETS
	REGEXPS			ROBBERY			SEARCH CLASSES
	SEMAPHORES		SPOOFING		STACK
	SUBSTITUTIONS		SUCCESS			SWITCHES
	VERBS			WIZARDS			ZONE OBJECTS
 
& drop 
  Command: drop[/<switch>] <object>
           drop[/<switch>] <exit>
 
  The first form removes <object> from your inventory and puts it in your
  location, except for the following special cases: Dropping a STICKY thing
  sends it home, and dropping a thing in a room with a drop-to sends the thing
  to the drop-to location.
 
  The second form removes <exit> from your list of exits and adds it to the
  list of exits for the current location.  Anyone in the same location as
  you may then use the exit to travel to the exit's destination.  You can
  only drop exits when you own the location where you are dropping them.
 
  The following switch is recognized:
     /quiet   - Don't perform the @odrop/@adrop attributes on the dropped
                 object.  This switch only works if you control the object.
 
  'throw' is the same as 'drop'.
  See also: get, @adrop, @drop, @odrop, DROP-TO, STICKY.  

& enter
  Command: enter[/<switch>] <object>
  The enter command is used to enter an object. Insides of objects are best
  used for vehicles, or storage spaces when you don't have a home (or even
  as a floating home).  In order to enter an object you must either own it or
  it must have its ENTER_OK flag set, and you must also pass the object's
  EnterLock (if it has one).
 
  The following switch is recognized:
     /quiet   - Don't perform the @oenter/@aenter or @oefail/@aefail
                attributes on the entered object, and don't perform the
                @oxleave attribute on your current location.  This switch
                only works if you control the object being entered.
 
  See also: leave, @aefail, @aenter, @efail, @enter, @idesc, @lock, @oefail,
            @oenter, @oxleave, ENTER_OK.

& examine
 
  Command: examine[/<switches>] <object>[/<wild-attrib>]
  Displays all available information about <object>.  <object> may be an
  object, 'me' or 'here'. You must control the object to examine it, or it
  must be set VISUAL.  If you do not own the object, you will just see the
  name of the object's owner, and optionally any public attributes and 
  attributes owned by you set on the object.
 
  If an attribute is owned by a player other than the owner of the object,
  the number of the attribute owner is shown in parentheses immediately
  following the attribute name. Flag letters may appear in parentheses also,
  to indicate the status of the attribute; see 'help @set2' for details.
 
  If you specify a wildcarded attribute name, then only those attributes
  that match are shown. So, 'exam me/v?' will show all your attributes that
  start with v and are two characters long.
 
  Continued in 'help examine2'.
 
& examine2
 
  The following switches are available:
 
     /brief  - Don't show the attributes on the object.
     /full   - When examining an object you don't control, show any public
               attributes set on the object in addition to the owner's name.
     /owner  - Show only the owner of the object.
     /parent - Includes attributes that are not present on the object itself
               but which are inherited from the object's parent.
     /pretty - Pretty-print, in a format suitable for a MUSH unformatter.
     /pairs  - Shows matches in parentheses, brackets, and braces.
               Each level ("nesting") of these is highlighted in a different
               ANSI color (in order, green, yellow, cyan, blue, and magenta).
               If an error is encountered, where the pairs don't match, the
               offending character is highlighted in red. The rest of the
               string is then printed out; no further pair-matching will
               occur. Escaped-out characters are not highlighted or counted.
 
  See also: look, @decompile, VISUAL, ATTRIBUTE OWNERSHIP.
 
& get
  Command: get[/<switch>] <object>
           get[/<switch>] <exit>
           get[/<switch>] <object>'s <sub-object>

  The first form picks up <object> from your location and adds it to your
  inventory.  It will fail if the object is locked against you, or if you
  are inside a player or object that you don't control and which isn't
  set ENTER_OK.
 
  The second form takes an exit from your location and adds it to you.
  Anyone inside you may then use the exit to travel to the exit's destination.
  You may take exits that you own, and exits owned by others in locations that
  you own.
 
  The third form takes <sub-object> from <object> and adds it to your
  inventory.  <object> must be ENTER_OK and <sub-object> must not be locked
  against you for this to work.  The lock on <object> is not checked.
{ 'help get2' for more }
& get2
  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc or @ofail/@afail attributes
                on the target object.  This switch only works if you control
                the object.
 
  <object> and <sub-object> may be either players or things.
  'take' is the same as 'get'.
  See also: drop, @afail, @asucc, @fail, @ofail, @osucc, @succ, ENTER_OK,
            FAILURE, SUCCESS.
& give
  Command: give <player>=<amount/object>
  Gives player the specified amount of money or <object>. You can't give
  someone money if their new total would be greater than 10000 (No reason to
  get greedy).  You may also give players objects, but the other player must
  be set ENTER_OK to receive something you give. 
  See also: @apay, @cost, @opay, @pay, ENTER_OK.

& goto
  Command: goto[/<switch>] <direction>
           goto[/<switch>] home
           <direction>
 
  Moves you in the specified direction, assuming that the direction is not
  locked against you.  'move home' is a special command that returns you to
  your home. The word 'move' may be omitted.
 
  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc/@odrop/@adrop or @ofail/@afail
                attributes on the exit being used.  This switch only works if
                you control the exit.
 
  'move' is the same as 'goto'.
  See also: enter, home, leave, home
 
& home
  Command: home
 
  The 'home' command takes you "home". It always works, with one exception
  related to the FIXED flag.
 
  The 'home' command is not a normal command, and therefore can never be
  overridden with @addcommand, or given hooks via @hook, or have its
  permissions altered via @admin.
 
  See also: HOMES, FIXED
 
& inventory
  Command: inventory
  Lists what you are carrying and how much money you have.

& kill
  Command: kill <player> [=<cost>]
  Attempts to kill the specified player. Killing costs <cost> coins, which
  gives you a <cost>% chance of killing the player. Thus, spending 100 
  coins always works (except against wizards and immortals, who can never be
  killed). Players cannot be killed in rooms which have been set HAVEN or
  which they control.  If you don't specify a cost, the default is 10 (for a
  10% chance of success).  The player, if killed, receives <cost>/2 coins in
  insurance.
  See also: @akill, @kill, @okill, BEING KILLED, IMMORTAL, WIZARD.

& leave
  Command: leave[/<switch>]
  This command leave allows you to exit an object you have entered, arriving
  in the same location as the object. You may not leave an object if you fail
  that object's LeaveLock (but you may still @teleport out, use an exit inside
  the object, or go home).
 
  The following switch is recognized:
     /quiet   - Don't perform the @oleave/@aleave or @olfail/@alfail
                attributes on the entered object, and don't perform the
                @oxenter attribute on your new location.  This switch
                only works if you control your current location.
 
  See also: enter, @lock, ENTER_OK, @aleave, @alfail, @leave, @lfail, @oleave,
            @olfail, @oxenter.
& LOGOUT
  Command: LOGOUT
  Disconnects you from your character without breaking the network connection
  to the game.  You may then log in to another character.  The LOGOUT command
  must be entered in all capitals.
  See also: QUIT.

& look
  Command: look[/<switches>] [<object>]
  Displays the description of <object>, or the room you're in if you don't
  specify an object.  Specifying object as <name> or #<dbref> or 'me' or
  'here' is legal.  You can also use look to look at objects held by other
  people, just use 'look <person>'s <object>'.
 
  You may use the /outside switch to look at the location of your current
  location (useful if you are inside a vehicle or other object).  You may
  also look at other objects in the 'outer' location, but you may not
  use the possessive form with the /outside switch (ie: "look/outside
  <person>'s <object>" won't work).
  
  'read' is the same as 'look'.
 
  See also: @adesc, @describe, @odesc.

& move
  Command: move[/<switch>] <direction>
           move[/<switch>] home
           <direction>
           home
 
  Moves you in the specified direction, assuming that the direction is not
  locked against you.  'move home' is a special command that returns you to
  your home. The word 'move' may be omitted.
 
  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc/@odrop/@adrop or @ofail/@afail
                attributes on the exit being used.  This switch only works if
                you control the exit.
 
  'goto' is the same as 'move'.
  See also: enter, home, leave.
& news
  Command: news [<topic>]
  Shows you the current news for the MUSH. It is highly recommended that
  you check the news daily for new information.  Otherwise, the wizards will
  have no pity on you for messing up with the new commands.

& OUTPUTPREFIX
  Command: OUTPUTPREFIX <string>
  Causes <string> to be output on a line by itself before printing the
  results of each command.  This command is intended for use by external
  robot programs, and may be restricted to players whose ROBOT flag is set.
  The OUTPUTPREFIX command must be entered in all capitals.
  See also; @robot, OUTPUTSUFFIX, ROBOT.

& OUTPUTSUFFIX
  Command: OUTPUTSUFFIX <string>
  Causes <string> to be output on a line by itself after printing the results
  of each command.  This command is intended for use by external robot
  programs, and may be restricted to players whose ROBOT flag is set.
  The OUTPUTSUFFIX command must be entered in all capitals.
  See also; @robot, OUTPUTPREFIX, ROBOT.

& page 
  Command: page [<player-list>] [=<message>]
 
  This command sends <message> to a list of players. If you do not specify
  a player list, it defaults to the players you last paged. You may use
  any combination of player names, player aliases, or partial names (strings
  that uniquely match the start of a connected player's name).
 
  You can format the message one of several ways by specifying ':', ';', or
  '"' as the first character of the message.  ':' and ';' format the message
  as 'From afar, <player> <message>', with ';' omitting the space between
  <player> and <message>.  '"' formats the message in normal page format
  (this is the default).
 
{ 'help page2' for more }
& page2  
  If your Idle attribute is set to something, then it is sent to anyone
  who successfully pages you.  This is useful for when you are away from
  your terminal for a short while.
 
  You can selectively disable pages from certain players with the '@lock/page'
  command (players must pass the lock in order to page you).  If someone
  cannot page you, they will be sent a message including of your Reject
  attribute if they try.  If someone pages you while you are not connected,
  they are sent a message including your Away attribute.
 
  See also: pose, say, whisper, :, ;, ", @pemit, @away, @idle, @reject.
 
& pose
  Command: pose[/<switches>] <message>
  Displays <message> to everyone in your current room, preceded by your name
  and optionally a space.  Example: the command 'pose jumps for joy' produces
  '<yourname> jumps for joy'.
 
  The following switches are available:
     /default - (default) Put a space between your name and the message
                (ie, display '<name> <message>').
     /nospace - Don't put a space between your name and the message
                (ie, display '<name><message>').
 
  See also: page, say, whisper, :, ;, ".

& PUEBLO
  Topic: Pueblo
 
  Pueblo is an HTML-based MU* client available from www.chaco.com.
  Unless compiled without Pueblo support (on by default), TinyMUSH provides
  these features to enable the use of Pueblo and HTML:
 
  Commands:	PUEBLOCLIENT	@htdesc		@vrml_url
  Switches:	@emit/html	@pemit/html
  Functions:	html_escape()	html_unescape()
		url_escape()	url_unescape()	(see Pueblo Functions)
  Flags:	HTML
  Attr flags:	html
 
  When you connect with Pueblo, it automatically uses the PUEBLOCLIENT
  command to set your HTML flag.  This causes most output from the mush
  to be escaped into HTML that Pueblo can display.  If you want to write
  arbitrary HTML on the mush and have it sent unescaped to Pueblo users,
  you'll need to apply the html attribute flag (see @htdesc for an
  example).

& PUEBLOCLIENT
  Command: PUEBLOCLIENT
 
  This command notifies the MUSH that one is using a client that supports
  the Pueblo extensions. Such a client normally sends this string
  automatically; users probably will never need to type this.
 
  See also: Pueblo.

& QUIT    
  Command: QUIT
  Logs you out and disconnects you from the game. Must be in all capitals.  
  See also: LOGOUT.

& read 
  Command: read [<object>]
  Displays the description of <object>, or the room you're in if you don't
  specify an object.  Specifying object as <name> or #<dbref> or 'me' or
  'here' is legal.  You can also use look to look at objects held by other
  people, just use 'read <person>'s <object>'.
 
  You may use the /outside switch to look at the location of your current
  location (useful if you are inside a vehicle or other object).  You may
  also look at other objects in the 'outer' location, but you may not
  use the possessive form with the /outside switch (ie: "read/outside
  <person>'s <object>" won't work).
  
  'look' is the same as 'read'.

& ;
  Command: ;<message>
  This command is much like the ':' command, except that no space is inserted
  between your name and the action.  Example: the command ';'s watch beeps.'
  produces '<yourname>'s watch beeps.'.
 
  Warning: This command does not work in command lists run from an attribute
  because the ';' is treated as the command separator.  Use pose/nospace
  instead.
 
  See also: page, pose, say, whisper, :, ".

& :
  Command: :<message>
  Displays <message> to everyone in your current room, preceded by your name
  and a space.  Example: the command ':jumps for joy' produces
  '<yourname> jumps for joy'.
  See also: page, pose, say, whisper, ;, ".

& "
  Command: "<message>
  Says <message> out loud to everyone in your current room.  Example:
  the command '"Where is the movie theater?' produces
  '<yourname> says "Where is the movie theater>"'.  Note that the closing
  double quote is automatically added.
  See also: page, pose, say, :, ".

& #
  Command: #<number> <command>
  Forces the object whose database number is <number> to perform <command>.
  Example: '#1033 move north' forces object #1033 to go north (assuming that
  you control it).  The same restrictions that apply to @force also apply to
  this command.
  See also: @force.

& \\
  Command: \\<message>
  Outputs <message> to everyone in your current room without embellishment.
  Example: the command '\\A chill falls over the room.' produces
  'A chill falls over the room.'
  See also: @emit, @oemit, NOSPOOF.

& say
  Command: say <message>
  Says <message> out loud to everyone in your current room. You can also
  use '"<message>'.
  See also: page, pose, whisper, :, ;, ".

& score
  Command: score
  Displays how much money you have.  Helpful to see if any machines are
  looping.
  See also: @ps, LOOPING.

& SESSION
  Command: SESSION
  Displays information on how many characters you have sent and received
  during this session, and which (Internal) port you are connected to on the
  mush.  It must be typed in all uppercase.
 
  Example:
    > SESSION
                                     Characters Input----  Characters Output---
    Player Name     On For Idle Port Pend  Lost     Total  Pend  Lost     Total
    Mortal           00:06   0s   16    0     0        44   156     0      2679
    2 Players logged in.
 
  Pending characters are those waiting to be acted on as commands (for input)
  or waiting to be sent out over the network (output).  Lost characters are
  due to overflowing either the MUSH's input or output buffers, either as the
  result of running a single command that produces too much output (such as
  @find and @search commands that match a large number of objects), or from
  typing too much on one line.
 
  Note: your Pending count for output will always be nonzero, as the output
  of the SESSION command hasn't been sent out over the network yet.

& take
  Command: take[/<switch>] <object>
           take[/<switch>] <exit>
           take[/<switch>] <object>'s <sub-object>
 
  The first form picks up <object> from your location and adds it to your
  inventory.  It will fail if the object is locked against you, or if you
  are inside a player or object that you don't control and which isn't
  set ENTER_OK.
 
  The second form takes an exit from your location and adds it to you.
  Anyone inside you may then use the exit to travel to the exit's destination.
  You may take exits that you own, and exits owned by others in locations that
  you own.
 
  The third form takes <sub-object> from <object> and adds it to your
  inventory.  <object> must be ENTER_OK and <sub-object> must not be locked
  against you for this to work.  The lock on <object> is not checked.
{ 'help take2' for more }
& take2
  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc or @ofail/@afail attributes
                on the target object.  This switch only works if you control
                the object.
 
  <object> and <sub-object> may be either players or things.
  'get' is the same as 'take'.
  See also: drop, @afail, @asucc, @fail, @ofail, @osucc, @succ, ENTER_OK,
            FAILURE, SUCCESS.

& think
  Command: think <message>
 
  You can use this command to send a private message to yourself. Pronoun
  substitution is performed. It is equivalent to '@pemit me = <message>'.
 
& throw
  Command: throw[/<switch>] <object>
           throw[/<switch>] <exit>
 
  The first form removes <object> from your inventory and puts it in your
  location, except for the following special cases: Dropping a STICKY thing
  sends it home, and dropping a thing in a room with a drop-to sends the
  thing to the drop-to location.
 
  The second form removes <exit> from your list of exits and adds it to the
  list of exits for the current location.  Anyone in the same location as
  you may then use the exit to travel to the exit's destination.  You can
  only drop exits when you own the location where you are dropping them.
 
  The following switch is recognized:
     /quiet   - Don't perform the @odrop/@adrop attributes on the dropped
                 object.  This switch only works if you control the object.
 
  'drop' is the same as 'throw'.
  See also: get, @adrop, @drop, @odrop, DROP-TO, STICKY.  

& use
  Command: use <object>
  Uses <object>.  Some objects will do interesting, useful, or dangerous
  things when used, for instance, using a camera should result in a 
  picture being taken.
  See also: @ause, @ouse, @use.

& version
  Command: version
  Displays the version of MUSH that is running and the date it was last
  rebuilt.

& whisper 
  Command: whisper <player>=<message>
  Whispers the message to the named person, if they are in the same room as
  you. No one else can see the message that you whisper.
 
  You can format the message one of several ways by specifying ':', ';', or
  '"' as the first character of the message.  ':' and ';' format the message
  as 'You sense <player> <message>', with ';' omitting the space between
  <player> and <message>.  '"' formats the message in normal whisper format
  (this is the default).
  See also: page, pose, say, :, ;, ".

& WHO
  Command: WHO <prefix>
  Displays a list of players currently connected to the MUSH.
  The WHO report tells you how long a player has been on, how long they
  have been inactive, and what they are doing (if they have used the @doing
  command).  If <prefix> is specified, only players whose names start with
  <prefix> are listed.  The WHO command must be entered in all capitals.
  See also: @doing.

& &
  Command: &<attribute> <object>[=<value>]
  Synonym: @set <object> = <attribute>:[<value>]
 
  Sets the attribute named <attribute> on <object> to <value>.  If
  <attribute> is not a predefined attribute (like ofail or va), then it is
  created.  Attributes so created are called user-named attributes.
  Attribute names may only contain letters, numbers, and the characters
  < -_.@#$^&*~?=+| >, and must start with a letter.  The names of user-named
  attributes may not be abbreviated (an attempt to get the value of the
  attribute will fail, and an attempt to set will create a new attribute).
  The & command may be used to set predefined attributes (in this instance,
  '&<attr> <object>=<value>' is equivalent to '@<attr> <object>=<value>').
 
  See also: @set.

& @@
  Command: @@ <args>
 
  This command does nothing, therefore it is useful for putting comments into
  a MUSH program.  Be careful that ()'s and {}'s in the (otherwise ignored)
  arguments are nested correctly, lest your command-ending ; be trapped
  inside.
 
  Example:
     @va me=$foobar *:@fo #1234=%0;@@ This controls my foobar puppet.
 
& @eval
  Command: @eval <arg>
 
  This command does nothing other than evaluate <arg>, making it useful
  for executing side-effect functions.
 
  Example:
     @va me=$test *: @eval [set(me,TEST:Set to %0)][pemit(%#,Testing %0.)]
 
& @chown
 
  Command: @chown[/nostrip] <object>[=<player>]
           @chown <object>/<attr>[=<player>]
 
  The first form changes the ownership of <object> to <player> (default is
  to yourself).  Objects may be things, rooms or exits. Unless you are a
  Wizard or have the chown_anything power, the object you are @chown'ing
  must have the CHOWN_OK flag set, and you must be able to pass its
  ChownLock.
 
  If you are neither a Wizard nor have the chown_anything power, to @chown
  a thing, you must be carrying it, and refer very specifically to that 
  object, and to @chown a room, you must '@chown here = me'. Players cannot
  be @chown'd; they always own themselves (unless they are robots).
 
  @chown'ing an object automatically sets it HALT. It also strips special
  flags (such as WIZARD, INHERIT, etc.) from the object, as well as all
  powers, unless the /nostrip switch is specified. If /nostrip is specified
  by God, special flags and powers are not stripped; if anyone else 
  specifies /nostrip, only the WIZARD flag and powers will be stripped.
 
  Continued in 'help @chown2'.
 
& @chown2
 
  When an object is @chowned, all unlocked attributes on the object are
  automatically @chowned as well, locked attributes remain owned by their
  original owners.
 
  The second form changes the ownership of the indicated attribute on <object>
  to <player> (default is the owner of the object).  You may only @chown
  unlocked attributes.  You may @chown unlocked attributes on objects that
  you own to yourself, and you may also @chown attributes that you own on
  objects owned by others to the owner of the object.
  
  See also: @lock, @unlock, CHOWN_OK, ATTRIBUTE OWNERSHIP.
 
& @chzone
 
  Command: @chzone <object>=<zone object>. 
  
  Changes the zone of <object> to <zone object>. If <zone object> is "none",
  the zone is reset to NOTHING.
  
  @chzone'ing a player does not automatically change the zone of their
  objects. Anyone may reset the zone of an object they own; <zone object>
  must either be "none", or must be owned by them. Only wizards may @chzone
  an object to an arbitrary zone object. Players may @chzone themselves to
  an object they own; otherwise, only wizards may @chzone players.
  @chzone'ing resets the WIZARD, ROYALTY, and INHERIT flags on non-player
  objects.
  
  See also: ZONE OBJECTS
  
& @clone
  Command: @clone[/<switches>] <object>[=<newname/cost>]
 
  Creates an exact duplicate of <object> that is owned by you and (for things
  and exits) puts it in your current location.  You may have the object put
  in your inventory (or your exitlist in the case of cloning exits) by using
  the /inventory switch.
 
  You may clone your own objects, plus VISUAL objects owned by others.
  If <newname> is specified, it is used as the name instead of the
  original name.
 
  Object clones do not receive the powers of the original. Cloning does
  duplicate flags, except for certain special flags (such as WIZARD,
  INHERIT, and IMMORTAL). The INHERIT flag is not copied unless the
  /inherit switch is specified. Other special flags are not copied to
  the clone unless the /nostrip switch is specified (Wizards only).
  Even if /nostrip is specified, the WIZARD flag is only copied if
  you are God. 
  
  Continued in 'help @clone2'.
 
& @clone2
 
  You own the clone, unless you specified the /preserve switch; if you
  did so, and you control the owner of the original object, then the
  clone will have the same owner as the original object.
 
  If you clone a linked exit, an attempt is made to link the clone to the
  same location.  Except when using the /inventory switch, you can only clone
  exits when you own your current location.
 
  If you clone a room with a drop-to, an attempt is made to link the drop-to
  to the same location.
 
  If the original object was owned by you, then the ACLONE attribute is run
  in the new attribute. Otherwise, the new object is set HALT.
 
  The exits and contents of cloned objects are not cloned (i.e., cloning
  is never recursive).
 
  Continued in 'help @clone3'.
 
& @clone3
  The following switches are available:
 
     /cost       - Treat the argument after the = as the cost of the new
                   object, not the name.
     /inherit    - Don't reset the INHERIT bit on the new object.
     /inventory  - Create the new object in your inventory (or your exitlist,
                   in the case of cloning exits).
     /location   - Create the new object in your location (default).
     /nostrip    - Don't strip special flags and powers from the clone.
                   (Wizards only.)
     /parent     - Set the new object's parent to be the template object and
                   don't copy the attributes.
     /preserve   - Keep the clone's owner the same as the original object's
                   owner. You must control the original object's owner.
 
  See also: @create, @decompile, @destroy, VISUAL.
 
& @cpattr

  @cpattr <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
  @cpattr <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...]
  @cpattr <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
  @cpattr <attr> = <obj1> [,<obj2>,<obj3>,...]
 
  The first form of this command is used to copy <attr> on <obj> to the
  object-attribute pairs in a comma-separated list. For example:
 
  @cpattr test/va = test/vb, cube/va, tribble/foo
 
  would copy the VA attribute from object "test" to VB on "test",
  VA on "cube", and FOO on "tribble".  <objN> is matched as if
  you were performing a @set on it.
 
  The second form copies <attr> to the list of objects, with the name
  <attr>. The third form copies <attr> from the object that executes the
  @cpattr, to the object-attribute pairs in the list. Finally, the third
  form copies <attr> from the object that executes the @cpattr to the
  objects in the list, with the name <attr>.
 
& @create
  Command: @create <name> [=<cost>]
  Creates a thing with the specified name.  Creation costs either <cost>
  or 10 coins, whichever is greater. The value of a thing is proportional
  to its cost, specifically, value=(cost/5)-1.  The value may not be greater
  than 100, values that would be greater than 100 are rounded down to 100.
  See also: @destroy, TYPES OF OBJECTS.

& @cron
  Command: @cron <object>/<attribute> = <timestring>
 
  This command causes <object> to execute the contents of <attribute>
  (just as if a '@trigger <object>/<attribute>' had been done), at the
  times specified by <timestring>. You must control <object> and be
  able to read <attribute>.
  
  The syntax of the @cron <timestring> is virtually identical to that of
  Unix cron; it's a list of five space-separated fields, as follows:
 
    <minute> <hour> <day of month> <month> <day of week>
 
  Each component of <timestring> is the asterisk ('*'), or a
  comma-separated list of numbers or number ranges (i.e., '5-7').
  For instance, '2,5-7,10' means '2, 5, 6, 7, and 10'. The restrictions
  on numbers is as follows: <minute> is a number between 0 and 59,
  <hour> is a number between 0 and 23 (equivalent to 12 am to 11 pm),
  <day of month> is a number between 1 and 31, <month> is a number
  between 1 and 12 (January through December), and <day of week> is
  a number between 0 and 6 (Sunday through Saturday).
 
  Continued in 'help @cron2'.
 
& @cron2
 
  The specification of a day may be made by either day of week, or day
  of month. If both are specified, both are adhered to. In other words,
  '0 3 1,15 * 2' indicates that the task is scheduled for 3 am on
  Tuesdays, as well as the 1st and 15th of each month.
 
  The '*' and ranges can be modified with a '/<number>', indicating the
  "step size". For instance, '*/2' is equivalent to '0,2,4,6,8,10,12,...'
  (up to 58), and '11-20/3' is equivalent to '11,14,17,20'.
 
  Examples of timestrings:
 
    Run every hour, on the hour:  0 * * * *
    Run once every month, at 3:10 am the 1st:  10 3 1 * *
    Run every fifteen minutes:  0,15,30,45 * * * *  (also valid: */15 * * * *)
    Run every five minutes starting at 3 past the hour: 3-59/5 * * * *
    Run once a day, at 6 am:  0 6 * * *
 
  Cron entries are not preserved over restarts. To make a cron entry
  'permanent', it should be entered as part of a @startup on an object.
 
  See also: @crondel, @crontab, @daily
 
& @crondel
  @crondel <object>[/<attribute>]
 
  If no <attribute> is specified, this command removes all cron entries
  for <object>. If <attribute> is specified, this command removes all
  cron entries associated with that object and attribute. You must
  control <object>.
 
  See also: @cron, @crontab, @daily
 
& @crontab
  @crontab [<object>]
 
  If <object> is specified, this command shows the cron entries
  associated with that object. You must control <object>.
 
  If <object> is not specified, this command shows all cron entries
  (if you are a Wizard, Royalty, or have the see_queue power) or
  all cron entries for objects you own (if you are not any of the
  above).
 
  See also: @cron, @crontab, @daily
 
& @decompile
  Command: @decompile <object>[/<wildcard>] [=<newname>]
 
  This dumps the sequence of commands needed to recreate that object. It
  is useful for keeping off-MUSH records of your valuable objects, and for
  transferring code from one MUSH to another. If you specify <newname>, then
  the commands dumped will set attributes, locks, and flags on an object named
  <newname> and will omit the command to create the object.
 
  If <wildcards> are specified, only the specific attributes for the object
  will be printed in decompile format. This allows you to decompile objects
  that are larger than the output buffer limit, as well as simply decompile
  parts of objects; if a wildcard pattern is given, only attributes will be
  dumped (no flags, etc.)  The wildcard pattern is identical to the type 
  used by the 'examine' command and the 'lattr()' function.

& @destroy
  Command: @destroy[/<switches>] <object>
 
  This command destroys <object> and refunds its cost of creation to its
  owner. You must own <object> in order to @destroy it, unless its
  DESTROY_OK flag is set, in which case anyone holding it may @destroy it.
  Rooms, exits, and objects may be destroyed. The actual destruction is
  delayed for up to ten minutes (or more, depending on the MUSH's specific
  configuration); the GOING flag is set on these objects. Clearing the
  GOING flag on the object spares it from destruction. Depending on the
  configuration of the MUSH, DESTROY_OK objects may be an exception,
  and would get immediately destroyed.
 
  The @destroy command will not destroy objects with the SAFE flag set unless
  the /override switch is specified.  The DESTROY_OK flag overrides the
  protection given by the SAFE flag.
 
  The following switches are available:
    /instant   - Immediately destroy the object.
    /override  - Negate protection offered by the SAFE flag.
 
  See also: DESTROY_OK, SAFE.
 
& @dig
  Command: @dig[/<switches>] <name> [= <exitlist> [, <exitlist>] ]
  Creates a new room with the specified name and displays its number. This 
  command costs 10 coins. If the [= <exitlist>] option is used, an exit will
  be opened from the current room to the new room automatically.  If the
  second <exitlist> option (after the comma) is specified, an exit from the
  new room back to the current room with the specified [Exits] name is
  opened.  Either exit creation may fail if you do not have sufficient
  rights to the current room to open or link the new exit.
  Example: The command
 
     @dig Kitchen = Kitchen;k;north;n,south;s
 
  will dig a room called Kitchen, and open an exit called 'Kitchen' in your
  current room.  The ; symbol means that you may enter the exit by typing
  'k', 'north' or 'n' also.  This command also opens the exit 'south;s' from
  'Kitchen' back to where you are.  Only the first Exit name is displayed in
  the Obvious exits list.
 
  If you specify the /teleport switch, then you are @teleported to the
  room after it is created and any exits are opened.
 
  See also: @destroy, @link, @open, LINKING, TYPES OF OBJECTS.

& @doing
  Command: @doing[/<switches>] [<message>]
 
  Sets your doing message, which appears after your name in the WHO report.
 
  The following switches are available:
     /message - Sets your Doing string in the WHO report. (default)
     /poll    - Displays the current Doing poll from the WHO report.
 
  See also: WHO.

& @dolist
  Command: @dolist[/<switch>] [<delimiter>] <list>=<action>
 
  <list> is a list of strings, which can be object numbers, attributes, or
  arbitrary words.  <action> is a command to perform once for each item in
  <list>, replacing the special symbol ## with the corresponding item from
  <list>, and the special symbol #@ with the position of the item in the
  list. . By default, @dolist considers each item in <list> to be separated
  with spaces. If you specify the /delimit switch, then each item is
  considered to be separated by <delimiter>. <delimiter> must be a single
  character.
 
  If present, <switch> can be any of:
    /space   - (Default) List elements are separated by spaces.
    /delimit - List elements are separated by <delimiter>.
    /notify  - Queues a "@notify me" after all the @dolist'd commands.
 
  Continued in 'help @dolist2'.
 
& @dolist2
 
  This command is particularly handy with lcon() and lexits(). A few examples:
 
    @dolist [lcon(here)] = "[name(##)](##)
    @dolist [lcon(here)] = @switch [get(##/last)]=*1990*,"[name(##)]
    @va me = va vb vc
    @dolist [get(me/va)] = @emit [get(me/##)]
    @dolist 2 3 4 5=@emit [add(#@,##)]
    @dolist Frodo Bilbo Gandalf = page ## = HELP!!!!  I've fallen into a pit.
    @dolist/delimit , {Frodo, Bilbo Baggins, Gandalf} = page ## = HELP!!!!
 
  See also: iter(), DELIMITERS.

& @drain
  Command: @drain <object>
  Discards all commands waiting on the semaphore <object> and resets the
  semaphore to its initial state.
  See also: @notify, @ps, SEMAPHORES

& @edit
  Command: @edit <object>/<wild-attr> = <search>,<replace>
           @edit <object>/<wild-attr> = ^,<text>
           @edit <object>/<wild-attr> = $,<text>
 
  This command edits the contents of one or more attributes of an object,
  eliminating the need to retype a long attribute in order to make a simple
  change.  In the first form, all occurrences of <search> in the specified
  attribute of the named object are replaced with <replace>.  Use curly
  braces ({ and }) around <search> or <replace> if they contain commas.
  The second and third form prepend and append <text> to the selected
  attributes, respectively.
 
  The output of this command ANSI-hilites the portion of the string
  that was altered. Note that if there are already ANSI characters in
  the string, the results of this highlighting may not reflect the
  actual state of the edited string (since the highlight, by definition,
  inserts a terminating ANSI 'normal' string).
 
  If <wild-attr> contains wildcard characters, then all attributes that
  match are edited.
 
  See also: edit()
 
& @emit
  Command: @emit[/<switches>] <message>
  Sends <message> to everyone in your current location without prefixing it by
  your character name.  You can also send the message to everyone in the room
  that contains the object you are inside with the /room switch.
 
  The following switches are available:
     /here  - Sends the message to everyone in the same location as you.
     /room  - Sends the message to everyone in the room that contains the
             object you are in.  Starting from your location, this switch
             'leaves' objects until it reaches a room, and @emits the message
             there.
  If both switches are specified, the message is sent to both places.  If
  neither is specified, /here is assumed.

  There is an also a '/html' switch, which sends the output in HTML
  format. (Pueblo support only.)
 
  Some MUSHes may restrict the use of this command.
  See also: @femit, @oemit, @pemit, SPOOFING, Pueblo.

& @entrances
  Command: @entrances [[<object>][,<low>[,<high>]]]
 
  Lists links from elsewhere to the specified object (default: your current
  room).  For rooms, exits and drop-to's, leading to the room and players
  and objects whose home is in the room are listed.  For players and objects,
  lists exits leading to them.  Because this command is computationally
  expensive, it costs 100 coins.  <low> and <high> can be used to indicate
  where to start and stop the search, respectively.
 
  You may only use this command on objects that you control.
 
  Examples:
    > @entrances             <- all links to here
    > @entrances object      <- all links to object
    > @entrances ,100,200    <- all links to here from #100 to #200
    > @entrances me,1000     <- all links to me from #1000 and above.
 
  See also: @link, @unlink.

& @femit
  Command: @femit[/<switches>] <object>=<message>
  Forces <object> to emit <message>.  This command is similar to the command
  '@force <object> = @emit <message>', except that it will work so long as
  you own the object, whereas @force may fail if the object has its INHERIT
  flag set and the object performing the @force does not.
 
  The following switches are available:
     /here  - Sends the message to everyone in the same location as <object>.
     /room  - Sends the message to everyone in the room that contains the
              object that <object> is in.  Starting from your location, this
              switch 'leaves' objects until it reaches a room, and @emits the
              message there.

  If both switches are specified, the message is sent to both places.  If
  neither is specified, /here is assumed.
 
  Some MUSHes may restrict the use of this command.
  See also: @emit, @fpose, @fsay, INHERIT, SPOOFING.

& @find
  Command: @find <name>[,<low>[,<high>]]
 
  Displays the name and number of every room, thing, or player that you
  control whose name matches <name>. Because the command is computationally
  expensive, it costs 100 coins.
 
  <low> and <high> may be used to restrict the range of objects that are
  searched, if they are given then the search starts at object #<low> and ends
  at object #<high>.
 
  Examples:
    > @find Lost Room
    > @find Secret Device,12000,14000
  See also: @search.

& @force
  Command: @force <player/object>=<command>
  Forces the game to act as though <player/object> had entered <command>.
  You may only force objects that you control.  Objects may not force players
  unless either the object or the player has their INHERIT flag set, and
  objects that do not have their INHERIT flag set may not force objects that
  do.  If the victim is specified by number, you may use an alternate form
  of the command, '#<number> <command>'.
  See also: puppets.

& @fpose
  Command: @fpose[/<switches>] <object>=<message>
 
  Forces <object> to pose <message>.  This command is similar to the command
  '@force <object> = :<message>', except that it will work so long as you
  own the object, whereas @force may fail if the object has its INHERIT flag
  set and the object performing the @force does not.
 
  The following switches are available:
     /default - (default) Put a space between the name of the object and
                the message (ie, send '<name> <message>').
     /nospace - Don't put a space between the name of the object and the
                message (ie, send '<name><message>').
 
  See also: @femit, @fsay, pose, :, ;, INHERIT.
 
& @fsay
  Command: @fsay <object>=<message>
 
  Forces <object> to say <message>. This command is similar to the command
  '@force <object> = "<message>', except that it will work so long as you
  own the object, whereas @force may fail if the object has its INHERIT
  flag set and the object performing the @force does not.
 
  See also: @femit, @fsay, say, ", INHERIT.
 
& @halt
  Command: @halt [<object>]
  Halts all commands being run by <object>, or by the object running the
  command if no <object> is given.  If the object to be halted is a player,
  then all commands being run by objects owned by that player are halted.
  Use this command to stop runaway objects and infinite loops.
  The process of halting an object involves removing all commands waiting
  to be run by the object from the queue and refunding the queue deposit.
  Halting an object does not affect commands waiting on it as a semaphore.
  See also: @drain, @notify, kill, HALTED, SEMAPHORES.

& @last
  Command: @last <player>
  This command displays a short 'connection history' for <player>, showing
  recent successful and failed connection attempts, as well as the total
  number of successful and failed connections.
  You can only display information about yourself.

& @link
  Command: @link <object>[=<dbref> | here | home | variable]
 
  When used on a player or a thing, this command sets the object's home
  to the indicated location.  The destination must be owned by you or be an
  ABODE room.
 
  When used on a room, this command sets the room's drop-to, where objects
  dropped in the room go.  The destination must be a room that is either owned
  by you or is LINK_OK.
 
  For exits, this command sets the destination if the exit is currently
  unlinked, and you control the destination or it is set LINK_OK. You can
  @link an unlinked exit regardless of who owns it or the lock set on it;
  you are made the owner if you successfully link to the destination. 
 
  Exits can also be linked to the special keyword "variable". The exit's
  destination is determined by evaluating the ExitTo attribute on the exit,
  when a player attempts to move through the exit. Only Wizards and those
  with the link_variable power may link exits in this way, since it allows
  the exit to essentially be linked to any destination.
 
{ 'help @link2' for more }
& @link2
 
  Linking an exit costs 1 coin, and if the exit was owned by someone else,
  you also reimburse the the former owner 1 coin (making the total cost to
  you 2 coins).
 
  If you are not a Wizard and do not have the link_to_anything power, in
  order to link to a destination, you must pass its LinkLock (even if you
  are the owner of that destination). Depending on the server configuration,
  even Wizards might not be able to ignore LinkLocks.
 
  Note that in all the above cases that it is the player performing the @link
  command that must pass the LinkLock, not the object being linked.
  Therefore, you should use the '$' lock qualifier if you want to prevent
  specific players from linking to your LINK_OK locations, as simply locking
  against '*<playername>' does not lock out their puppets.
 
  See also: @dig, @open, @unlink, @exitto, DROP-TOS, HOMES, LINKING.

& @list
  Command: @list [<option>]
  Lists information from internal databases.  Information is available
  about the following options:
    attributes        - Valid object attributes.
    commands          - Commands that you may use (excluding the 
                        attribute-setting commands as well as any exits, and
                        $-commands available).
    config_read_perms - Config parameter read permissions (most will be blank,
                        meaning that anyone can read those parameters).
    costs             - The costs associated with many commands and actions.
    default_flags     - The flags that new objects receive by default
                        when created.
    flags             - The names and letters of all the flags.
    functions         - All the available functions.
    options           - Several global yes/no options.
    params	      - Several global options and limits.
    switches          - What commands support switches and the switches
                        that they do support.
  The information provided by the @list command is definitive, as it reads
  the internal tables to produce the information it displays.  Specifying
  @list with no argument lists the options you may use.

& @listmotd
  Command: @listmotd
  Displays the current message-of-the-day.  Note that it is displayed when
  you connect to your character.

& @lock
  Command: @lock[/<whichlock>] <object>=<key>
           @lock <object>/<attrib>
 
  The first form locks <object> to a specific key(s).  Type 'help @lock keys'
  for a list of the keys you may use.
 
  <whichlock> indicates which lock you want to set on the object.  If you
  don't specify one, you set the Default lock. Type 'help @lock locks' for
  a list of the locks you may set and what they are used for.
 
  The second form locks the indicated attribute of the named object, so that
  when the object is @chowned, the attribute will remain owned by you.
  It may also be used when you own an attribute on an object that you do not
  own, in this case it prevents the object's owner from @chowning the
  attribute to himself, and prevents anyone from modifying or removing the
  attribute.
 
  See also: @chown, @unlock.

& @lock locks
  You can set the following locks:
 
     DefaultLock:  Exits:          controls who may traverse the exit to
                                   its destination.
                   Rooms:          controls whether the player sees the SUCC
                                   or FAIL message for the room following the
                                   room description when looking at the room.
                   Players/Things: controls who may GET the object.
     ChownLock:    All:            controls who may @chown the object if the
                                   object is CHOWN_OK.
     ControlLock:  All:            controls which objects can Control this
                                   object (only checked if CONTROL_OK flag
                                   is set).
     DropLock:     Players/Things: controls who may DROP the object.
     EnterLock:    Players/Things: controls who may ENTER the object if the
                                   object is ENTER_OK.
     GiveLock:     Players/Things: controls who may give the object.
     LeaveLock:    Players/Things: controls who may LEAVE the object.
  
{ 'help @lock locks2' for more }
& @lock locks2
 
     LinkLock:     All but Exits:  controls who may link to the location if the
                                   location is LINK_OK (for linking exits or
                                   setting drop-tos) or ABODE (for setting
                                   homes).
     PageLock:     Players:        controls who may page the player.
     ParentLock:   All:            controls who may make @parent links to the
                                   object.
     ReceiveLock:  Players/Things: controls who may give things to the object.
     SpeechLock:   All but Exits:  controls who may speak in this location
                                   (only checked if the AUDITORIUM flag is
                                   set on that location)
     TeloutLock:   All but Exits:  controls who may teleport out of the
                                   location.
     TportLock:    Rooms/Things:   controls who may teleport there if the
                                   location is JUMP_OK.
 
{ 'help @lock locks3' for more }
 
& @lock locks3
 
     UseLock:      All but Exits:  controls who may USE the object, GIVE the
                                   object money and have the PAY attributes
                                   run, have their messages heard and possibly
                                   acted on by LISTEN and AxHEAR, and invoke
                                   $-commands stored on the object.
     UserLock:     All:            Not used by MUSH, is intended to be used
                                   in MUSH programming where a user-defined
                                   lock is needed.
 
& @Lock keys
 
  You may use the following keys when setting locks.  For information about
  a particular type of key, type 'help @lock <keytype>'.
 
  Key Type    Form in @Lock Command
  ----------  ------------------------------
  Normal      <object>
  Is          =<object>
  Carry       +<object>
  Ownership   $<object>
  Indirect    @<object>
  Attribute   <attribute>:<wildcard-pattern>
              +<attribute>:<wildcard-pattern>
              =<attribute>:<wildcard-pattern>
  Evaluation  <attribute>/<value>
  Compound    <key> & <key>
              <key> | <key>
              !<key>
              ( <key> )

& @lock attribute
  ATTRIBUTE LOCKS:
 
  Key: <attribute>:<pattern>
       +<attribute>:<wildcard-pattern>
       =<attribute>:<wildcard-pattern>
 
  You may lock on whether a specific attribute on the player attempting to
  pass the lock matches a pattern.  Example: '@lock thing=sex:m*' will lock
  thing to anyone whose sex starts with an M. Wild cards, greater than and
  less than may be used, for example: '@lock a-f=name:<g' will lock the exit
  a-f against any one whose name is higher than f.
 
  Both the player testing the lock and every object in his inventory is
  checked, the player passes the lock if any of those objects passes the lock.
  If the attribute name is prefixed by a = then only the player is checked.
  Similarly, if the attribute name is prefixed by a + then only objects in
  the player's inventory are tested.
 
{ 'help @lock attribute2' for more }
& @lock attribute2
  Note: you may lock against any attribute, but the locked object must be
  able to read the attribute from the player attempting to pass the lock or
  the lock will fail.
 
  Examples:
    > @lock men's room=sex:m*
    > @lock a-f=name:<g
    > @lock post office=email:*@*
  See also: ATTRIBUTE OWNERSHIP, @lock evaluation.

& @lock evaluation
  Topic: EVALUATION LOCKS
 
  Key: <attribute>/<value>
 
  Evaluation locks let you evaluate one of your attributes and compare the 
  result against a value stored in the lock.  The result must be an exact
  match (no wildcarding allowed, but uppercase and lowercase are considered
  to be the same).  When evaluating the attribute the enactor substitutions
  (%#/%n/etc) are replaced with information about the player trying to pass
  the lock, and 'me' and %! refer to the locked object or exit.
 
  If you call an indirect lock and the indirect lock is an evaluation lock
  (or is a compound lock that includes an evaluation lock), then the original
  lock object is checked for the attribute first, followed by the object that
  has the actual evaluation lock.  If there are multiple levels of indirection
  the intermediate locks are not checked.
 
{ 'help @lock evaluation2' for more }
& @lock evaluation2
  Examples:
    > @lock bank=checkmoney/1
    > &checkmoney bank=[gt(money(%#),5000)]
    Only people and objects with more than 5000 pennies may pass.
    Note: this lock requires wizard privileges to read the worth of other
    players.
 
    > @lock divisible_by_five_club = checkdiv/0
    > &checkdiv divisible_by_five_club = [mod(mid(%#,2,20),5)]
    Only objects whose db-number is divisible by 5 may pass.
  See also: @lock attributes.

& @lock indirect
  Topic: INDIRECT LOCKS
 
  Key: @<object>
 
  You may reference the lock on another object and use the result of
  evaluating that other object's lock.    You pass an indirect lock if you
  pass the default lock on <object>.  This is especially useful if you
  have a large number of objects or exits that want to have the same lock,
  and you want to be able to update one object and have all the other
  locks change at the same time.
 
  <object> is searched for when you enter the @lock command and its
  database number is stored in the lock, so something like
  '@Lock north=@master.lock' is safe even if you are going to move master.lock
  to another location.
 
  Examples:
    > @lock master.lock = me
    > @lock north = @master.lock
    > @lock south = @master.lock
    North and south all reference the lock on master.lock, so you may change
    the lock on all three exits by changing master.lock.
  See also: @lock normal.

& @lock normal
  Topic: NORMAL LOCKS
 
  Key: <object>
 
  You pass a normal lock if you either are the named object or if you carry
  the named object.  <object> may be the name or #number of a thing,  a
  playername prefixed by an asterisk (*<playername>), 'me', or 'here'.
 
  Examples:
    > @lock treasure room = secret key
    > @lock private area = me
  See also: @lock is, @lock carry.

& @lock is
  Topic: IS LOCKS
 
  Key: =<object>
 
  You pass an is lock only if you are the named object.
 
  Example:
    > @lock mystical highway = =magic bus
    Only the magic bus may travel down the mystical highway.  You cannot
    travel the highway if you are carrying the bus.
  See also: @lock carry, @lock normal.

& @lock carry
  Topic: CARRY LOCKS
 
  Key: +<object>
 
  You pass a carry lock if you are carrying the named object.
 
  Example:
    > @lock secret passage = +magic bus
    You can only traverse the secret passage if you are carrying the
    magic bus.  The bus cannot enter the passage on its own (perhaps
    when you are driving it).
  See also: @lock is, @lock normal.

& @lock ownership
  Topic: OWNERSHIP LOCKS
 
  Key: $<object>
 
  You pass an ownership lock if you have the same owner as <object>.
 
  Examples:
    > @lock mystuff=$me
    Only objects you own may use the mystuff exit.
 
    > @lock/page me = !$*TinyJerk
    Neither TinyJerk nor any of his objects may page you.
  See also: @lock normal.

& @lock compound
  Topic: COMPOUND LOCKS
 
  Key: <key> & <key>
       <key> | <key>
       !<key>
       ( <key> )
 
  You can make complex locks by combining keys with the logical AND and OR
  operators (& and ! respectively), or by using the NOT operator.  You
  may also group complex locks with parentheses.
 
  Examples:
    > @lock exit = me & !me
    An impossible lock, nothing can be both you and not you.
 
    > @lock message = me | *recipient
    Both you and the player recipient may get the message.

& @mvattr
  Command: @mvattr <object>=<old>,<new>[,<copy1>]...
  This command moves attributes around on an object.  The attribute <old> is
  renamed <new> (and is copied to <copy1>, <copy2> and so on if specified).
  If you cannot modify the <old> attribute (for instance if you are trying to
  move the Last attribute, or if it were owned by another player), then a new
  copy is made and the original is not removed.
  See also: @set.

& @name
  Command: @name <object> = <new name>

  Changes the name of <object>.  <object> can be a thing, player, exit, or
  room, specified as <name> or #<dbref> or 'me' or 'here'.
 
  See '@list options' as to whether or not a player name may contain 
  spaces.

& @notify
  Command: @notify[/<switches>] <object>[/<attribute>][=<count>]
 
  Notifies the semaphore <object>, running the first command that waited on
  <object> using the semaphore-wait forms of the @wait command. If <count>
  is specified, it indicates the number of times the semaphore is notified.
  If there are no commands (or less than <count> commands) pending for
  <object>, then subsequent @waits will not block until the semaphore count
  reaches zero again. If <attribute> is specified, it notifies commands that
  are blocking on an attribute other than the default 'Semaphore'.
 
  The following switches are available:
     /first - (default) Notify the first command waiting on the indicated
              semaphore (or the first <count> commands).
     /all   - Notify all commands waiting on the semaphore and reset the
              semaphore count to zero.  <count> is ignored.
 
  See also: @drain, @ps, @wait, SEMAPHORES

& @npemit
  Command: @npemit <object>=<message>
 
  Sends the unparsed contents of <message> to <object>, in a fashion akin
  to @pemit. This differs from @pemit/noeval in that <message> is completely
  untouched -- no space compression is done.
 
  See also: @pemit
 
& @oemit
  Command: @oemit <player>=<message>
  Emits <message> to everyone in your current location except for <player>.
  See also:  @emit, @pemit, SPOOFING.

& @open
  Command: @open[/<switches>] <direction list> [=<number>[,<direction list>]]
  Creates an exit in the specified direction(s). If <number> is specified,
  it is linked to that room. Otherwise, it is created unlinked. You or anyone
  else may use the '@link' command to specify where the unlinked exit leads.
  Opening an exit costs 1 coin. If you specify <number>, linking costs 1 more
  coin.  You can specify a second direction list (after the comma), which is 
  automatically opened in the room that the new exit goes TO and which is
  linked back to where you are.  I.e.  @open north;n=#1234,south;s
  would open exit 'north;n' from here to #1234, and an exit 'south;s'
  from #1234 to here, assuming you have rights to open exits and link to
  the rooms in question.
 
  The following switches are available:
     /location  - Create the exit in your location (default).
     /inventory - Create the exit on yourself.
 
  See also: @dig, @link, LINKING.

& @parent
  Command: @parent <object> [=<parent>]
 
  The command sets the parent of <object> to <parent> (or clears the parent
  if <parent> is omitted.  You must control <object>, and must own <parent>,
  or <parent> must be set PARENT_OK.
 
  See also: PARENT OBJECTS.

& PARENT OBJECTS
  Topic: PARENT OBJECTS
 
  Parent objects provide a way for several objects to inherit common
  attributes, exits, and $-commands from a single object, so that changing
  the parent object affects all of its children.  When searching for
  attributes or exits, first the object itself is checked, then the parent
  is checked only if the object does not have what was searched for.
 
  Any attribute the parent object has will be passed down to its children,
  if they don't already have one. For instance, if the child object has no
  description, it will inherit the description of its parent.
 
  Any exits the parent object has will show up in the exit list of the
  child, and may be used as normal exits.
 
  The parent is searched for $-commands as well as the child, unless the
  parent is uselocked against the player. The child's attributes take
  precedence over the parent's; precedence is checked by attribute name,
  NOT by $-command name.
 
{ 'help parent2' for more }
& PARENT2 
  Topic: PARENT OBJECTS (continued)
 
  A parent object may itself have a parent, up to a configurable limit
  (usually 10 levels).  The parent need not be the same type as its children,
  and flags and locks are not inherited from parent objects.  You may not
  create parent loops.
 
  See also: @parent, parent().

& @password
  Command: @password <old password>=<new password>
 
  This command changes your password.

& @pemit
  Command: @pemit[/switches] <what>=<message>
 
  Emits <message> only to <what>, or to <what>'s contents of the /contents
  switch is given.  <what> must be either in the same location as you or
  be something you own.  You can also @pemit to distant players if
  pagelocks allow you to page them, and this costs as much as a page
  <This feature is not present in all MUSHes>.  You cannot @pemit to the
  contents of something you don't own.
 
  The /list switch to this command allows you to @pemit a message to
  a list:  @pemit/list <object 1> [<object 2> <object N>] = <message>
  There can be any number of objects in the list. The objects must be
  specified by dbref number. This can be combined with other switches.
  
  The following other switches are available:
    /contents - Send the message to the contents of the named object.
    /object   - Send the message to the named object.
    /noeval   - Send the message unparsed.
    /html     - Send the message in HTML format. (Pueblo support only.)
 
  See also: page, @emit, @oemit, SPOOFING, Pueblo.

& @program
  Command: @program <player> = <object>/<attribute>[:<prefix>]
 
  This command allows player input to be sent directly to another command,
  bypassing all other commands, built-in or otherwise. <player> will be
  placed into program mode, and prompted with <prefix> if specified, as
  well as a "> " input prompt. When the player next types something,
  you (the person who initiated the @program) will execute the contents
  of <object>/<attribute>, with the player's input as %0 and the player
  as the enactor (%N, %#). Note that this is the value of the attribute
  at the time the @program was initiated, NOT the value at the time the
  player enters input.
 
  The programming object must control <player>, or it or its owner must
  have the Program power. It must also be able to see <attribute> on
  <object>. <player> must be a connected player, and programs are cleared
  when a player logs out.
 
  Continued in 'help @program2'.
 
& @program2
 
  A player currently within a program can have input processed normally
  by prefixing that input with a '|', i.e., '|WHO' rather than 'WHO', etc.
  Programs can also be aborted through the '@quitprogram' command; note
  that if your input is currently being absorbed by a program, you will
  need to type '|@quitprogram'.
 
  Examples are given in 'help @program3'.
 
& @program3
 
  An example:
 
    ] @va Object = $try it: @program %#=me/VB:Please enter some words.
    ] @vb Object = @emit Text '%0' entered by %N.; @program %#=me/VC
    ] @vb Object = @emit More text '%0' entered by %N. Done.
    ] try it
    Please enter some words.
    > here are some words
    Text 'here are some words' entered by Wizard.
    > even more words
    More text 'even more words' entered by Wizard. Done.
 
  Another example:
 
    ] @va Object1 = $try it: @program %#=Object2/VB:Try it out.
    ] @vb Object2 = :shows: Text '%0' entered by %N.
    ] try it
    Try it out.
    > testing this
    Object1 shows: Text 'testing this' entered by Wizard.

& @quitprogram
  Command: @quitprogram [<player>]
 
  Terminates the @program being run by <player>. If <player> is not
  specified, it is assumed to be the enactor.
 
  Note that this command is issued for the player whose input is
  being absorbed, not the object that is controlling the program.
 
  Also note that if a player's input is currently being absorbed
  by the @program, that the player needs to type '|@quitprogram'
  rather than '@quitprogram' in order to get out of it.
 
  See also:  @program.

& @ps
  Command: @ps[/<switches>] [<object>]
  Lists information about the commands you have on each of the queues.
  Unless the /summary switch is used, this command lists all the commands you
  have on the queues, optionally along with their enactor and arguments.
  Commands scheduled to be executed at a later time (by the @wait command)
  also show the number of seconds until they will be executed and/or the
  semaphore on which they are waiting.  If <object> is specified, only
  commands run by <object> are listed, otherwise all commands run by any of
  your objects is listed.  A summary of the number of commands listed and the
  total number of commands in the queues is also displayed.  This command is
  useful for identifying infinite loops in programs.
 
  The following switches are available:
     /brief   - (default) Display a brief summary that shows the semaphore
                number, time-to-wait, object running the command, and the
                command to be run.
     /long    - In addition to the information in the /brief report, display
                the name and number of the object that caused the command
                to be run (the enactor) and the arguments to the command.
     /summary - Display just the queue counts.
 
  See also: @notify, @wait.

& @quota
  Command: @quota
  Lists your total building quota and the amount you have remaining.
  Creating objects, digging rooms, and opening exits all consume quota.
  See also: @create, @dig, @open.

& @robot
  Command: @robot <name>=<password>
  Creates a robot player owned by you.  The robot has its ROBOT flag set, so
  it may use the OUTPUTPREFIX and OUTPUTSUFFIX commands that most publicly
  available robot programs require.  This command costs 1000 coins.
  Note that some sites do not restrict OUTPUTSUFFIX and OUTPUTPREFIX to
  robots.
  See also: OUTPUTPREFIX, OUTPUTSUFFIX, ROBOT, TYPES OF OBJECTS.

& @search
  Command: @search [<player>] [<class>=<restriction>[,<low>[,<high>]]]
 
  Displays information about objects that meet the search criteria.
  Because this command is computationally expensive, it costs 100 coins.
  <player> restricts the search to the named player, while <class>
  and <restriction> control the objects listed.  Type 'help search classes'
  for a list of the classes you may use.

  Except when getting lists of players ('@search type=player' or
  '@search flags=P'), you may only search for objects that you own.
  You may limit the range of the search with <low> and <high>, which specify
  the objects to start and stop the search at, respectively.  The default for
  <low> is #0 and the default for <high> is the last object in the database.
 
  Examples:
    @search flags=PWc              <-- search for connected wizards.
    @search type=room              <-- list all rooms owned by me.
    @search eval=gt(money(##),10)  <-- search for things worth more than 10.
    @search type=room,100,300      <-- Rooms between #100 and #300, inclusive
    @search object=Test,5000       <-- Things starting with Test from object
                                       #5000 to the end of the database.
  See also: @find, search().
& @set
  Command: @set <object>=[!]<flag>
           @set <object>=<attribute>:<value>
           @set <object>=<attribute>:_<fromobj>/<fromattr>
           @set <object>/<attr>=[!]<attrflag>
 
  The first form sets (or clears) the indicated flag on <object>, the
  second form sets the <attribute> attribute on <object> to <value>,
  creating a new user-named attribute if there is no attribute named
  <attribute>.  The third form copies an attribute from another object, and
  the fourth form sets (or clears) an attribute flag on the <attr> attribute
  of <object>.
 
  When setting attributes on an object, you may also use the command
  '@<attribute> <object> = <value>' if the attribute is a predefined
  attribute.  You may also use the command '&<attribute> <object> = <value>'
  to set either predefined attributes or user-named attributes.  Either of
  these is equivalent to the second form of the @set command.
 
  Continued in 'help @set2'.

& @set2
  The following flags may be set using the fourth form of the @set command;
  they are displayed when the attribute is examined.
 
     hidden     - Wiz-only. Prevent mortals from seeing the attribute. (M)
     html       - When used as part of an Attr/OAttr/AAtr trio (as in @verb,
                  @enter, etc.), the Attr is not HTML-escaped (see Pueblo). (H)
     no_command - Prevent $-commands and ^-patterns defined in the attribute
                  from being performed. ($)
     no_inherit - Prevents children of the object from obtaining the 
                  attribute.  From their perspective the attribute does not
                  exist. (I)
     no_parse   - When $-commands are matched, the unparsed (non-evaluated)
                  string is used. Useful for MUSH editors. (P)
     regexp     - When $-commands are matched, treat the pattern as a 
                  regular expression rather than a wildcard glob pattern. (R)
     visual     - Anyone may see the attribute when they examine you, and
                  may get the attribute with get(). (V)
     wizard     - Wiz-only. Prevent mortals from changing the attribute. (w)
 
  Continue in 'help @set3'.

& @set3
  The folowing flags are unsettable:
 
     locked	- @lock'd attributes. (+)
     dark	- Attribute which can only be seen by God. (d)
     god	- Attribute which can only be changed by God. (g)
 
  See also: @lock, @lock, examine, FLAGS, REGEXPS.
 
& @sql
  Command: @sql <SQL query string>
 
  This command sends a SQL statement to an external SQL database and
  returns the results. The user must be God or have the use_sql power
  (note that even having a Wizard flag is not sufficient).
 
  See 'help SQL2' for details and examples.
 
& @stats
  Command: @stats[/all] [<player>]
 
  Without any switches or additional arguments, this command displays
  the number of objects in the database, and the dbref of the next item
  that will be created. This version of the command is free.
 
  @stats/all gives a  breakdown by object types. If <player> is specified,
  the breakdown for the named player is given. You may only list individual
  counts for yourself. These versions of the command are computationally
  expensive, and cost the same as a @search.
 
  See also: stats().

& @sweep
  Command: @sweep[/<switches>]
  This command tells you all of the objects, players, and exits that are
  listening in the room you are currently in, as well as the objects you are
  carrying.  Most objects only listen for a particular string or phrase, so
  they normally do not pose a problem if you need privacy.  You will have to 
  be careful of players, puppets, and audible exits since they will hear
  everything you say and do.  There are several switches that may be used to
  limit the type of listeners that are checked for.  They are:
     /here      - Check the room I am in.
     /inventory - Check my inventory.
     /exits     - Check exits in the room.
 
     /commands  - Check for objects that have $-commands set on them.
     /connected - Check for connected players and their puppets.
     /listeners - Check for objects with @listen set to something.
     /players   - Check for players and their puppets, whether or not they
                  are connected.
 
  The default is to search for everything.  If you specify one or more
  switches from either category (either location or listener type then only
  that location or listener type is checked.
  See also: @listen, AUDIBLE, PUPPETS.

& @switch
  Command: @switch[/<switches>] <string>=<t1>,<c1> [,<tN>,<cN>]... [,<cD>]
  Compares <string> against the targets <t1>, <t2>, etc, until a match is
  found, at which time the corresponding list of commands is performed.
  Wildcards, and the < and > operators are allowed in the targets.  By
  default, any list whose target matches the string is executed (the targets
  are not mutually exclusive). If no target matches, the default list
  <cD> is executed. The evaluated value of <string> can be obtained as '#$'.
 
  The following switches are available:
     /all   - (default) Perform the actionlists associated with all targets
              that match <string>.
     /first - Perform only the actionlist associated with the first target
              that matches <string>.

& @teleport
  Command: @teleport [<object>=] <room/thing>
           @teleport [<object>=] <exit>
           @teleport [<object>=] home
 
  The first form of the @teleport command moves <object> (or you) to the named
  room or thing.  The second form sends <object> (or you) to the destination
  of the named exit, while the third form sends <object> (or you) home.
  If the destination room has a drop-to, the object will go to the drop-to
  instead of the named location.

  For the first form of the @teleport command, the object being teleported 
  must pass its location's TeloutLock; and you must control the destination,
  or it must be JUMP_OK and you must pass the destination's TportLock.
 
  The second and third forms let you remove any object from locations you
  control by sending them through an exit or to their home.
 
  The following switch is available:
      /quiet - Suppresses @succ/@osucc/@fail/@ofail/etc. messages.
 
  See also: JUMP_OK, @lock (tport and telout), @tfail, @otfail, @atfail,
            @tofail, @otofail, @atofail

& @trigger 
  Command: @trigger[/<switch>] <object>/<attr> [=<param> [, <param>]... ]
 
  Invokes an action list stored in an attribute on an object.  The triggering
  object becomes the enactor and the positional parameters %0 through %9
  are set to the supplied parameters.  If the /quiet switch is given,
  the "Triggered." message will be omitted.
 
  See also: LOOPING.

& @unlink
  Command: @unlink <room/exit>
  This command removes drop-tos on rooms and clears the destination on exits.
  Once unlinked, an exit may be taken over by anyone with the @link command.
  See also: @link, LINKING.

& @unlock
  Command: @unlock <object>
           @unlock <object>/<attrib>
  The first form removes the lock on <object>, so that anyone may pass
  through (if an exit) or pick it up (if a player or an object).
 
  The second form clears the locked flag on the indicated attribute of the
  named object.  This allows the attribute to change ownership to the new
  owner automatically when the object is @chowned, and allows the owner
  of the object to @chown the attribute to themself or to overwrite it.
  You must own the attribute to be unlocked, but you do not need to own the
  object.
  See also: @chown, @lock, ATTRIBUTE OWNERSHIP.

& @verb
  Command: @verb <victim>=<actor>,<what>,<def>,<owhat>,<odef>,<awhat>,<args>
 
  This command provides a way to do user-defined verbs with associated
  @attr/@oattr/@aattr groups. Invoking it does the following:
  
  <actor> sees the contents of <victim>'s <what> attribute, or
    the <def> string if you can't read <victim>'s <what> attribute.
  Everyone in the same room as <actor> sees the contents of
    <victim>'s <owhat> attribute, with <actor>'s name prepended,
    or <odef>, also with <actor>'s name prepended, if you can't read
    <victim>'s <owhat> attribute.
  If you control <victim>, then he executes the contents of his <awhat>
    attribute.
  
  By supplying up to nine <args>, you may pass those values on
  the stack (i.e. %0, %1, %2, etc. up through %9).
 
  You must control the actor, but need not control the victim.  Note that
  if you don't have the ability to read the appropriate attributes (whether
  because you control the victim, he is VISUAL, or the attributes are set
  VISUAL), the default messages will be used.
 
{ 'help @verb2' for more }
& @verb2
  Here is a description of the arguments to @verb:
    victim - The object that is searched for attributes, and which runs the
             <awhat> attribute if it is found.
    actor  - The object that 'did' the verb, this is the value for %#/%n/etc
             in substitutions, and this object's name is included in the
             message to others in the same location.
    what   - The name of the attribute containing the message to be delivered
             to the actor.
    whatd  - The message to deliver to the actor if the victim does not have a
             <what> attribute, or if it cannot be read.
    owhat  - The name of the attribute containing the message (prefixed by the
             actor's name) that is sent to everyone in the room with the actor.
    owhatd - The message (prefixed by the actor's name) to deliver to others
             in the room with the actor if the victim does not have an <owhat>
             attribute, or it cannot be read.
    awhat  - The name of the attribute that is to be executed by the victim.
    args   - The comma-separated arguments to be passed for substitution
             (%0-%9).  If there is more than one argument, enclose all the
             arguments within curly braces.  Any argument that contains an
             embedded comma needs to be enclosed in curly braces as well.
 
{ 'help @verb3' for more }
& @verb3
  Examples:
    > &xtest test1=You just xtested test1.
    > &oxtest test1=just xtested test1.
    > &axtest test1="I was xtested.  Yikes.  Arg1=%0, Arg2=%1, Arg3=%2.
    > @verb test1=me,xtest,XTEST DFLT,oxtest,OXTEST DFLT,axtest,{a,b c,de}
    You just xtested test1.
    test1 says "I was xtested. Yikes. Arg1=a, Arg2=b c, Arg3=de."
    > &xtest test1
    > @verb test1=me,xtest,XTEST DFLT,oxtest,OXTEST DFLT,axtest,{a,b c,de}
    XTEST DFLT
    test1 says "I was xtested. Yikes. Arg1=a, Arg2=b c, Arg3=de."
    > @fo test1={@verb test1=me,xtest,XTEST D,oxtest,OXTEST D,axtest,{a,b,de}} 
    test1 just xtested test1.
    test1 says "I was xtested. Yikes. Arg1=a, Arg2=b, Arg3=de."
  See also: locate().

& @wait
  Command: @wait <seconds>=<command>
           @wait <object>[/<seconds>]=<command>
           @wait <object>/<attribute>=<command>
 
  The first form of @wait executes <command> after <seconds> seconds.
  The second form increments the semaphore count for <object> and executes
  <command> after <object> is notified with the @notify command.  If the
  semaphore count for <object> is negative (because it has been notified more
  times than it has been waited on), then <command> is run immediately.
  If <seconds> is specified in the second form, the command is automatically
  run after <seconds> seconds even if the semaphore isn't notified.
  The third form is identical to the second, except that the semaphore
  count is stored in the specified attribute, rather than Semaphore.
 
  This command charges a deposit of 10 coins, which is refunded when
  <command> is executed.
 
  See also: @drain, @notify, @ps, SEMAPHORES.
 
& @wipe
  Command: @wipe <object>[/<wild-attr>]
 
  This command erases attributes from an object.  All attributes that match
  <wild-attr> (or all attributes, if <wild-attr> is not specified) are removed
  from <object>.  Attributes that you do not have permission to modify (such
  as read-only or locked attributes) are not removed.

& @aahear
  Command: @aahear <object> = <command-list>
  Attribute: Aahear
 
  An Aahear on an object is activated whenever the listen pattern
  matches anything done/said by anything else in the room, including
  itself.  (The Ahear ignores itself, helpful for keeping machines from 
  triggering itself)
 
  Example: @aahear listener = "I heard someone (maybe me?) say the word!
  See also: @ahear, @amhear, @listen.

& @aclone
  Command: @aclone <object> = <command-list>
  Attribute: Aclone
 
  Sets the actions to be taken by a new object that has just been created
  as the result of a @clone command.  The contents of the Aclone attribute
  are run by the new object and not by the old object.
 
  This attribute is only meaningful for things, and will never be
  automatically triggered on other object types.
 
  Example: @aclone Time bomb = @wait 600=@trig me/va;@wait 10=@trig me/vb
           @va time bomb = :EXPLODES with a thundering roar;@destroy me
           @vb time bomb = :ticks.; @wait 10=@trig me/vb
  See also: @clone.

& @aconnect
  Command: @aconnect <object> = <command-list>
  Attribute: Aconnect
 
  Sets the actions to be taken by a player right after connecting to the
  game.  This attribute is only meaningful for players, and will never be
  automatically triggered on other object types, with one exception.
 
  If the Global aconnects/adisconnects are executed, when a player logs
  in, any Master Room object with an @aconnect on it runs that attribute,
  with the player as the Enactor. Note that the object, NOT the connecting
  player, executes that attribute.
 
  Example: @aconnect me = check.my.mailbox
 
  See also: @adisconnect.

& @adescribe
  Command: @adescribe <object> = <command-list>
  Attribute: Adescribe
 
  Sets the actions to be taken when <object> is looked at.
 
  Example: @adesc kitten = :rubs against %n's legs affectionately.
  See also: look, @desc, @idesc, @odesc.

& @adfail
  Command: @adfail <object> = <command-list>
  Attribute: Adfail
 
  Sets the action to be taken by an object when someone tries to drop it
  but fails because they didn't pass the object's drop lock.
 
  Example: @adfail sword = @name me=Cursed Sword;:laughs maniacally.
  See also: drop, @dfail, @odfail, @lock.

& @adisconnect
  Command: @adisconnect <object> = <command-list>
  Attribute: Adisconnect
 
  Sets the actions to be taken by a player right after disconnecting from
  the game. This attribute is only meaningful for players, and will never be
  automatically triggered on other object types, with one exception.
 
  If the Global aconnects/adisconnects are executed, when a player logs
  out, any Master Room object with an @adisconnect on it runs that attribute,
  with the player as the Enactor. Note that the object, NOT the connecting
  player, executes that attribute.
 
  The stack variable '%0' can be used to obtain the disconnect reason,
  which will be one of the following:  'quit' (typed QUIT), 'logout'
  (typed LOGOUT), 'netdeath' (player's end of the connection dropped),
  'timeout' (idled out), 'boot' (@boot'd, @toad'd, or @destroy'd),
  'shutdown' (game shutdown), 'nologins' (game full), or 'unknown'.
 
  Example: @adisconnect me = home
 
  See also: @aconnect.

& @adrop
  Command: @adrop <object> = <command-list>
  Attribute: Adrop
 
  Sets the action to be taken by an object when it is dropped, or by an exit
  when it is successfully used.
 
  Example: @adrop plastique = kill %n=100; @destroy me
  See also: drop, @drop, @odrop, DROP-TO, EXITS.

& @aefail
  Command: @aefail <object> = <command-list>
  Attribute: Aefail
 
  Sets the action to be taken by an object when someone tries to enter it
  but fails because the object is not ENTER_OK or the player fails the
  object's enter lock.
 
  The enter lock only affects the 'enter' command and its aliases (set via
  the @ealias command), it does not affect exits that lead to the object or
  teleporting in.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @aefail car = @emit ;'s alarm starts wailing when %n tries
                         to break in.
  See also: @aenter, @efail, @ealias, @enter, @oefail, @oenter, enter,
            ENTER_OK.

& @aenter
  Command: @aenter <object> = <command-list>
  Attribute: Aenter
 
  Sets the action to be taken by an object or room when someone enters it,
  whether by using an exit, the enter or leave commands, or by teleporting.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @aenter car = :starts its engine, eagerly awaiting a road trip.;
                         "Beep Beep!
  See also: enter, @enter, @oenter, ENTER_OK.

& @afail
  Command: @afail <object> = <command-list>
  Attribute: Afail
 
  Sets the commands to be performed by <object> when one of these events
  occurs:
 
    - For exits: Someone tries to traverse the exit but cannot because they
      fail the exit's default lock or the exit is not linked.
    - For players and things: Someone tries to pick up the object but cannot
      because they fail the object's default lock.
    - For rooms, players, and things: Someone looks around inside the room,
      player, or thing and fails the object's default lock.
 
  Example:
    > @afail vase = :falls to the floor and smashes to pieces.;@destroy me
  See also: @fail, @ofail, FAILURE.

& @agfail
  Command: @agfail <object> = <command-list>
  Attribute: Agfail
 
  Sets the action to be taken by an object when someone tries to give it
  away but fails because they didn't pass the object's give lock.
 
  Example: @agfail sword = @name me=Cursed Sword;:laughs maniacally.
  See also: give, @gfail, @ogfail, @lock.

& @ahear
  Command: @ahear <object> = <command-list>
  Attribute: Ahear
 
  Sets the actions to be taken after the object hears a string that matches
  the pattern in the Listen attribute which was not produced by the object
  itself.  Messages that are produced by the object itself are ignored.
 
  Example: @ahear clock = "The time is now [time()].  >> BONNNNGGGGG <<
  See also: @aahear, @amhear, @listen.

& @akill
  Command: @akill <object> = <command-list>
  Attribute: Akill
 
  Sets the actions to be taken by an object after it is killed and has
  returned to its home.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @akill lion = south; :leaps onto %n, roaring loudly.;kill %n=100
  See also: kill, @kill and @okill, BEING KILLED, IMMORTAL, WIZARD.

& @aleave
  Command: @aleave <object> = <command-list>
  Attribute: Aleave
 
  Sets the action to be taken by an object or room when someone leaves it,
  whether by using an exit, the enter or leave commands, or by teleporting.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @aleave car = :stops to let %n out.;:revs its engine, hoping
                         another brave soul would like a ride.
  See also: leave, @leave, @oleave.

& @alfail
  Command: @alfail <object> = <command-list>
  Attribute: Alfail
 
  Sets the action to be taken by an object when someone tries to leave it
  but fails because the player fails the object's leave lock.
 
  The leave lock only affects the 'leave' command and its aliases (set via
  the @ealias command), it does not affect going home, using an exit in the
  location, or teleporting out.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @alfail box = :rattles around as %n tries to escape.
  See also: @aleave, @lalias, @leave, @lfail, @oleave, @olfail, leave.

& @alias
  Command: @alias <player> = <name>
  Attribute: Alias
 
  Provides an alternate name by which the player is known.  The alternate
  name is only used for players when referenced as '*<name>' or by commands
  that only take playernames (such as page or @stats).  You may not set
  an alias on any other object type.
 
  When setting an alias, the alias is checked to see that it is both a legal
  player name and not already in use.  Only if both checks succeed is the
  alias set.
 
& @amhear
  Command: @amhear <object> = <command-list>
  Attribute: Amhear
 
  Sets the actions to be taken after the object hears a string that matches
  the pattern in the Listen attribute which was produced by the object
  itself.
  Messages that are produced by anything other than the object itself are
  ignored.
 
  Example: @amhear listener = "Wait a minute.  I said the trigger word!
  See also: @aahear, @ahear, @listen.

& @amove
  Command: @amove <object> = <command-list>
  Attribute: Amove
 
  Sets the action to be taken by an object whenever it moves from one 
  location to another, whether by using an exit, entering or leaving an
  object, teleporting, or going home.
 
  This attribute is meaningful for players, and things and will never be
  automatically triggered on other object types.
 
  Example: @amove car = @vz me=[extract(%vz,1,19)] [loc(me)]
  See also: @move, @omove.

& @apay
  Command: @apay <object> = <command-list>
  Attribute: Apay
 
  Sets the actions to be taken after the object is given the number of coins
  specified in its Cost attribute.  If the giver tries to give more than that
  number of coins, the excess is refunded, and if less than the necessary
  amount is given then it is all given back and a snide message is sent to
  the giver.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @apay Coke machine = @clone Can of Coke; :drops a can on the
                                floor.
  See also: give, @cost, @opay, @pay.

& @arfail
  Command: @arfail <object> = <command-list>
  Attribute: Arfail
 
  Sets the action to be taken by an object when someone tries to give it
  something that fails its give lock.
 
  Example: @arfail merchant = "I don't buy such junk.  Begone!;
                              @tel %#=cheater_exit
  See also: give, @agfail, @gfail, @ogfail, @orfail, @rfail, @lock.

& @asuccess
  Command: @asuccess <object> = <command-list>
  Attribute: Asucc
 
  Sets the actions to be taken by an object when someone successfully picks
  it up (because they passed the lock), by an exit when someone passes
  through it, or when someone looks at a room and passes the room's lock.
 
  Example: @asucc kitten = :climbs up your sleeve and nuzzles your face.
  See also: @osucc, @success, SUCCESS.

& @atfail
  Command: @atfail <object> = <command-list>
  Attribute: Atfail
 
  Sets the action to be taken by an object when someone tries to teleport
  there but fails.
 
  Example: @atfail here = @page [owner(me)]=%N tried to teleport here.
  See also: @teleport, @tfail, @otfail, @lock.

& @atofail
  Command: @atofail <object> = <command-list>
  Attribute: Atofail
 
  Sets the action to be taken by an object when someone tries to teleport
  out but fails.
 
  Example: @atofail here = @page [owner(me)]=%N tried to teleport out.
 
  See also: @teleport, @tofail, @otofail, @lock.
 
& @atport
  Command: @atport <object> = <command-list>
  Attribute: Atport
 
  Sets the actions to be performed by object whenever it teleports.
  The actions are performed after the object moves to its new location.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
  
  Example: @atport me = &TEL.COUNT me=add(v(TEL.COUNT),1)
 
  See also: @otport, @oxtport, @tport, @teleport.

& @aufail
  Command: @aufail <object> = <command-list>
  Attribute: Aufail
 
  Sets the list of commands to be run when someone 'use's the object but
  fails the object's use lock.  Note that the other functions controlled
  by the use lock (paying, listening, and $-commands) do not trigger
  Aufail.
 
  Example: @aufail robot = "I _told_ you to leave me alone; kill %n=100
 
  See also: @oufail, @ufail, @use.

& @ause
  Command: @ause <object> = <command-list>
  Attribute: Ause
 
  Sets the actions to be taken when someone uses the object with the use
  command.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @ause grenade = :EXPLODES with a thundering roar; kill %n=100;
                           @destroy me
  See also: use, @ouse, @use.

& @away
  Command: @away <object> = <message>
  Attribute: Away
 
  This attribute is sent as a message to anyone who tries to page you when 
  you are not connected.
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  Example: @away me = Hey, I'm not even connected.  So why are you paging me?
  See also: @idle, @reject, page.

& @charges
  Command: @charges <object> = <count>
  Attribute: Charges
 
  This attribute allows you to limit the number of times an object can be
  used.  If there is a charges attribute it is decremented each time an
  action on the object is triggered.  Once it reaches zero, normal triggering
  stops and the Runout attribute (if one is present) is run instead.
 
  Example: @charges Fireball wand = 5
  See also: @runout.

& @cost
  Command: @cost <object> = <amount>
  Attribute: Cost
 
  Sets the number of coins that need to be given to an object to trigger the
  Pay, Opay, and Apay attributes.  If the object is given more than this
  amount, the excess is returned to the giver, while if less than this amount
  is given the entire amount is returned, a snide message is sent to the
  giver, and the Apay, Opay, and Pay attributes are not used.
 
  This attribute is only meaningful for things, and will never be
  automatically triggered on other object types.
 
  Example: @cost Coke machine = 25
  See also: give, @apay, @opay, @pay.

& @daily
  Command: @daily <object> = <command list>
  Attribute: Daily
 
  This attribute is automatically triggered once per day, at whatever
  hour is set by the config parameter events_daily_hour. 
  Doing a '@daily <object> = <commands>' is functionally equivalent
  to doing '&SOME_ATTR <object> = <commands>', and then a
  '@cron <object>/SOME_ATTR = 0 7 * * *' (substitute whatever
  events_daily_hour is for '7').
 
  @daily attributes are handled entirely through the cron facility;
  they appear in the @crontab schedule, and can be unscheduled by
  using @crondel. However, cron entries are automatically entered
  for objects with an @daily, at startup time.
 
  Changing events_daily_hour while the MUSH is running does NOT
  re-schedule already-scheduled @daily triggers; it only affects
  future sets of @daily. Thus, it is possible for an object to
  end up with two such entries, if a @daily is set on it, the
  events_daily_hour is changed, and the @daily is re-set.
 
  See also: @cron, @crondel, @crontab
 
& @describe
  Command: @describe <object> = <description>
  Attribute: Desc
 
  Sets the description for <object>, which others see when they look at the
  object.  Giving all your objects, rooms, and exits good descriptions is
  considered to be good building practice.
 
  Function references and %-substitutions are allowed in descriptions, and
  are evaluated when someone looks at the object.  In function references,
  'me' refers to the object being looked at, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the looker.
 
  Examples:
    <object> @desc vase = You see a delicate Ming vase.
    <exit>   @desc elevator = There is an elevator to the east.
  See also: look, @adescribe, @odescribe.

& @dfail
  Command: @dfail <object> = <message>
  Attribute: Dfail
 
  Sets the message that a player sees when he tries to drop the object but
  fails because he didn't pass the object's drop lock.
 
  Function references and %-substitutions are allowed in drop failure
  messages, and are evaluated when someone drops the object.  In function
  references, 'me' refers to the object being dropped, while %-substitutions
  that refer to the enactor (such as %n, %#, %p, etc) refer to the dropper.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @dfail sword = The sword has welded itself to your hand.
  See also: drop, @adfail, @odfail, @lock.

& @drop
  Command: @drop <object> = <message>
  Attribute: Drop
 
  Sets the message that a player sees when he drops the object, or after he
  goes through the exit.
 
  Function references and %-substitutions are allowed in drop messages, and
  are evaluated when someone drops the object.  In function references,
  'me' refers to the object being dropped, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the dropper.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Examples: <object> @drop vase = You gently put down the delicate vase.
            <exit>   @drop elevator = The elevator doors close behind you.
  See also: drop, @adrop, @odrop, DROP-TO, EXITS.

& @ealias
  Command: @ealias <object> = <entrance-list>
  Attribute: Ealias
 
  Sets up a set of alternate commands that may be used as synonynms for the
  command 'enter <object>' when you are in the same location as the object.
  The alternate commands are separated by semicolons just like in exit names.
 
  Entry aliases are checked for after exitnames, builtin MUSH commands, and
  leave aliases for the current location, but before $-commands.  If more than
  one object has an entry alias that matches a player's command, the one on
  the object that occurs first in the location contents list is used.
 
  This attribute is meaningful for players and things, and will never be
  automatically looked at on rooms or exits.
 
  Example: @ealias car = get in car; car; climb in; go for a ride
  See also: @lalias, enter, leave.

& @efail
  Command: @efail <object> = <command-list>
  Attribute: Efail
 
  Sets the message that a player sees when he tries to enter the object but
  fails because the object is not ENTER_OK or the player fails the
  object's enter lock.
 
  Function references and %-substitutions are allowed in efail messages, and
  are evaluated when someone fails to enter the object.  In function
  references, 'me' refers to the object that the enactor tried to enter, while
  %-substitutions that refer to the enactor (such as %n, %#, %p, etc) refer to
  the the player who tried (and failed) to enter.
 
  The enter lock only affects the 'enter' command and its aliases (set via
  the @ealias command), it does not affect exits that lead to the object or
  teleporting in.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @efail car = The car's door is locked.
  See also: @aefail, @aenter, @ealias, @enter, @oefail, @oenter, enter,
            ENTER_OK.

& @enter
  Command: @enter <object> = <message>
  Attribute: Enter
 
  Sets the message that a player sees when entering an object or room,
  whether by using an exit, the enter or leave commands, or by teleporting.
 
  Function references and %-substitutions are allowed in enter messages, and
  are evaluated when someone enters the object.  In function references,
  'me' refers to the object being entered, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the player entering the
  object.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @enter car = You climb into the car and buckle your seatbelt.
  See also: enter, @aenter, @oenter, ENTER_OK.

& @fail
  Command: @fail <object> = <message>
  Attribute: Fail
 
  Sets the failure message for <object>.  This message is seen by the actor
  when one of these events occurs:
 
    - For exits: Someone tries to traverse the exit but cannot because they
      fail the exit's default lock or the exit is not linked.
    - For players and things: Someone tries to pick up the object but cannot
      because they fail the object's default lock.
    - For rooms, players, and things: Someone looks around inside the room,
      player, or thing and fails the object's default lock.
 
  Substitution and evaluation is performed on the message before it is shown.
 
  Example:
    > @fail table = It's too heavy to lift!                            <thing>
    > @fail doorway = The doorknob does not turn.                       <exit>
  See also: get, @afail, @ofail, FAILURE.

& @filter
  Command: @filter <object> = <pattern>[, <pattern>...]
  Attribute: Filter
 
  This attribute specifies a series of patterns to be used to suppress
  text normally forwarded by the AUDIBLE flag.  If the desired pattern
  contains a comma, the pattern may be enclosed in curly braces {}.
 
  Example:
    > @fo test=out
    > @set #378=puppet
    test> test grows ears and can now hear.
    > @filter out = {* has arrived.},{* has left.}
    Set.
    > :has not arrived.
    Wizard has not arrived.
    test> From a distance, Wizard has not arrived.
    > :has arrived.
    Wizard has arrived.
  See also:  AUDIBLE, @forwardlist, @infilter, @inprefix, @prefix.

& @forwardlist
  Command: @forwardlist <object> = <dbref-list>
  Attribute: Forwardlist
 
  Specifies a list of locations (specified by their db numbers) that are to
  receive messages heard by <object> (filtered by the @filter attribute and
  prefixed by the @prefix attribute).  The messages are only forwarded if
  <object> has its AUDIBLE flag set.
  See also: @filter, @prefix, AUDIBLE.

& @gfail
  Command: @gfail <object> = <message>
  Attribute: Gfail
 
  Sets the message that a player sees when he tries to give away the object
  but fails because he didn't pass the object's give lock.
 
  Function references and %-substitutions are allowed in give failure
  messages, and are evaluated when someone tries to give away the object.
  In function references, 'me' refers to the object being given away, while
  %-substitutions that refer to the enactor (such as %n, %#, %p, etc) refer
  to the (attempted) giver.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @gfail sword = You can't give away a cursed sword!
  See also: give, @agfail, @ogfail, @lock.

& @htdesc
  Command: @htdesc <object> = <message>
  Attribute: HTDesc

  Sets the HTML description for <object>.  The HTML description of an object
  will be shown to a player with the HTML flag.  If not set, the regular
  description in the Desc attribute is shown instead.
 
  If you wish to place raw HTML in this attribute, you should set the html
  attribute flag on it so that the contents will not be doubly htmlified.
  Without the flag, any '<' characters would be translated to "&lt;", which
  means the browser would display a '<' character rather than beginning to
  process a markup tag.

  Function references and %-substitutions are evaluated in this attribute.
 
  Example: @htdesc me = <IMG SRC="http://www.me.com/mypic.jpg">
           @set me/htdesc = html
 
  See also: Pueblo, @set.

& @idesc
  Command: @idesc <object> = <message>
  Attribute: Idesc
 
  Sets the internal description for <object>.  The internal description of an
  object will be shown to any player entering it.  If not set, the regular
  description in the Desc attribute is shown instead.
 
  Function references and %-substitutions are allowed in inside descriptions,
  and are evaluated when someone fails to get or look at the object.  In
  function references, 'me' refers to the object being looked at, while
  %-substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the player doing the looking.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @idesc car = You are sitting in the driver's seat of a Volkswagen
                        Beetle.
  See also: enter, @describe, ENTER_OK.

& @idle
  Command: @idle <object> = <message>
  Attribute: Idle
 
  This attribute is sent as a message to anyone who successfully pages you.
  It can be used to tell someone who pages you when you will return
  (if you are going to be away for a while).
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  Example: @idle me = At dinner.  Back about 7PM.
  See also: @away, @reject, page.

& @infilter
  Command: @infilter <object> = <pattern>[, <pattern>...]
  Attribute: Infilter
 
  This attribute specifies a series of patterns to be used to suppress
  text normally sent to the contents of <object> by @listen.  If the desired
  pattern contains a comma, the pattern may be enclosed in curly braces {}.
 
  Example:
    > @listen sports car=*
    > @fo test=enter sports car
    test has left.
    test> Sports Car(#383Q)
    > :waves.
    test> Wizard waves.
    Wizard waves.
    > @infilter sports = *waves*
    > :waves.
    Wizard waves.
    > :knocks on the window.
    test> Wizard knocks on the window.
    Wizard knocks on the window.
  See also:  @filter, @inprefix, @listen, @prefix.

& @inprefix
  Command: @inprefix <object> = <prefix text>
  Attribute: Inprefix
 
  This attribute, when set, will prefix all text that is sent to the contents
  of <object> by @listen.  The default is to have no prefix, the text is
  forwarded unadorned.
 
  Example:
    > @listen sports car=*
    > @fo test=enter sports car
    test has left.
    test> Sports Car(#383Q)
    > :waves.
    test> Wizard waves.
    Wizard waves.
    > @inprefix sports car = In the mundane world outside,
    test> In the mundane world outside, Wizard waves some more.
    Wizard waves some more.
  See also: @filter, @infilter, @listen, @prefix.

& @kill
  Command: @kill <object> = <message>
  Attribute: Kill
 
  This command sets the message that is shown to anyone who kills <object>.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Function references and %-substitutions are allowed in kill messages, and
  are evaluated when someone kills the object.  In function references, 'me'
  refers to the object that was killed, while %-substitutions that refer to
  the enactor (such as %n, %#, %p, etc) refer to the player doing the killing.
 
  Example: @kill guard = The guard says "I'll get.. you... for... this... %n"
                         as he falls down and dies.
  See also: kill, @akill, @okill, BEING KILLED, IMMORTAL, WIZARD.

& @Lalias
  Command: @lalias <object> = <entrance-list>
  Attribute: Lalias
 
  Sets up a set of alternate commands that may be used as synonynms for the
  command 'leave' when you are inside a player or a thing.  The alternate
  commands are separated by semicolons just like in exit names.
 
  Leave aliases are checked for after exitnames and builtin MUSH commands, but
  before enter aliases and $-commands.
 
  This attribute is meaningful for players and things, and will never be
  automatically looked at on rooms or exits.
 
  Example: @lalias car = get out;climb out;out;open door;outside
  See also: @ealias, enter, leave.

& @leave
  Command: @leave <object> = <message>
  Attribute: Leave
 
  Sets the message that a player sees when leaving an object or room, whether
  by using an exit, the enter or leave commands, or by teleporting.
 
  Function references and %-substitutions are allowed in leave messages, and
  are evaluated when someone leaves the object.  In function references,
  'me' refers to the object being left, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the player leaving the
  object.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @leave car = You unbuckle your seatbelt and climb out of the car.
  See also: leave, @aleave, @oleave.

& @lfail
  Command: @lfail <object> = <command-list>
  Attribute: Lfail
 
  Sets the message that a player sees when he tries to leave it but fails
  because the player fails the object's leave lock.
 
  The leave lock only affects the 'leave' command and its aliases (set via
  the @ealias command), it does not affect going home, using an exit in the
  location, or teleporting out.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @lfail plane = You don't have a parachute!
  See also: @aleave, @alfail, @lalias, @leave, @oleave, @olfail, leave.

& @listen
  Command: @listen <object> = <string>
  Attribute: Listen
 
  This attribute contains a wildcard pattern that the object listens for.
  Anything spoken, posed, emitted, or whispered in the room that <object> is
  in, as well as messages resulting from using objects (such as Opay and Succ
  messages) are checked against the Listen attribute.  When the object hears 
  something that matches the pattern, it triggers the Ahear attribute, as
  well as either the Amhear or Aahear attributes, as appropriate,
  substituting %0 the string that matched the first wildcard character in the
  Listen, %1 for the second. etc.  If the pattern in the Listen attribute is
  matched, objects in <object>'s inventory will also hear the message and
  have a chance to match it.  Objects whose Listen attribute is set to
  anything will be listed when a @sweep command is run by someone in the
  same room.
 
  If the @listen pattern is matched, then the object's contents will
  hear the message also, prefixed by the text in @inprefix if it is set.  Any
  text that matches any pattern specified in @infilter will not be sent to
  the contents.
 
  Example: @listen camera = * has arrived.
           @ahear camera = @va me = %va %0
  See also: @aahear, @ahear, @amhear, @sweep, @inprefix, @infilter.

& @move
  Command: @move <object> = <command-list>
  Attribute: Move
 
  Sets the message that an object sees after it moves from one location to
  another, whether by using an exit, entering or leaving an object,
  teleporting, or going home.
 
  This attribute is meaningful for players, and things and will never be
  automatically triggered on other object types.
 
  Example: @move bopper = OK.  You're there now.
  See also: @amove, @omove.

& @odescribe
  Command: @odescribe <object> = <message>
  Attribute: Odesc
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone looks at <object>.
 
  Example: @odesc vase = carefully inspects the vase.
  See also: look, @adescribe, @describe, @idesc.

& @odfail
  Command: @odfail <object> = <message>
  Attribute: Odfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to drop <object> but fails because they
  didn't pass the object's drop lock.
 
  Function references and %-substitutions are allowed in drop failure
  messages, and are evaluated when someone drops the object.  In function
  references, 'me' refers to the object being dropped, while %-substitutions
  that refer to the enactor (such as %n, %#, %p, etc) refer to the dropper.
 
  Example: @odfail sword = tries to put down the sword but it leaps back
                                       into %p hand.
  See also: drop, @adfail, @dfail, @lock.

& @odrop
  Command: @odrop <object> = <message>
  Attribute: Odrop
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone drops <object>, or to others in the room that the
  player arrives in after taking an exit.
 
  Example: <object> @odrop stone = puts down the stone and then
                                       wipes sweat from %p brow.
           <exit>   @odrop elevator = enters the elevator from the lobby.
  See also: drop, @adrop, @drop, DROP-TO, EXITS.

& @oefail
  Command: @oefail <object> = <command-list>
  Attribute: Oefail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room as the player when he tries to enter the object but fails
  because the object is not ENTER_OK or the player fails the
  object's enter lock.
 
  The enter lock only affects the 'enter' command and its aliases (set via
  the @ealias command), it does not affect exits that lead to the object or
  teleporting in.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @oefail car = tries to open the car's door, but it is locked.
  See also: @aefail, @aenter, @ealias, @efail, @enter, @oenter, enter,
            ENTER_OK.

& @oenter
  Command: @oenter <object> = <message>
  Attribute: Oenter
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the location being entered when someone enters <object>.  Note that the
  message is shown to those inside the object, not those outside.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @oxenter wormhole = enters the wormhole from normal space.
  See also: enter, @aenter, @enter, @oxenter.

& @ofail
  Command: @ofail <object> = <message>
  Attribute: Ofail
 
  Sets the others failure message for <object>.  This message is seen others
  in the same location as the actor when one of these events occurs:
 
    - For exits: Someone tries to traverse the exit but cannot because they
      fail the exit's default lock or the exit is not linked.
    - For players and things: Someone tries to pick up the object but cannot
      because they fail the object's default lock.
    - For rooms, players, and things: Someone looks around inside the room,
      player, or thing and fails the object's default lock.
 
  Substitution and evaluation is performed on the message before it is shown.
 
  Examples:
    > @ofail table = tries to pick up the table, but it is too heavy.  <thing>
    > @ofail doorway = tries the knob on the door, to no avail.         <exit>
  See also: get, look, @afail, @fail, FAILURE.

& @ogfail
  Command: @ogfail <object> = <message>
  Attribute: Ogfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to give away <object> but fails because
  they didn't pass the object's give lock.
 
  Function references and %-substitutions are allowed in give failure
  messages, and are evaluated when someone tries to give away the object.
  In function references, 'me' refers to the object being given away, while
  %-substitutions that refer to the enactor (such as %n, %#, %p, etc) refer
  to the (attempted) giver.
 
  Example: @ogfail blob = tries to give away a sticky blob of goo.
  See also: give, @agfail, @gfail, @lock.

& @okill
  Command: @okill <object> = <message>
  Attribute: Okill
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone kills <object>.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @okill guard = bashes in the guard's skull, killing him.
  See also: kill, @akill, @kill, BEING KILLED, IMMORTAL, WIZARD.

& @oleave
  Command: @oleave <object> = <message>
  Attribute: Oleave
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the location being left when someone leaves <object>.  Note that the
  message is shown to those inside the object, not those outside.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @oleave wormhole = departs the wormhole to return to normal space.
 
  See also: leave, @aleave, @leave, @oxleave.

& @olfail
  Command: @olfail <object> = <command-list>
  Attribute: Olfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room as the player when he tries to leave it but fails because the
  player fails the object's leave lock.
 
  The leave lock only affects the 'leave' command and its aliases (set via
  the @ealias command), it does not affect going home, using an exit in the
  location, or teleporting out.
 
  This attribute is meaningful for players and things, and will never be
  automatically triggered on rooms or exits.
 
  Example: @olfail plane = thinks about jumping out of the plane without a
                           parachute, but wisely reconsiders.
  See also: @aleave, @alfail, @lalias, @leave, @lfail, @oleave, leave.

& @omove
  Command: @omove <object> = <message>
  Attribute: Omove
 
  Sets the message that others in the same location see after the object has
  moved to that location from somewhere else, whether by using an exit,
  entering or leaving an object, teleporting, or going home.
 
  This attribute is meaningful for players, and things and will never be
  automatically triggered on other object types.
 
  Example: @omove car = coasts to a stop.
  See also: @amove, @move.

& @opay
  @opay <object> = <message>
  Attribute: Opay
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone pays <object> enough to satisfy its Cost attribute.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @opay Coke machine = slips some change into the coin slot on the
                                Coke machine.  You hear some rumbling from
                                inside the machine and a can of Coke appears
                                in the tray at the bottom of the machine.
  See also: give, @cost, @apay, @pay.

& @orfail
  Command: @orfail <object> = <message>
  Attribute: Orfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to give <object> a thing that does not
  pass <object>'s receive lock.
 
  Function references and %-substitutions are allowed in receive failure
  messages, and are evaluated when someone tries to give away the object.
  In function references, 'me' refers to the intended recipient of the object,
  while %-substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the (attempted) giver.
 
  Example: @orfail merchant = tries to unload some worthless trash on Astinous.
  See also: give, @agfail, @arfail, @gfail, @ogfail, @rfail, @lock.

& @osuccess
  Command: @osuccess <object> = <message>]
  Attribute: Osucc
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone picks up the named player or thing, goes through the
  named exit, or looks at the room and passes the room's lock.
 
  Setting Osuccess messages on all takeable objects and usable exits is
  considered good building practice.
 
  Examples: <object> @osucc vase = carefully picks up the vase.
            <exit>   @osucc doorway = opens the door and leaves the room.
                                      The door closes behind %o with a click.
  See also: get, look, @asuccess, @success, SUCCESS.

& @otfail
  Command: @otfail <object> = <message>
  Attribute: Otfail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to teleport to somewhere he does not have
  permission.  You do not see this message if they couldn't teleport out of
  their present location.
 
  Function references and %-substitutions are allowed in teleport failure
  messages, and are evaluated when someone attempts to teleport to the
  specified destination.  In function references, 'me' refers to the teleport
  destination, while %-substitutions that refer to the enactor (such as %n,
  %#, %p, etc) refer to the player attempting the teleport.
 
  When a player teleports another object (@tel <object>=<destination>), the
  lock is checked against the object, not the player.
 
  Example: @otfail here = thinks about teleporting to the Magic Room, but
                          decides against it at the last moment.
  See also: @teleport, @atfail, @tfail, @lock.

& @otofail
  Command: @otofail <object> = <message>
  Attribute: Otofail
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the same room when someone tries to teleport out of somewhere they do not
  have permission.
 
  Function references and %-substitutions are allowed in teleport failure
  messages, and are evaluated when someone attempts to teleport from their
  location.  In function references, 'me' refers to the player's location,
  while %-substitutions that refer to the enactor (such as %n,
  %#, %p, etc) refer to the player attempting the teleport.
 
  Example: @otofail here = thinks about teleporting from the Magic Room, but
                          decides against it at the last moment.
 
  See also: @teleport, @atofail, @tofail, @lock.

& @otport
  Command: @otport <object> = <message>
  Attribute: Otport
 
  Sets the message (prefixed by your name) that others in the room to which
  the object goes see when the object teleports there.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
  
  Example: @otport me = appears in a flash of non-wizardly brilliance.
 
  See also: @atport, @oxtport, @tport, @teleport.

& @oufail
  Command: @oufail <object> = <message>
  Attribute: Oufail
 
  Sets the message that others in the same room see when someone tries to
  use object but fails the object's use lock.  Note that the other functions
  controlled by the use lock (paying, listening, and $-commands) do not
  trigger Oufail.
 
  Example: @oufail robot = tries to activate the robot, but to no avail.
 
  See also: @aufail, @ufail, @use.

& @ouse
  Command: @ouse <object> = <message>
  Attribute: Ouse
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the room when someone uses <object>.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @ouse camera = takes a picture with the camera.
  See also: use, @ause, @use.

& @oxenter
  Command: @oxenter <object> = <message>
  Attribute: Oxenter
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the location being left when someone enters <object>.  Note that the
  message is shown to those outside the object, not those inside.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @oxenter wormhole = climbs into the wormhole and vanishes.
  See also: enter, @aenter, @enter, @oenter.

& @oxleave
  Command: @oxleave <object> = <message>
  Attribute: Oxleave
 
  Sets the message (prefixed by the player's name) that is shown to others in
  the location being entered when someone leaves <object>.  Note that the
  message is shown to those outside the object, not those inside.
 
  This attribute is meaningful for players, things, and rooms, and will never
  be automatically triggered on exits.
 
  Example: @oxleave wormhole = steps out of a hyperspatial wormhole.
 
  See also: leave, @aleave, @leave, @oleave.

& @oxtport
  Command: @oxtport <object> = <message>
  Attribute: Oxtport
 
  Sets the message (prefixed by your name) that others in the room from which
  the object comes see when the object teleports out.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
  
  Example: @oxtport me = disappears in a flash of non-wizardly brilliance.
 
  See also: @atport, @otport, @tport, @teleport.

& @pay
  Command: @pay <object> = <message>
  Attribute: Pay
 
  Sets the message that is shown to the player who gives <object> enough
  money to satisfy its Cost attribute.
 
  This attribute is only meaningful for things, and will never be
  automatically triggered on other object types.
 
  Example: @pay Coke machine = You slip some change into the slot.
  See also: give, @apay, @cost, @opay.

& @prefix
  Command: @prefix <object> = <prefix text>
  Attribute: Prefix
 
  This attribute, when set, will be used as a prefix for all text forwarded
  by the 'audible' flag on an object or exit.  The default if this attribute
  is not set is 'From <object name>,' for objects, and 'From a distance,'
  for exits.
 
  Example:
    > @fo test=out
    > @set #378=puppet
    test> test grows ears and can now hear.
    > :does something silly.
    Wizard does something silly.
    test> From a distance, Wizard does something silly.
    > @prefix out=From some strange place
    Set.
    > :does something even sillier.
    Wizard does something even sillier.
    test> From some strange place Wizard does something even sillier.
  See also: AUDIBLE, @filter, @forwardlist, @infilter, @inprefix.

& @reject
  Command: @reject <object> = <message>
  Attribute: Reject
 
  This attribute is sent as a message to anyone who tries to page you but
  you have prevented them from paging you via your page lock (@lock/page).
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  Example: @reject me = I _told_ you not to page me anymore...
  See also: @away, @idle, page.

& @rfail
  Command: @rfail <object> = <message>
  Attribute: Rfail
 
  Sets the message that a player sees when he tries to give an object to
  someone else, but the receiver refuses to accept the object because
  the object didn't pass its receive lock.
 
  Function references and %-substitutions are allowed in receive failure
  messages, and are evaluated when someone tries to give away the object.
  In function references, 'me' refers to the intended recipient of the object,
  while %-substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the (attempted) giver.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
 
  Example: @gfail merchant = The merchant doesn't want your worthless trash.
  See also: give, @agfail, @arfail, @gfail, @ogfail, @orfail, @lock.

& @runout 
  Command: @runout <object> = <command list>
  Attribute: Runout
 
  Sets the actions to be taken by <object> when another of its attributes is
  triggered (either automatically or via the @trigger command) and its
  Charges attribute is zero.  When this occurs, the Runout attribute is run
  INSTEAD OF the attribute that would have run normally.
 
  Example: @runout magic wand = :fizzles and turns to dust.; @destroy me
  See also: @charges.

& @sex
  Command: @sex <object> = <gender>
  Attribute: Sex
 
  Sets the gender for <object>, which is used to determine which pronouns to
  use when replacing %p, %o, %s, and %a parameters in messages that apply to
  <object>.  Genders that start with M or m are considered male, those
  starting with F, f, W, or w are considered female, those starting with
  P or p are considered plural, and anything else is considered neuter.
 
  Example: @sex me = female
           @sex me = No thank you (Silly, but possible.  Treated as neuter)
  See also: GENDER.

& @startup
  Command: @startup <object> = <command list>
  Attribute: Startup
 
  Sets a list of commands to be performed by <object> when the game is
  started up.  Typical actions include going home, cleaning visitors out of
  a room, resetting a puzzle or complex object to its initial state, or
  starting up an object that wants to run continuously.
 
  Example: @startup me = @vz me=MUSH was last restarted at [time()].
           @startup me = home

& @success
  Command: @success <object> = <message>
  Attribute: Succ
 
  Sets the message that is shown to the player who successfully picks up the
  named player or thing, goes through the named exit, or looks at the room
  and passes the room's lock.
 
  Example: <object> @succ vase = You carefully pick up the delicate vase.
           <exit>   @succ doorway = You open the door and walk through the
                                    doorway.
  See also: get, look, @asuccess, @osuccess, SUCCESS.

& @tfail
  Command: @tfail <object> = <message>
  Attribute: Tfail
 
  Sets the message that a player sees when he tries to teleport to somewhere
  he does not have permission.  You do not see this message if you couldn't
  teleport out of your present location.
 
  Function references and %-substitutions are allowed in teleport failure
  messages, and are evaluated when someone attempts to teleport to the
  specified destination.  In function references, 'me' refers to the teleport
  destination, while %-substitutions that refer to the enactor (such as %n,
  %#, %p, etc) refer to the player attempting the teleport.
 
  When a player teleports another object (@tel <object>=<destination>), the
  lock is checked against the object, not the player.
 
  Example: @tfail here = A psychic barrier prevents you from teleporting there.
  See also: @teleport, @atfail, @otfail, @lock.

& @tofail
  Command: @tofail <object> = <message>
  Attribute: Tofail
 
  Sets the message that a player sees when he tries to teleport from somewhere
  he does not have permission.
 
  Function references and %-substitutions are allowed in teleport failure
  messages, and are evaluated when someone attempts to teleport out of their
  location.  In function references, 'me' refers to the player's current
  location, while %-substitutions that refer to the enactor (such as %n,
  %#, %p, etc) refer to the player attempting the teleport.
 
  Example: @tofail here = A psychic barrier prevents you from teleporting
           out.
 
  See also: @teleport, @atofail, @otofail, @lock.
 
& @tport
  Command: @tport <object> = <message>
  Attribute: Tport
 
  Sets the message that an object sees whenever it teleports.
  The message is displayed after the object moves to its new location.
 
  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.
  
  Example: @tport me = Hey! I teleported. Wow!
 
  See also: @atport, @otport, @oxtport, @teleport.

& @ufail
  Command: @ufail <object> = <message>
  Attribute: Ufail
 
  Sets the message that someone sees when they try to use object but fail
  the object's use lock.  Note that the other functions controlled by the use
  lock (paying, listening, and $-commands) do not trigger Oufail.
 
  Example: @ufail robot = The robot pointedly ignores you.
 
  See also: @aufail, @oufail, @use.

& @use
  Command: @use <object> = <message>
  Attribute: Use
 
  Sets the message that is shown to the player who uses <object>.
 
  This attribute is only meaningful for players and things, and will never
  be automatically triggered on other object types.
 
  Example: @use camera = You take a picture with the camera.  Click.
  See also: use, @ause, @ouse.

& @vrml_url
  Command: @vrml_url <location> = <url>
  Attribute: VRML_URL
 
  Sets the URL of a VRML page to be shown to Pueblo users when they connect
  in <location>.
 
  See also: Pueblo, @htdesc.

& @conformat
  Command: @conformat <object> = <contents format>
  Attribute: ConFormat
 
  Replaces the usual "Contents:" or "Carrying:" format when an object
  is looked at, by a player-specified contents format. This is evaluated
  as if it were a description or other similar message on the room, and
  is passed no special parameters. The list of room contents can be
  obtained through 'lcon(me)', though note that this does no checking
  for what the viewing player should and shouldn't see.
 
  One could change the format to 'Contents: Object1 Object2 Object3'
  through '@conformat here = Contents: [iter(lcon(me),name(##))]',
  for example. More complex things are, obviously, possible.
 
  See also: @exitformat

& @exitformat
  Command: @exitformat <object> = <list of exits format>
  Attribute: ExitFormat
 
  Replaces the usual "Obvious Exits:" format when an object is looked
  at, by a player-specified exits format. This is evaluated as if it
  were a description or similar message on the room, and is passed no
  special parameters. The list of exits can be obtained through 
  'lexits(me)', though note that this does no checking for what the
  viewing player should and shouldn't see.
 
  One could change the format to 'Exits: Exit1 Exit2 Exit3' through
  '@exitformat here = Exits: [iter(lexits(me),name(##))]', for example.
 
  Or, to imitate a PennMUSH-style room-TRANSPARENT "long exits" format:
  'Obvious Exits:[iter(lexits(me),%r [name(##)] leads to [name(loc(##))].'
 
  See also: @conformat

& @exitto
  Command: @exitto <object> = <function text>
  Attribute: ExitTo
  
  When an exit is variably linked, when a player attempts to move through
  the exit, the @exitto attribute is evaluated. If the evaluation (with
  the player considered as the enactor) results in a valid dbref for the
  destination, the player is moved to that destination, just as if the
  exit had been normally linked to that destination. Otherwise, the exit
  is treated as unlinked.
 
  For example, '@exitto random = [switch(rand(3),0,#0,1,#10,2,#50)]' would,
  when a player attempted to go through it, randomly send the player to
  either room #0, room #10, or room #50.
 
  See also: @link
 
& MARKER
  Flag: Marker0 (0), Marker1 (1) ... through Marker9 (9)
 
  The ten "marker" flags are "user-defined" flags. Through the flag_name
  and flag_access configuration parameters, the names of these flags, and
  the permissions it takes to set/unset them, can be changed. Thus, the
  exact names of the flags will vary on a per-MUSH basis, though Marker0
  through Marker9 will always remain aliases for them, and their
  one-character symbols are always 0 through 9. All user-defined flag
  names are prefixed with an underscore (_), clearly differentiating
  them from normal built-in flags.
  
& ABODE
  Flag: ABODE (A)
 
  If a room is set ABODE, players can set their homes there, 
  and can set the homes of objects there.  It does not mean that a 
  player can open an exit to that room, only that they can set their 
  home there.
& AUDIBLE
  Flag: AUDIBLE (a)
  
  When set on an object, player, or room everything from a say, pose, or emit
  inside the object will be sent to every object in the location of that
  object (except for rooms which have no location) as well as to all objects
  mentioned in the object's Forwardlist attribute.  When set on an exit,
  everything from a say, pose, or emit in the room the exit is in will be
  forwarded to the room the exit points to.  In both cases the @prefix
  attribute will be inserted in front of the text, or a default prefix if no
  @prefix attribute is set.  If the @filter attribute is present, it will be
  used to suppress those messages matching any of the patterns specified.
  See also: @filter, @forwardlist, @prefix.

& BLIND
  Flag: BLIND (B)
 
  When set on an object, when the object is moved, '<object> has arrived.'
  and '<object> has left.' messages are not displayed to the locations that
  the object is leaving and entering.
 
  When set on a location, 'has arrived.' and 'has left.' messages are not
  displayed when objects enter or leave the location.
 
  The flag does NOT suppress @osucc, @odrop, etc. messages (unlike the DARK
  flag).
  
  This flag can only be set by Wizards.
 
& BOUNCE
  Flag: BOUNCE (b)
 
  When set on an object, this flag "bounces" anything that the object
  hears to its contents (i.e., the contents hear the message also).
  This is basically equivalent to giving the object a @listen of '*'
  without an @ahear. It is, however, considerably more efficient than
  doing so, and, moreover, can be set on player objects without
  requiring the player_listen config directive to be enabled.

& CHOWN_OK
  Flag: CHOWN_OK (C)
 
  This flag, when set, allows you to transfer ownership to
  another player. To set it, you must be carrying the object. You 
  also have to be in the room if you want to set this flag on rooms 
  or exits.  After this flag is set, the new player may gain 
  ownership of the object by using the @chown command (See @chown).
 
  Note that setting an object CHOWN_OK lets anyone on the game @chown it.
  To restrict this (for example, if you intend a particular player to own
  the object, but they aren't logged in right now), @lock the object's
  ChownLock to the appropriate player.
 
& CONNECTED
  Flag: CONNECTED (c)
 
  This flag applies only to players and it shows if the 
  player is connected or not. Thus, each time you are connected to 
  the game, you should see the 'c' flag set, otherwise, you are DEAD!
  You cannot reset this flag, and it is used internally by the code 
  for things like tabulating players for the WHO list, etc.

& DARK
  Flag: DARK (D)
 
  If a room is DARK, then no items are shown when a person 
  'looks' there. If a thing is DARK, then "look" does not list that 
  object in the room's Contents:, and if an exit is DARK, it doesn't 
  show up in the Obvious Exits: list.  Puppets and objects that can 
  listen cannot be DARK.

& DESTROY_OK
  Flag: DESTROY_OK (d)
 
  When set on an object, it allows any player to destroy
  it as long as the object is not locked against them. This is good 
  for things like notes, whereby the recipient can destroy the note 
  after reading it, instead of having to look for you to destroy it.
  The DESTROY_OK flag overrides the SAFE flag, so that you do not need to
  give the /override switch to @destroy to destroy a thing that is both
  DESTROY_OK and SAFE.
 
  See also: @destroy, SAFE.

& ENTER_OK
  Flag: ENTER_OK (e)
 
  If an object or person is ENTER_OK, other players may enter the object
  or person by using 'enter <object/person>. Players must also have the
  ENTER_OK set if they wish to be able to receive things given to them by
  other players via the 'give <player> = <object>' command. Note that
  entering objects is also subject to Enter Locks.

& GOING
  Flag: GOING (G)
 
  Used internally for the @destroy command, it is set on objects
  that are set to be destroyed. In the event that a player decides
  they don't want to destroy the object after all, then they can
  simply set the object !GOING, and it will be spared destruction
  (assuming that the periodic destroyed-object-cleanups hasn't
  run yet, of course).
 
& HAVEN
  Flag: HAVEN (H)
 
  @set here=haven;@set me=haven. If a location is HAVEN, you 
  cannot kill in that location.  The HAVEN flag no longer blocks pages or
  @pemits, use @lock/page instead.
 
  See also: @lock/page.
& KEY
  Flag: KEY (K)
  
  When set on an object, it prevents non-player objects from passing
  locks on that object. Effectively, it prevents non-player objects
  from picking it up, linking to it, giving to it, etc.
 
& LINK_OK
  Flag: LINK_OK (L)
  
  If a room is LINK_OK, anyone who passes its LinkLock can link exits
  to it (but still not from it).
 
  You may also @forwardlist to, @drain, and @notify any LINK_OK objet
  whose LinkLock you past.
 
  See @link.

& UNFINDABLE
  Flag: UNFINDABLE (U)
 
  If a player is set UNFINDABLE, he cannot be found by the loc() or room()
  functions.  Bummer.
  If a room is set UNFINDABLE, players in that room (or inside objects
  in the room) cannot be found by loc()/room().

& FLOATING
  Flag: FLOATING (F)
 
  If a room is set floating, you will not be notified every 10 
  minutes or so that you have a disconnected room.
& OPAQUE
  Flag: OPAQUE (O)
 
  When set on a player, it prevents other players from 
  seeing what you are carrying in your inventory. Only exception is 
  when the object you are carrying belongs to the other player 
  looking at you.
& PLAYER
  Flag: PLAYER (P)
 
  The PLAYER flag identifies you as a player. This flag cannot be reset by
  any player, not even a Wizard. It is used mainly by the MUSH code to
  identify your  commands, check for validity of commands or locks etc.
  Generally, just pretend it isn't even there.

& JUMP_OK
  Flag: JUMP_OK (J)
 
  When a room or thing is set JUMP_OK, then that location can be teleported
  into by anyone.
 
  See @teleport.
& PUPPET
  Flag: PUPPET (p)
 
  @set <object> = puppet. Causes an object to grow eyes and 
  ears, and relay all it sees and hears to its owner.  
  See: @force, PUPPETS
& ROOM
  Flag: ROOM (R)
 
  This flag is automatically set on rooms when you @dig a new
  room. It cannot be changed. Rooms have the added advantage that 
  they can be saved from destruction by setting the room to !GOING 
  (see GOING).

& VISUAL 
  Flag: VISUAL (V)
 
  When set on your object, it allows other players to examine it and
  see all the object's attributes as if they owned the object. They
  cannot make any changes to the object.

& QUIET
  Flag: QUIET (Q)
 
  This flag when set on yourself prevents you from hearing 
  the 'set' or 'triggered' messages from any objects you own.  When 
  set on an object, only that object will not relay its messages.

& HALTED
  Flag: HALTED (h)
 
  While this flag is set, the object cannot perform any MUSH
  actions, listen, be triggered, etc.
& GAGGED
  Flag: GAGGED (j)

  When set on a player, it disables him from doing anything 
  except moving and looking.  He cannot talk, page, build, pose, get 
  or drop objects. (Yet another consequence of annoying the wizards.)
  Only wizards can set this flag.
& STICKY
  Flag: STICKY (S)

  If a thing is STICKY, it goes home when dropped (see HOMES). If a room
  is STICKY, its drop-to is delayed until the  last person leaves (see
  DROP-TOs). Only meaningful for things and rooms. 
& TEMPLE
  Flag: TEMPLE (T)
 
  The TEMPLE flag is no longer a part of TinyMUSH.
& BUILDER
  Flag: BUILDER (B)
 
  This is now the Builder power.
& WIZARD
  Flag: WIZARD (W)

  If a person is WIZARD, they are unkillable, subject to fewer restrictions,
  and able to use wizard commands; they "control" everything other than
  the God character. In general, WIZARDs can do anything using #<number>
  or *<player>. Only the God character can set and unset the WIZARD flag
  of other players. No WIZARD can turn their own WIZARD flag off.   

& ROYALTY
  Flag: ROYALTY (Z)
 
  If a person is ROYALTY, they can see and examine things, and
  teleport anywhere or anything, like a wizard can. They cannot modify
  objects or players they do not control, and cannot use wizard commands.
  This flag may only be set by a wizard.
 
& IMMORTAL
  Flag: IMMORTAL (i)
 
  Objects set immortal cannot be killed and don't use up money.
  Only settable by wizards.  This is useful when an object's location
  shouldn't be changed by Joe Player, but you don't want to have to relink it
  to its current location whenever it moves.

& FIXED
  Flag: FIXED (f)
 
  If this flag is set on an object, it can neither teleport nor go 'home'.
  If this flag is set on a player, neither the player nor objects owned
  by the player may teleport or go 'home'.
 
& UNINSPECTED
  Flag: UNINSPECTED (g)
 
  This is a 'marker' flag, typically set on rooms that need to be
  inspected for conformance to building standards. It may only be
  set by Wizards and Royalty.
 
& STAFF
  Flag: STAFF (w)
 
  This is a 'marker' flag, typically set on players who serve as Staff.
  This confers no special abilities; it is, however, only settable by
  Wizards.
 
& HEAD
  Flag: HEAD (?)
 
  This is a 'marker' flag, typically set on players who serve as 
  leadership of some sort. This confers no special abilities; it
  is, however, only settable by Wizards.
 
& COMPRESS
  Flag: Compress (.)
 
  This flag doesn't do anything.
 
& AUDITORIUM
  Flag: AUDITORIUM (n)
 
  If this flag is set, SpeechLocks are checked on that object.
 
& VACATION
  Flag: VACATION (|)
 
  This flag can only be set by Wizards. It automatically unset when
  a player logs on. Thus, it is useful for marking players who will
  be gone for a long time and should not be removed from the database.
 
& VERBOSE
  Flag: VERBOSE (v)
 
  This flag causes all commands executed by the object having
  the flag to be sent to the owner of the object.  i.e.:
 
  @create foo
  @set foo=VERBOSE
  @force foo="Hi.
  foo] "Hi.
  foo says "Hi."

  See also: TRACE
& INHERIT
  Flag: INHERIT (I)
 
  In TinyMUSH 1.0, Wizard-owned objects had wizard powers.  This was
  a problem in many cases, so that behavior changed.  Now, only Wizard
  objects or Wizard-owned Inherit-set objects have wizard powers.  Only
  players can set the Inherit flag, and the Inherit flag is reset during
  @chown.  If a player is set Inherit, all his stuff is assumed to be
  inherit, so his objects can control him.  If a player is NOT Inherit,
  his stuff does NOT control him.  (i.e. cannot @force him.)  This flag
  is not especially useful for non-wizards.
& MONITOR
  Flag: MONITOR (M)
 
  When set, anytime the object hears something from someone who passes the
  object's use lock, the object's attributes are scanned for attributes
  of the form '^<pattern>:<commandlist>'.  If the message matches the
  wildcarded <pattern>, then <commandlist> is executed, substituting %0 for
  the text that matched the first wildcard, %1 for the second, and so on.
  All matching attributes are executed, not just the first.
  Parents of MONITOR objects are never checked for ^-patterns.
 
  See also: LISTENING.
& TRACE
  Flag: TRACE(T)
 
  When a thing is set TRACE, it will report to its owner the result of all
  substitutions that it performs that change the original string.  The order
  for displaying nested evaluations (such as when evaluating the arguments to
  a function) is a site-selected configuration parameter.
 
  Example:
  > @set object = trace
  > @va object = say The result is [add(4,mul(3,%0))].
  > @trig object/va = 7
  object(#322)} '%0' -> '7'
  object(#322)} 'mul(3,%0)' -> '21'
  object(#322)} 'add(4,mul(3,%0))' -> '25'
  object(#322)} 'The result is [add(4,mul(3,%0))].' -> 'The result is 25.'
  object says "The result is 25."

{ 'help trace2' for more } 
& trace2
  When trace output is displayed in top-down order (final evaluation first,
  followed by the 'smaller' evaluations needed to perform it), then the total
  number of trace output lines that may be produced by an evaluation is limited
  to 200.  Bottom-up trace output is not limited.

  See also: VERBOSE.
& NOSPOOF
  Flag: NOSPOOF(N)
 
  This flag gives you mucho output when people @emit.  It can be annoying,
  but you'll know who's spoofing.
  See also: @emit, @femit, @oemit, @pemit.

& PARENT_OK
  Flag: PARENT_OK(Y)
 
  If an object is set PARENT_OK, then any other object that passes the object's
  ParentLock may make this object a parent of any object that it controls.
  Caution: allowing others to use your objects as parents lets them read the
  attributes on the object (as well as any parents of the object).

  See also: @lock/parent.
 
& CONSTANT
  Flag: CONSTANT(k)
 
  Only God can set attributes on an object set CONSTANT. This includes
  both setting attributes, changing attributes, and removing attributes.
  This affects commands like @cpattr as well as @set. In effect, this
  flag causes attributes on the object to be treated as if they were
  locked.
 
& TICKLER
  Flag: TICKLER(k)
 
  An object that is set TICKLER is able to use the Tcl interpreter
  functions. This flag can only be set by God.
 
  See also: TCL.
 
& LIGHT
  Flag: LIGHT(l)

  An object or exit that is set LIGHT is visible even when inside a DARK
  location.  If an object is set both DARK and LIGHT, then its contents are
  visible even though the object itself is not.

& MYOPIC
  Flag: MYOPIC(m)
 
  If you are set MYOPIC, then you are treated as if you did not own anything
  when you use the LOOK command or when you automatically look at a location
  when entering it.  Other commands (such as EXAMINE) are not affected.

& TERSE
  Flag: TERSE(q)
 
  If you are set TERSE then you are not shown the description, success/failure
  messages, contents, or exits of locations you enter.  You must use the LOOK
  or EXAMINE commands to see this information.
 
  Others in the location still get the osucc/ofail messages and the asucc or
  afail command list is still run.
 
  See also: examine, look.

& ROBOT
  Flag: ROBOT(r)
 
  If set on a player, indicates that the player is a robot and is allowed to
  use the OUTPUTPREFIX and OUTPUTSUFFIX commands that many publicly available
  robot programs require.  Some MUSHes do not restrict access to the
  OUTPUTPREFIX and OUTPUTSUFFIX commands.
 
  See also: OUTPUTPREFIX, OUTPUTSUFFIX, @robot.
 
& SAFE
  Flag: SAFE(s)
 
  When set, requires the use of the /override switch to @destroy in order to
  destroy the object.  It does not prevent the destruction of the object,
  but merely requires some additional effort.  If a thing is set DESTROY_OK,
  its SAFE flag is ignored and it may be destroyed without using the /override
  switch.
  See also: @destroy, DESTROY_OK.

& TRANSPARENT
  Flag: TRANSPARENT (t)
 
  If an exit is TRANSPARENT, then when you look at it you see the description
  of the room on the other side of the exit in addition to the description
  of the exit.
 
  If a room is TRANSPARENT, exits are displayed in a "long" format,
  showing their destinations.
 
& HTML
  Flag: HTML (~)
 
  If a player is set HTML, he can receive HTML output. This flag is 
  normally set by the invocation of a PUEBLOCLIENT command, and removed
  upon disconnection.
 
  See also: Pueblo.

& SLAVE
  Flag: SLAVE (x)
 
  If set on a player, neither the player nor any of his objects may perform
  any commands that change the database.  Some sites may restrict additional
  commands.  This flag may only be set or cleared by wizards.

& CONTROL_OK
  Flag: CONTROL_OK (z)
 
  This flag doesn't do anything yet.
& ANSI
  Flag: ANSI (X)
 
  When set on a player, this flag will enable the player to see ANSI
  control sequences, such as hilites and colors.
 
  TinyFugue users who do not wish to see ANSI color should leave this flag
  on, but '/set emulation=ansi_strip'. This saves the server some processing
  work; if a user has the ANSI flag unset, the server has to go through
  each line of text the user sees and strip the ANSI from it. Thus, if
  a user can do it in-client, this is preferable.
 
  See also: NOBLEED, ansi(), stripansi().
& NOBLEED
  Flag: NOBLEED (-)
 
  When set on a player, this flag will append an ANSI white character to
  the normal ANSI 'normal' character, which will hopefully fix ANSI color
  'bleed' (color extending into text it's not meant to extend into) on
  most terminals. This flag should not be set unless necessary; it causes
  the server to have to do some extra processing.
 
  See also: ANSI, ansi(), stripansi().
 
& STOP
  Flag: STOP (!)
 
  This flag is only settable by Wizards. If one or more $commands are
  matched on an object set STOP, no attempt will be made to match $commands
  on further objects. See 'help command evaluation' for an exact list of
  the matching order.
 
  This flag is intended primarily for use on master-room and ZONE
  local-master-room objects. The objects in the room should be 
  ordered, first to last, in order of probability of a match. Since
  master-room objects typically have many commands on them, and 
  multiple matches on the same command are not used/desired, this
  flag can save the needless computational expense of extra matching.
 
& ZONE
  Flag: ZONE (o)
 
  When set on an object, it declares this object a "Zone". Anything
  which is parented to an object set ZONE treats that parent object like
  a local equivalent of the Master Room, provided that the configuration
  option "local_master_rooms" is turned on. To be precise:
 
  If a player types a command, and it is not an exit, built-in command,
  or $command on an object nearby, if his current location is parented 
  to something set ZONE, the contents of that parent object will be
  checked for $commands, in the same way that Master Room objects are
  (i.e. the parents of the objects in the ZONE room are not checked for
  $commands). If the ZONE object also has a parent which is set ZONE, then 
  the contents of that object will be checked, and so on. 
 
  If nothing is matched in this way, then, if the player himself
  is parented to a ZONE object, that object's contents are checked. 
  "Secondary parents" are not checked for player zones. If still nothing 
  matches, only then will the global Master Room be checked.
 
  Continued in 'help Zone2'.
 
& ZONE2
 
  Most of the same caveats which apply to the global Master Room also apply
  to ZONE objects (henceforth referred to as local master rooms). The number
  of objects in the room should be kept to an absolute minimum. Objects
  which do not have $commands on them should not be placed in the room.
  Objects placed in a master room should only contain attributes with 
  $commands and other essentials (@startup, @forwardlist, and so forth);
  data attributes should be placed on another object (parenting the commands
  object to a data object is helpful, since master room checks do not
  look at the parent for $commands).
 
  Commands on objects in a local master room are run with the permissions
  of that object. This enables an area to utilize a set of $commands that
  might run with the permissions of different builders; furthermore, ZONEs
  enable a single command object to be set INHERIT, if that sort of 
  permission is needed (since simply putting $commands directly on the
  parent room causes those $commands to run with the permissions of the
  child object).

& ARBITRARY COMMANDS
  Topic: ARBITRARY COMMANDS
 
  You may define commands that are triggered whenever someone enters a command
  that matches the command template (wildcarding allowed).  These commands
  are called arbitrary commands, user-defined commands, or $-commands (for how
  they are defined), and they are checked for only after the check for
  single-character commands, exits, and internal commands have been performed
  and have failed (so an arbitrary command that matches 'page *' will never
  be performed).
 
  You define an arbitrary command by storing a string of the form
  '$<template>:<commandlist>' in an attribute of an object, then the command
  will be available to anyone who carries the object, is in the same room as
  the object, or is inside the object.  Only use user-named attributes and
  VA-VZ for arbitrary commands, as many of the predefined attributes are not
  for arbitrary commands.  <template> is the pattern to check for (it may
  contain wildcards), and <commandlist> is a semicolon-separated list of
  commands to perform.  The text that the wildcard characters matched are
  available in the variables %0 through %9.
{ 'help arbitrary2' for more }
& arbitrary2
  Example:
    > @va testobj = $foobar *:"I was foobar'ed with %0.
    Set.
    > foobar xyzzy
    testobj says "I was foobar'ed with xyzzy"
 
  You can prevent individual attributes from being checked for $-commands
  with the command '@set <obj>/<attr> = no_command'.  Attributes so set
  are reported with ($) following the attribute name when examined.
  The command '@set <obj>/<attr> = !no_command' clears the flag.
 
  You can also match a regular expression rather than wildcards. See
  'help RegExps' for details.
 
  The following attributes are never checked for $-commands: ALIAS CHARGES
  DESC DROP FAIL IDESC ODESC ODROP OFAIL OSUCC SEX SUCC.
 
  See also: @set.

& PIPING
  Topic: PIPING
 
  It is possible to "pipe" the output of one command to another, in a
  fashion similar to that of a UNIX shell. The output from the first
  command in a pipe is passed to the next command as the percent
  substitution %| -- and the output from that command can be piped
  into yet another command, and so forth.
 
  The output of a pipe contains the raw ASCII codes which would normally
  be directly output to the terminal. All pipe output is terminated with
  a newline (equivalent of a '%r'). Raw output can be treated using
  the translate() function.
 
  The pipe symbol is ';|', and is used much like the standard semicolon
  used to separate commands. As with the semicolon, the pipe symbol is
  taken literally if entered from the terminal. The maximum number of
  chained pipes defaults to 20.
 
  See 'help Piping2' for examples.
 
& PIPING2
 
  Examples of a pipe:
 
    > &DO_SEEDESC me=$+seedesc *: look %0 ;| @pemit %#=--%r%|--
    > +seedesc me
    --
    Wizard(#3PWc)
    You see someone special.
    --
 
& REGEXPS
  Topic: REGEXPS (Regular Expressions)
 
  The majority of matching in MUSH is done with wildcard ("globbing")
  patterns. There is a second type of matching, using regular expressions,
  that is available in certain circumstances.
 
  For attributes that are $-commands or ^-listen-patterns, setting that
  attribute "regexp" (with '@set <object>/<attribute>=regexp') causes
  patterns to be matched using regular expressions rather than globbing.
 
  In a regular expression match, the substring of the string which matched
  the regexp pattern is %0; %1 through %9 are the substrings of the string
  which matched parenthesized expressions within the regexp pattern. 
 
  Continued in 'help regexps2'.

& REGEXPS2
  Regular expressions are extremely useful when you want to enforce
  a data type. For example, if you have a command where you want a
  player to enter a string and a number ('+setnum <player>=<number>',
  for example), you might do it like this:
 
  &DO_NUM Command Object=$^\+setnum (.+)=([0-9]+)$: @va me=Data: %1 = %2
  @set Command Object/DO_NUM = regexp
 
  Then, '+setnum cookies=30' would set VA to "Data: cookies = 30".
  This eliminates your having to check to see if the player entered
  a number, since the regular expression matches only numbers.
  Furthermore, the '+' guarantees that there needs to be at least
  one character there, so a player can't enter '+setnum cookies='
  or '+setnum =10' or similarly malformed input.
 
  The '+' sign in the command has to be escaped out, or it is taken as
  a regexp token. Furthermore, the pattern-match has to be anchored
  with ^ and $, or something like 'try +setnum cookies=30 now' would
  also match. Regexps are case-sensitive; wildcard globbing is not.
 
  Regular expression syntax is explained in 'help regexp syntax'.

& REGEXP SYNTAX
  Topic: REGEXP SYNTAX
 
  TinyMUSH supports regular expression syntax virtually identical to
  the extended regular expressions supported by Perl 5.
  See 'help regexp examples' for a very simple explanation of the basics.
 
  TinyMUSH implements this functionality using the PCRE 2.04 library,
  written by Philip Hazel <ph10@cam.ac.uk>, Copyright (c) 1997-1999
  University of Cambridge. The remainder of this help entry is derived
  from its manual pages. The supported functionality is equivalent to
  Perl 5.005 regular expressions.
 
  A regular expression is a pattern that is matched against a subject
  string from left to right. Most characters stand for themselves in a
  pattern, and match the corresponding characters in the subject. 
 
  Continued in 'help regexp syntax2'.
 
& REGEXP SYNTAX2
 
  There are two different sets of meta-characters: those that
  are recognized anywhere in the pattern except within square
  brackets, and those that are recognized in square brackets.
  Outside square brackets, the meta-characters are as follows:
 
       \      general escape character with several uses
       ^      assert start of subject
       $      assert end of subject
       .      match any character except newline
       [      start character class definition
       |      start of alternative branch ("or")
       (      start subpattern
       )      end subpattern
       ?      0 or 1 quantifier (after a unit to quantify)
              or, minimal match (after a quanitifier)
              or,  extends the meaning of ( after a ( 
       *      0 or more quantifier
       +      1 or more quantifier
 
  Continued in 'help regexp syntax3'.
 
& REGEXP SYNTAX3
 
  Part of a pattern that is in square brackets is called a
  "character class". It matches any character listed in the class.
  In a character class, the only metacharacters are:
 
       \      general escape character
       ^      negate the class, if the first character in the class
       -      indicates character range (e.g. A-Z, 0-4)
       ]      terminates the character class
 
  A backslash will escape most metacharacters, and can turn
  some normal characters into generic character types:
 
       \d     any decimal digit
       \D     any character that is not a decimal digit
       \s     any whitespace character
       \S     any character that is not a whitespace character
       \w     any "word" character (letter, digit, or underscore)
       \W     any "non-word" character
 
  Continued in 'help regexp syntax4'.
 
& REGEXP SYNTAX4
 
  Quantifiers specify repetition of characters. They are:
 
       {N}    match exactly N of whatever came before
       {M,N}  match at least M but not more than N of whatever came before
       *      match 0 or more of whatever came before, equiv. to {0,}
       +      match 1 or more of whatever came before, equiv. to {1,}
       ?      match 0 or 1 of whatever came before, equiv. to {0,1}
 
  Quantifiers are usually "greedy" -- they match as much as possible.
  Adding a ? after a quantifier causes it to match as little as
  possible instead. 
 
  Continued in 'help regexp syntax5'.
 
& REGEXP SYNTAX5
 
  Outside a character class, a backslash followed by a digit greater
  than 0 (and possibly further digits) is a back reference to a
  capturing subpattern earlier (i.e. to its left) in the pattern,
  provided there have been that many previous capturing left parentheses.
  A back reference matches whatever actually matched the capturing
  subpattern in the current subject string, rather than anything matching
  the subpattern itself. Thus, the pattern:
 
    (sens|respons)e and \1ibility
 
  matches "sense and sensibility" and "response and responsibility",
  but not "sense and responsibility". 
 
  Continued in 'help regexp syntax6'.
 
& REGEXP SYNTAX6
 
  An assertion is a test on the characters following or preceding the
  current matching point that does not actually consume any characters.
  There are two kinds: those that look ahead of the current position in
  the subject string, and those that look behind it.
 
  An assertion subpattern is matched in the normal way, except that it
  does not cause the current matching position to be changed. Lookahead
  assertions start with  (?=  for positive assertions and (?! for
  negative assertions. For example, lookbehind assertions start with
  (?<=  for  positive  asser- tions and (?<! for negative assertions.

  Assertion subpatterns are not capturing subpatterns, and may not
  be repeated, because it makes no sense to assert the same thing
  several times. If an assertion contains capturing subpatterns within it,
  these are always counted for the purposes of numbering the capturing
  subpatterns in the whole pattern.

  Continued in 'help regexp syntax7'.

& REGEXP SYNTAX7
 
  There are also two useful backslash assertions:
  
       \b     word boundary
       \B     not a word boundary
 
  A word boundary is a position in the subject string where the
  current character and the previous character do not both match \w or
  \W (i.e. one matches \w and the other matches \W), or the start
  or end of the string if the first or last character matches \w,
  respectively.
 
  Continued in 'help rexpexp syntax8'.
 
& REGEXP SYNTAX8
 
  Other, more complex features, such as conditional subpattern patching,
  and embedded comments in regular expressions, are also supported. 
  Try a World-Wide Web search for PCRE, or consult a book on regular
  expressions, for more details.
 
& REGEXP EXAMPLES
  Topic: REGEXP EXAMPLES
 
  The regexp pattern '.' is equivalent to the wildcard '?'; it matches
  one and only one of an arbitrary character.
 
  The regexp pattern '.+' is equivalent to the wildcard '*'; it matches
  one or more arbitrary characters. To match zero or more arbitrary
  characters, the regexp pattern is '.*'.
 
  To match a string of numbers, use:       [0-9]+
  To match a string of letters only, use:  [A-Za-z]+
 
  See 'help regexp syntax' for a more detailed explanation.

& ATTRIBUTE OWNERSHIP
  Topic: ATTRIBUTE OWNERSHIP
  The attributes on an object may be owned independently from the object.
  Normally, the owner of the object owns all of its attributes.
  In addition to an owner, each attribute also has a locked flag,
  set or cleared with @lock <obj>/<attr> and @unlock <obj>/<attr>.
  This flag controls whether or not the owner of the object may
  @chown the attribute to himself with @chown <object>/<attrib>,
  as well as whether or not the attribute is automatically @chowned to
  the new owner when the object is @chowned.
 
  You may lock and unlock attributes that you own on any object (whether
  you own the object or not), and you may @chown an attribute that you own
  to the owner of the object if it is unlocked.  The examine command
  will show you all attributes that you own on an object, even if you
  don't own the object.
{ 'help attrib2' for more }
& attrib2
  Locked attributes may not be modified or removed, and do not change ownership
  when the object containing them is @chowned.
 
  You may not modify or remove attributes that you own that are stored
  on objects that you do not own, but you may modify or remove attributes
  owned by others on your objects (if you do this, the attribute becomes owned
  by you).
 
  If an attribute is owned by someone other than the object's owner, then
  the number of the attribute's owner is shown in parentheses immediately
  after the attribute name.  If there are any flags set on the attribute,
  those flags are indicated in the parentheses too.
 
  The + flag means means that the attribute is locked (so that it will not
  change ownership of the object is @chowned), the $ flag means that
  $-commands are not checked for that attribute.  The I flag indicates that
  the attribute is not inherited by children of the object, and the V flag
  shows that the attribute is publically visible.
{ 'help attrib3' for more }
& attrib3
 
  When checking an attribute lock against an object, the lock will always
  fail if the locked object is not owned by the same player as the attribute
  being tested.  The comparison specified in the lock is only performed if
  the owner of the locked object also owns the attribute on the object
  being checked.
 
  See also: @chown, @lock, @set, @unlock, examine.

& BEING KILLED
  Topic: BEING KILLED  
 
  Getting killed is no big deal. If you are killed, you return to your home,
  and  all things you carry return to their homes. You also collect 50 coins
  in insurance money (unless you have >= 10000 coins or you were killed via
  the Wizard slay command).  Generally, killing is not encouraged unless 
  absolutely necessary. (Note: Killing a wizard is a quick way to discover
  the many uses of the @boot command...  and killing anyone can be very
  rude.)
  See also: kill, @akill, @kill, @okill, IMMORTAL, WIZARD.

& BOGUS COMMANDS
  Topic: BOGUS COMMANDS    
  
  Bogus commands can be made using exits. For example, to make a 'sit'
  command, one could "@open sit", then "@link sit=here" (because unlinked
  exits can be stolen), "@lock sit=#0" (impossible for a room to pass a lock,
  #0 is always a room, therefore the lock always fails), and "@fail sit=You
  sit on the chair."; "@ofail sit=sits on the chair.".  Since nobody can go
  through it, it always fails. The @fail message is displayed  to the player,
  and the @ofail message (preceded by the player's name) to  everyone else.  
  See also: @afail, @fail, @link, @lock, @ofail, @open.

& BOOLEAN VALUES
  Topic: BOOLEAN VALUES
 
  Boolean values are considered to be true (1) or false (0), as follows:
 
    - All numbers are true, except for zero, i.e.:
      t(0) => 0		t(1) => 1	t(532) => 1	t(-1987) => 1
  
    - All dbrefs (#0 and higher) are true. #-1 and below are false.
      Note that, for example, #1000 is true even if there aren't that
      many objects in the database. Use isdbref() to check if a dbref
      is actually valid. Also, lists of dbrefs are valid, as are
      other strings starting with dbrefs other than '#-1 <string>':
 
      t(#0) => 1		t(#1) => 1		t(#-1) => 0
      t(#-5) => 0		t(#0 #3 #5) => 1	t(#1 #34 #6) => 1
      t(#-1 NO MATCH) => 0      t(#-2 test) => 1	t(#-37 xx) => 1
      t(#7 testing) => 1
 
    - All other non-empty strings are true, i.e.:
      t(foo) => 1	t() => 0
 
  Continued in 'help Boolean Values2'. 
 
& BOOLEAN VALUES2
 
  If the configuration parameter booleans_oldstyle is enabled (it is
  disabled by default), the boolean value of dbrefs (strings that
  start with a '#', effectively) is altered as follows:
 
  - All numeric dbrefs other than #0 and #-1 are considered to be true.
 
  - Anything non-numeric that has a '#' prefix is considered false.
    This includes lists of dbrefs.
 
  - Examples of results if booleans_oldstyle is enabled:
 
    t(#0) => 0			t(#1) => 1		t(#-1) => 0
    t(#-5) => 1			t(#0 #3 #5) => 0	t(#1 #34 #6) => 0
    t(#-1 NO MATCH) => 0	t(#-2 test) => 0	t(#-37 xx) => 0
    t(#7 testing) => 0
 
  Functions such as andbool() and ifelsebool() use boolean values.
 
& CONTROL
  Topic: CONTROL      
 
  There are 5 rules to controlling objects:
   1) You control anything you own.
   2) Anything you own that has its INHERIT flag set controls anything you 
      own (including you).
   3) Anything you own that does not have its INHERIT flag set only controls
      other things that you own that do not have their INHERIT flag set and
      do not control you, unless YOU have your inherit flag set.
   4) A wizard controls everything.
   5) Anybody controls an unlinked exit, even if it is locked.
 
  Builders should beware of 5, lest their exits be linked or stolen.
 
  Most of the commands for altering the database and many commands and
  functions that retrieve information only work on objects that you control.

& COSTS      
  Topic: COSTS
 
  Certain commands cost money to use, they will fail if you don't have
  enough.  Use the @list costs command to find out what these commands are
  and how much they cost.
  See also: @list.

& CREDITS
  Topic: CREDITS
 
  TinyMUSH 3.0 is a fusion of TinyMUSH 2.2 and TinyMUX, and so we must
  thank everyone associated with those projects, as well as the original
  TinyMUSH 2.0 and its predecessors.
 
  TinyMUSH 2.0 is derived from Larry Foard's TinyMUSH (which was itself 
  derived from TinyMUD, written by Jim Aspnes). TinyMUSH 2.0, written by
  JT Traub (Moonchilde@PernMUSH) and Glenn Crocker (Wizard@TinyCWRU),
  was a consolidation of features found in other servers, including
  TinyMUSH, PernMUSH, TinyTIM, and, later, PennMUSH.
 
  TinyMUSH 2.2 is primarily the work of Jean Marie Diaz (Ambar@PernMUSH),
  Deborah Wilson-Hooker (Tyleet@TwoMoons), and Lydia Leong (Amberyl@PernMUSH).
  TinyMUX is primarily the work of David Passmore (Lauren@From the Ashes).
 
  Many, many people have contributed to TinyMUSH; our list of "thanks" is
  by no means complete.
 
  See 'help Credits2' for the list of names.
 
& CREDITS2
 
Significant code, ideas, bugfixes, and support have been contributed
over the years by many people, including, in alphabetical order:
 
Dean Gaudet		Robby Griffin		Stephen J. Kiernan
Andrew Molitor		T. Alexander Popiel	Marcus Ranum
Alan Schwartz		Jennifer Smith		Russ Smith
Deborah Wilson-Hooker	Airam@Generations	Ambar@Pern
Coyote@TinyTIM		Dreamline@Horizons	Ethaniel@BTech3056
Evinar			Furie@DungeonMUSH	Harlock@StarWarsII
Hcobb@TinyTIM		Jellan@Pern		Kalkin@DarkZone
Kayan Telva@BTech3056	Mike@StarWars		Miritha@Pern
R'nice@TinyTIM		Sh'dow@Pern		Sketch@TinyTIM
 
& DROP-TOS
  Topic: DROP-TOS
 
  When the @link command is used on a room, it sets a drop-to location.  Any
  object dropped in the room (if it isn't STICKY) will go to that location.
  If the room is STICKY, the drop-to will be delayed until the last person in
  the room has left.
  See also: @link, STICKY.

& ENACTOR
  Topic: ENACTOR
 
  The enactor is the object that caused an action list to be performed.
  So, the enactor of the Ahear action list is the player or object who
  said/emoted/etc the message that matched the Listen attribute, the
  enactor of the Apay attribute is the player who gave the object money, etc.
  The enactor of an attribute that is run by a @trigger command is the 
  object that ran the @trigger command.  The following substitutions can be
  performed in an action list to return information about the enactor:
 
    %# or [v(#)]           - Database number of the enactor
    %N/%n or [v(N)]/[v(n)] - Name of the enactor.
    %O/%o ...              - Objective pronoun for the enactor
                             (him her it them)
    %P/%p ...              - Possessive pronoun (his her its their)
    %S/%s ...              - Subjective pronoun (he she it they)
    %A/%a ...              - Absolute possessive pronoun (his hers its theirs)
  See also: SUBSTITUTION.

& MOVING
  Topic: MOVING
 
  A number of things happen when you leave one location and enter another
  (assuming you pass the lock on the exit or have permission to enter the
  object or to teleport to the location).  The following list describes the
  actions that MUSH takes when an object moves from one place to another.
  Note that if an indicated attribute is not set, no message is displayed
  (or no action is performed).
 
  - If you are using an exit (as opposed to teleporting, entering an object,
    or going home), You receive the SUCC message for the exit, others in the
    old location receive the exit's OSUCC message, and the exit runs its
    ASUCC action list.
  - If you are teleporting or being teleported, others in the old location
    receive your OXTPORT attribute.
  - If you are a player or have your LISTEN attribute set to something,
    and if the old location is not dark and you are not dark, you receive the
    LEAVE message for the old location, others in the old location receive
    the OLEAVE message, and the old location runs its ALEAVE action list.
    Others in the new location receive the OXENTER message from the old
    location, and others in the old location receive the message '<yourname>
    has left.'
{ 'help moving2' for more }
& moving2
  - You are moved to the new location.  If you are entering an object,
    teleporting, or going home, all KEY objects are stripped from you.
  - If the new location is a room, you receive the room's DESC, others in the
    room receive the ODESC, and the room runs its ADESC.  If you pass the
    room's lock do the same with SUCC, OSUCC, and ASUCC, otherwise use FAIL,
    OFAIL, and AFAIL.
  - If the new location is a player or an object, you receive the location's
    IDESC (or DESC if the IDESC is not set).  In either event, others in the
    same location see the ODESC message and the location runs its ADESC 
    action list.
  - You are shown the contents and visible exits if the location is not DARK.
  - If you used an exit, then you receive the DROP message for the exit,
    others in the new room receive the exit's ODROP message, and the exit
    runs its ADROP action list.
  - If you are teleporting or being teleported, you receive your TPORT
    attribute, others in your new location receive your OTPORT attribute,
    and your ATPORT attribute is run.
  - You receive your MOVE attribute, others in your new location receive
    your OMOVE attribute, and your AMOVE attribute is run.
{ 'help moving3' for more }
& moving3
  - If you are a player, or have your LISTEN attribute set to something,
    and if the old location is not dark and you are not dark, you receive the
    ENTER message for the new room, others in the new room receive the OENTER
    message, and the new room runs its AENTER action list. Others in the room
    you just left receive the new room's OXLEAVE message, and others in the
    old location receive the message '<yourname> has arrived.'
  - If the old location is a STICKY room and has its drop-to set, see if
    objects in that room should be sent to the drop-to location.  If so,
    do it.
  - If you are a player, you have a chance of finding some money.
 
  See also: @adesc, @adrop, @aenter, @afail, @aleave, @asucc, @atport, @desc,
            @drop, @enter, @fail, @leave, @listen, @odesc, @odrop, @oenter,
            @ofail, @oleave, @osucc, @oxenter, @oxleave, @oxtport, @succ,
            @tport, move, @teleport, home, KEY, STICKY, DROP-TOS, FAILURE,
            SUCCESS.
& EXITS
  Topic: EXITS
 
  An exit links one location to another location, providing a way to travel
  on the MUSH.  Although normally used to link rooms together, exits can be
  made to and from players and objects.
 
  You may pick up exits that you own, and drop exits into locations that
  you own.  When you pick up or drop an exit, anyone in the exit's new
  location may use the exit and travel to its destination.
 
  If an exit is set DARK it will not show up in the list of obvious exits in
  a room.
  See also: @link, @open.

& FAILURE
  Topic: FAILURE  
 
  You fail to use a player or a thing when you cannot take it (because it's
  lock fails).  You fail to use an exit when you cannot go through it
  (because it is unlinked or locked). You fail to use a room when you fail
  to look around (because it's locked).
  See also: get, look, @afail, @fail, @lock, @ofail, STRINGS.

& FLAGS
  Topic: FLAGS
 
  Everything in the universe of this MUSH (Rooms, Exits, Things, Players,
  etc) are represented in the same way at the program level.  A room merely
  has the room flag set and a player has the player flag set.  In addition,
  flags also give objects abilities or qualities.  For instance, a wizard
  has the wizard flag set.  That is what lets the program know he may use
  wizard abilities.  An object or room may have the dark flag set. In the
  case of an object, this makes the object invisible to normal eye-sight.
  In the case of a room, the room becomes too dark to see other objects or
  players.  To get a list of the flags that are available, type '@list flags'
  or 'help flag list'. For more specific information on a particular flag,
  request help on the flag's name, as in 'help ENTER_OK'.

& FLAG LIST
  Topic: FLAG LIST
 
	A - Abode	B - Blind	C - Chown_OK	D - Dark	
	E - Exit	F - Floating	G - Going	H - Haven	
	I - Inherit	J - Jump_OK	K - Key		L - Link_OK	
	M - Monitor	N - Nospoof	O - Opaque	P - Player	
	Q - Quiet	R - Room	S - Sticky	T - Trace	
	U - Unfindable	V - Visual	W - Wizard	X - Ansi	
	Y - Parent_OK	Z - Royalty	a - Audible	b - Bounce	
	c - Connected	d - Destroy_OK	e - Enter_OK	f - Fixed	
	g - Uninspected	h - Halted	i - Immortal	j - Gagged	
	k - Constant	l - Light	m - Myopic	n - Auditorium	
	o - Zone	p - Puppet	q - Terse	r - Robot	
	s - Safe	t - Transparent	u - Suspect	v - Verbose	
	w - Staff	x - Slave	z - Control_OK	! - Stop	
	$ - Commands	- - NoBleed	~ - HTML	. - Compress	
	? - Head	| - Vacation
  
  See 'help Marker' for help on user-defined flags (0 through 9).
 
  For information on a particular flag, type 'help <flagname>'.
 
& FUNCTIONS
  Topic: FUNCTIONS
 
  Functions are specialized commands used to manipulate strings and other
  input. The format for a function is of this form: [fun-name(<input>)]
  Although usually the []'s indicate an input that is optional, in this case
  they are necessary and tell the MUSH that this is a function, although
  nested functions (like [first(rest(This is a nice day))] returns 'is') do
  not require more than one pair of []'s.  Nested brackets may be used when
  it is necessary to insert a function call in the middle of an argument,
  like [get(me/[get(me/vz)])], which returns the contents of the attribute
  named in the VZ attribute.
 
  For help on a particular function, type 'help <functionname>'.  You may
  need to include the parentheses with the function name, ie.
  'help <functionname>()'.  Type 'help function list' or '@list functions'
  for a list of the available functions.  'help function classes' will show
  a list of the functions broken down into classes.
 
  See also: @list functions, FUNCTION CLASSES, FUNCTION LIST, DELIMITERS.

& FUNCTION LIST
  Topic: FUNCTION LIST
 
  See the following help topics for the relevant function lists:
 
  Attribute Functions: retrievel of attribute-related information.
  List Functions: manipulation of lists.
  Math Functions: math and logic.
  Misc Functions: miscellaneous utilities.
  Object Functions: retrieval of object-property-related information.
  Pueblo Functions: available only when Pueblo is enabled.
  Side-Effect Functions: side-effect functions.
  Stack Functions: manipulation of object stacks.
  String Functions: manipulation of strings.
  Structure Functions: manipulation of data structures.
  Variable Functions: manipulation of object-associated variables.
   
  See 'help <function name>' for more information about a specific function.
 
& FUNCTION CLASSES
 
  See "help function list".
 
& ATTRIBUTE FUNCTIONS
  Topic: Attribute Functions
 
	aposs()		default()	edefault()	eval()
	get()		get_eval()	grep()		grepi()
	hasattr()	hasattrp()	lattr()		obj()
	objeval()	poss()		subj()		u()
	udefault()	ulocal()	v()		xget()
	zfun()
 
& OBJECT FUNCTIONS
  Topic: Object Functions
 
	andflags()	children()	con()		conn()
	controls()	cwho()		doing()		elock()
	exit()		flags()		findable()	fullname()	
	hasflag()	haspower()	hastype()	home()		
	idle()		inzone()	lastcreate()	lcon()		
	lexits()	lparent()	loc()		locate()	
	lock()		lwho()		mail()		mailfrom()	
	money()		name()		nearby()	next()		
	num()		objmem()	orflags()	owner()		
	parent()	pfind()		playmem()	pmatch()	
	ports()		programmer()	rloc()		room()		
	search()	sees()		stats()		type()		
	visible()	where()		xcon()		zone()		
	zwho()
 
& SIDE-EFFECT FUNCTIONS
  Topic: Side-Effect Functions
 
	command()	create()	force()		link()		
	set()		tel()		trigger()	wait()		
	wipe()
 
& LIST FUNCTIONS
  Topic: List Functions
 
	columns()	elements()	extract()	filter()	
	filterbool()	first()		fold()		grab()		
	index()		insert()	iter()		last()		
	ldelete()	list()		lnum()		loop()
	lpos()		lrand()		map()		match()
	matchall()	member()	mix()		munge()		
	remove()	replace()	rest()		revwords()	
	setdiff()	setinter()	setunion()	shuffle()	
	sortby()	sort()		splice()	step()	
	while()		words()
 
& MATH FUNCTIONS
  Topic: Math and Logic Functions
 
  Logic:
	eq()		gt()		gte()		lt()
	lte()		neq()		ncomp()
	not()		t()
	and()		or()		xor()
	andbool()	notbool()	orbool()	xorbool()
 
  Miscellaneous:
	add()		abs()		ceil()		dec()
	dist2d()	dist3d()	div()		e()		
	exp()		fdiv()		floor()		inc()
	ladd()		land()		landbool()	lmax()
	lmin()		ln()		log()		lor()
	lorbool()	max()		min()		mod()
	mul()		pi()		power()		round()
	sign()		sqrt()		sub()		trunc()
 
  Continued in 'help Advanced Math Functions'.
 
& ADVANCED MATH FUNCTIONS
  Topic: Advanced Math Functions
 
  Bitfield manipulation:
	band()		bnand()		bor()
	shl()		shr()
 
  Trigonometry:
	acos()		asin()		atan()
	cos()		sin()		tan()
 
  Vectors:
	vadd()		vdot()		vmul()		vsub()
	vdim()		vmag()		vunit()
 
& MISC FUNCTIONS
  Topic: Miscellaneous Functions
 
	case()		config()	convsecs()	convtime()	
	die()		ifelse()	localize()	mudname()	
	nonzero()	pemit()		r()		rand()		
	remit()		restarts()	restarttime()	s()		
	secs()		setq()		setr()		sql()		
	starttime()	switch()	switchall()	time()		
	version()
 
& STRING FUNCTIONS
  Topic: String Functions
 
	after()		alphamax()	alphamin()	ansi()
	beep()		before()	capstr()	cat()
	center()	chomp()		comp()		decrypt()
	delete()	edit()		encrypt()	escape()
	foreach()	isdbref()	isnum()		isword()	
	lcstr()		left()		lit()		ljust()
	merge()		mid()		null()		pos()
	regmatch()	repeat()	reverse()	right()
	rjust()		secure()	scramble()	space()
	squish()	strcat()	streq()		stripansi()
	strlen()	strmatch()	strtrunc()	translate()
	trim()		ucstr()		valid()		wordpos()
 
& STRUCTURE FUNCTIONS
  Topic: Structure functions
 
  Every object can be associated with a number of data structures. A
  data structure consists of an arbitrary number of components (elements);
  each component has a data type. An object can have multiple instances
  of each data structure that has been defined for it; each instance is
  associated with data. These data structures provide the ability to
  abstract, to some extent, the manipulation of data.
 
  The structure functions are:
 
	construct()	destruct()	load()		linstances()
	lstructures()	modify()	structure()	unload()	
	unstructure()	z()
 
  All of these functions operate on the calling object; to manipulate
  structures on other objects, wrap the function calls in an objeval().
 
  There is a configurable maximum number of structure definitions per
  object, typically 100. There is also a configurable maximum number of
  instances per object, typically 100. Always destruct() unneeded instances!
 
& VARIABLE FUNCTIONS
  Topic: Variable functions
 
  Every object has the ability to be associated with a number of temporary
  variables. These variables can be arbitrarily named, and persist until
  the game is restarted. Functions are used to set and retrieve these
  variables, and all operate directly on the object making the function
  call; to manipulate variables on other objects, wrap the call in an
  objeval(). With the exception of lvars() and x(), all the functions
  operate strictly via side-effects, and return an empty string.
 
  The variable functions are:
 
	clearvars()	let()		lvars()		regparse()
	setx()		x()		xvars()
  
  There is a configurable maximum number of variables per object,
  typically 50. If an attempt is made to set more than 50 variables,
  it will fail silently. See 'wizhelp variables_limit' for details.
 
& STACK FUNCTIONS
  Topic: Stack functions
 
  Every object has the ability to store a single stack of data, referred
  to as an "object stack" (distinguishing it from the "command stack",
  i.e. %0 - %9). Object stacks can store an arbitrary number of strings,
  and are meant to be used for temporary variable storage; they are not
  preserved across restarts.
 
  The stack functions are:
 
	dup()		empty()		items()		lstack()
	peek()		pop()		popn()		push()
	swap()		toss()
 
  All stack functions require the caller to control the object.
  There is a configurable maximum number of stack items per object,
  usually 50, beyond which point attempts to push additional items onto
  the stack will fail silently; see 'wizhelp stack_limit' for details.
 
  Continued in 'help Stack Funcs2'.
 
& STACK FUNCS2

  A "stack" is a last-in, first-out (LIFO) data structure. You can think
  of a piece of data stored in a stack as being equivalent to a plate
  with something written on it. The first plate you put in goes on the
  bottom of the pile. The second plate goes on top of the first plate,
  the third plate goes on top of the second plate, and so forth. When
  you go to pick up a plate, the top plate is the last plate you put
  on the stack (the third plate, in this example).
  
  Putting a piece of data on top of the stack is calling "pushing" data
  onto the stack. Taking a piece of data off the top of the stack is 
  called "popping" data off the stack. Pieces of data on a stack are
  frequently referred to as "items".
 
  Items in a stack are numbered top to bottom, starting with zero. 
  That means that the top item on the stack is item 0, the next
  item down is item 1, and so forth. A stack with N items is therefore
  numbered 0 to N-1.

& PUEBLO FUNCTIONS
  Topic: Pueblo Functions
 
  The functions html_escape(), html_unescape(), url_escape(), and 
  url_unescape() are only available when Pueblo support is enabled.
 
  HTML escapes affect these symbols:
  <	becomes		&lt;		>	becomes		&gt;	
  &	becomes		&amp;		"	becomes		&quot;
 
  URL escapes affect these symbols (which are converted to hex):
  < > # % { } | \ ^ ~ [ ] ' ; / ? : @ = & " +
  Spaces are also converted to '+' by url_escape().
 
  See also: Pueblo.

& DELIMITERS
  Topic: DELIMITERS
 
  A large number of MUSH functions allow the specification of a list
  delimiter. Some allow this only for the input list; some also allow
  an output delimiter to be specified. All delimiters are single
  characters.
 
  The default delimiter is a space. The list "1 2 3" consists of three
  elements (1, 2, and 3), space-delimited. The list "1-2-3" also
  consists of the same three elements, but is dash-delimited.
 
  In the case where an input delimiter is specified, but an output
  delimiter is not, the output delimiter will default to the input
  delimiter, rather than defaulting to a space.
 
  Most functions that taken output delimiters can take a '%r' output
  delimiter, as well as a null output delimiter (i.e., just string all
  the output together, with no separator between each item). The null
  output delimiter is represented by the token '@@'.
 
  See examples:  iter(), map(), filter().
 
& GENDER
  Topic: GENDER
 
  A player's (virtual) gender is specified in the Sex attribute.  This
  attribute controls how gender-specific pronoun substitutions are evaluated
  for the player.  If the player's Sex attribute starts with an 'M' or an 'm'
  then the player is assumed to be male,  'F', 'f', 'W', and 'w' indicate
  female, 'P' or 'p' indicate plural, and anything else indicates neuter.
  See also: SUBSTITUTIONS.  

& GOALS
  Topic: GOALS
 
  There is no ultimate goal to this game, except to have fun.  There are
  objects and places to build, puzzles to solve, scenery to visit, and people
  to meet. There are no winners or losers, only fellow players.  Enjoy.

& HERE
  Topic: HERE 
 
  The word 'here' refers to the room you are in (if you are inside an object,
  it refers to the object that you are in, not the room that the object is
  in).  For example, to rename the room you are in (if you control it), you
  could enter '@name here= <new name>'.

& HOMES
  Topic: HOMES
 
  Every thing or player has a home.  This is where players when they go home,
  or things with the STICKY flag set go when dropped.  Homes are set with the
  @link command. A thing's home defaults to the room where it was created, if
  you control that room, or your home. You can link an exit to send players
  home with '@link <dir>=home'.  Drop-tos can also be set to 'home'.
  See also: @link, DROP-TO, STICKY.

& LINKING  
  Topic: LINKING
 
  You can link to a room if you control it, or if it is set LINK_OK or ABODE.
  Being able to link means you can set the homes of objects or yourself to
  that room if it is set ABODE, and that you can set the destination of exits
  to that room if it is LINK_OK.
  See also: @link, ABODE, LINK_OK.

& LISTENING
  Topic: LISTENING
 
  Thee are two ways to listen for something in a room. The easiest way
  is to use a combination of @listen and @ahear/@aahear/@amhear. The
  second way is to use a "^" pattern in an attribute, similar to the way
  "$" is used for user-defined commands. The attribute takes the form:
  '^<pattern>:<action>'.
 
  The ^-pattern check is only performed on objects with their MONITOR flag
  set.  The criterion for triggering a pattern-listen is the same as that for
  triggering an @ahear - the object cannot trigger its own listen patterns.
  All matching attributes have their <action>s performed, not just the first.
  Also, attributes with the no_command flag set are not checked for ^-patterns,
  and neither are objects' parents.
 
  Example:
    > @va test = ^* says "foo *":say I got a foo with %1!.
    Set.
    > @set test=monitor
    test grows ears and can now hear.
    > say foo bar
    You say "foo bar"
    test says "I got a foo with bar!."
  See also: @ahear, @listen, @set.

& LISTS
  Topic: LISTS
 
  A list is a string, usually stored in an attribute (currently any of the
  va-vz attributes), which is a series of words, separated by one or more
  spaces.  The following would be a list (denoted on the ends by ', which is
  not actually in the string): 'one two three four five'.  The functions
  first(), rest(), cat(), member(), and remove(), all work on lists.
 
  See also: cat(), first(), member(), remove(), rest().

& LOOPING
  Topic: LOOPING
 
  Looping in an object can have its good parts and its bad parts.  The good
  part is when you activate part of a program multiple times to exhaustively
  perform an operation.  This is usually done by:
     @va object =  <list of commands>;@trigger me/vb
     @vb object =  @switch <test> = <false>,@trigger me/va,<otherwise go on>
 
  Looping can be a problem when it goes on without stopping.  The @ps command
  can be used to see if you are looping.  Beware!  A looping machine that
  isn't @halt'ed will drain your money supply while you are away!
  See also: @halt, @ps.

& ME
  Topic: ME
 
  The word 'me' refers to yourself. Some things to do when starting out: 
 
  1) Give yourself a description with 
     '@desc me = <description>', then look at yourself with 'look me'.
 
  2) Set your gender, if you wish it known, with
     '@sex me=male' or '@sex me=female'  (or '@sex me=neuter' to be an 'it',
     or '@sex me=plural' to be a 'they').
 
  3) Prevent other people from picking you up, with '@lock me=me'
 
  4) Let other people give you money, but not jump into you, with
     '@lock/enter me=me' and then '@set me=ENTER_OK'
 
  5) Prevent other people from using you, with '@lock/use me=me'
 
& MONEY
  Topic: MONEY
 
  You need money to build within the game, to run programmed objects or use
  certain other commands, or to buy things from vendors set up by other
  players.  You can get money via one or more of these methods:
    1.  You receive a daily allowance for each day you connect.
    2.  You have a chance of finding money as you wander around areas that
        other people have built.
    3.  Some MUSHes may implement a place where you can sell valuable objects
        for money.
  See also: @list costs, COSTS.

& PUPPETS
  Topic: PUPPETS
 
  An object is made into a puppet by doing '@set <object>=puppet', once an
  object is a puppet it will relay all that it sees and hears to its master.
  All objects created by a puppet are owned by its master, when puppets spend
  or earn money, they use their master's money supply.  In order to prevent
  puppets from screwing up puzzles, objects may have the KEY flag set, this
  will prevent puppets from picking the object up. A puppet may be commanded
  by its master by '@force <object>=command', or by the shorthand version, 
  '#<number of puppet> command'.  The puppet flag is handy for debugging, as
  it allows you to see the result messages your object generates.
 
  Example:       
  @force fred="hi there.  -or-  #4342 "hi there.
  See also:  VERBOSE.

& ROBBERY
  Topic: ROBBERY
 
  Robbing is not allowed on this MUSH. If you really need money, ask your
  friendly neighborhood wizard.
  See also: MONEY.

& search classes
  Topic: SEARCH CLASSES
 
  You may use the following classes in @search commands and search()
  function calls:
  
  TYPE      - Restricts to objects of the indicated type (OBJECTS, ROOMS,
              EXITS, PLAYERS, GARBAGE). THINGS may be used as an alias
              for OBJECTS.
  NAME      - Restricts to objects whose names start with <restriction>.
  OBJECTS   - A combination of TYPE=OBJECT and NAME=<restriction>.
  THINGS    - An alias for OBJECTS.
  ROOMS     - A combination of TYPE=ROOM and NAME=<restriction>.
  EXITS     - A combination of TYPE=EXIT and NAME=<restriction>.
  PLAYERS   - A combination of TYPE=PLAYER and NAME=<restriction>.
  FLAGS     - Restricts to objects which have the flags listed in
              <restriction> set..
  EVAL      - Evaluates the restriction for each object, replacing ##
              with the object's database number.  Evaluations that return
              TRUE (ie, not 0 or #-1) are selected.
  EOBJECT   - A combination of TYPE=OBJECT and EVAL=<restriction>.
  ETHING    - An alias for OBJECTS.
  EROOM     - A combination of TYPE=ROOM and EVAL=<restriction>.
  EEXIT     - A combination of TYPE=EXIT and EVAL=<restriction>.
  EPLAYER   - A combination of TYPE=PLAYER and EVAL=<restriction>.

& SEMAPHORES
  Topic: SEMAPHORES
 
  Semaphores may be used for synchronizing complex objects or for enforcing
  mutual exclusion.  You may use any object you own or any LINK_OK object as
  a semaphore, and any type of object (thing, room, player, or exit) may be
  used.
 
  The semaphore state of an object is shown by the Semaphore attribute (which
  is read-only); a positive number indicates the number of commands awaiting
  notifies, and a negative number indicates the number of waits on that
  semaphore that will not block.
 
  Use the '@wait <object>' form of the @wait command to request a command be
  delayed until <object> is notified with the @notify command.  The @drain
  and @notify/all commands clear the semaphore on <object>, either
  discarding or executing all pending commands.  Remember that the
  object performing the @wait executes the command, not the object used
  as a semaphore. 
{ 'help semaphores2' for more }
& semaphores2
  You may also combine the semaphore and timer options of @wait with
  '@wait <object>/<timeout> = <command>'  If the time period expires before
  the semaphore is notified, then the command is executed and the semaphore
  count is decremented, just as if the command had been run because the
  semaphore had been notified.
 
  Examples: <simple>     @wait semaphore="Foo
                         @notify semaphore
            <mutex lock> @va mutex lock=@wait me=@trig me/vb
                         @vb mutex lock="Got it!;@notify me
                         @startup mutex lock=@notify me
            <timed wait> @wait timer/60 = "Sixty Second Timer.
 
  In the above examples you will say "Foo" after semaphore is notified,
  you will say "Got it" when you have the mutual exclusion lock mutex lock
  (You could have also modified object registers that need to be protected
  from concurrent update), and you will say "Sixty Second Timer." either when
  timer is notified or after sixty seconds pass.
 
  See also: @drain, @notify, @wait.

& SPOOFING
  Topic: SPOOFING
 
  Spoofing is the act of making other characters think that a person said or
  did something that they did not.  This is very easy to accomplish, and has
  some good effects, which is why it is allowed.  Note that the NOSPOOF flag
  allows players to see exactly who is spoofing what.
 
  Example:
    ... From TinyJerk's perspective ...
    > @emit Wizard is a jerk!
    Wizard is a jerk.
 
   ... From Wizard's perspective, Wizard is set NOSPOOF ...
   [TinyJerk(#226)] Wizard is a jerk!
   > @boot tinyjerk
   You booted TinyJerk off!
   TinyJerk has disconnected.
   1 connection closed.
 
   ... TinyJerk's perspective again ...
   Wizard gently shows you the door.
 
   *** Disconnected ***

& STACK
  Topic: STACK
 
  Command lists that are run on objects can have up to 10 stack values
  named %0 through %9 (or [v(0)] through [v(9)]).  Stack values can be set
  by the @trigger command, or by matching wildcard characters in the Listen
  attribute (in the case of the Ahear, Aahear, and Amhear attributes).
 
  Example:
    > @listen item = * foo *
    Set.
    > @ahear item = "-->[v(1)]<-- bar -->[v(0)]<--
    Set.
    > say Fee fie foo fum
    You say "Fee fie foo fum"
    item says "-->fum"<-- bar -->Wizard says "Fee fie<--"

& SUBSTITUTIONS
  Topic: SUBSTITUTIONS
 
  All messages may contain %-substitutions, which evaluate to gender-specific
  pronouns if the player's gender is set or to other useful information.
  Information returned is based on the player that caused the message to be
  displayed, not the object that stored the message or which is running the
  action list.
 
  Simple format substitutions:
 
    %r      = Carriage return / newline.
    %t      = Tab character.
    %b      = A single blank space.
    %%      = The literal '%' character.
    %\      = The literal '\' character.
 
  Continued in 'help Substitutions2'.
 
& Substitutions2
 
  Substitutions related to the enactor (the object which caused the
  action to be executed, or the message to be displayed):
 
    %#      = Enactor's dbref.
    %n, %N  = Enactor's name. Equiv: name(%#)
    %s, %S  = Subjective pronoun: he, she, it, they. Equiv: subj(%#)
    %o, %O  = Objective pronoun: him, her, it, them. Equiv: obj(%#)
    %p, %P  = Possessive pronoun: his, her, its, their. Equiv: poss(%#)
    %a, %A  = Absolute possessive pronoun: his, hers, its, theirs.
    %l      = Dbref of enactor's location. Equiv: loc(%#)
 
  For those substitutions that have either lower-case or upper-case
  forms, using the upper-case letter will capitalize the first letter
  of the result; i.e., '%S' returns 'He', 'She', 'It', or 'They'.
 
  Continued in 'help Substitutions3'.
 
& Substitutions3
 
  Other substitutions:
 
    %!       = Dbref of the object holding the message or running the
               action list ('me').
    %c       = Text of the last command executed.
    %0-%9    = Value of positional parameter/stack location 0 through 9.
    %q0-%q9  = Value of registers 0 through 9. Equiv: r(0) - r(9)
    %va-%vz  = Contents of attributes VA through VZ. Equiv: v(va) - v(vz)
    %=<var>  = The <angle brackets> are literal. Contents of an attribute.
               Equiv: v(<var>) (no <>), i.e., %=<test> is equivalent to
               v(test) or get(me/test)
    %_<var>  = Value of a variable set via setx(). Equiv: x(<var>)
               Normally, this is a single-letter variable name, but if
               the name is enclosed in angle brackets, multi-letter variable
               names can be used. '%_<foo>' is equivalent to 'x(foo)'.
    %x<code> = ANSI color substitution.
 
  Note: %<whatever> is equivalent to [v(<whatever>)], but is more efficient.
 
  See also: GENDER, V(), ANSI().
 
& SUCCESS
  Topic: SUCCESS
 
  You successfully use a player or a thing when you take it (because you
  passed the lock).  You successfully use an exit when you go through it.
  You successfully use a room when you look around and the room is not locked
  against you.
  See also: get, look, @asuccess, @lock, @osuccess, @success.

& SWITCHES
  Topic: SWITCHES
 
  Some commands have command switches associated with them that can be used
  to modify their behavior.  For instance, switches on the @ps command
  control the amount of information displayed, and switches on the @switch
  command indicate whether to perform all actionlists whose targets match
  the search string, or just the first.
  See also: @list.

& OBJECT TYPES
  Topic: OBJECT TYPES
 
  There are 4 types of objects: things, players, exits, and rooms. The first
  letter following an object's ID number indicates the type: P(layer),
  E(xit), R(oom), otherwise, thing.  Things are inanimate objects that can
  be carried.  Players are animate objects that can move and carry. Exits
  are the means by which objects move from room to room. Rooms are locations
  that contain objects and linked exits.

& COMMAND EVALUATION
  Topic: COMMAND EVALUATION
 
  When you submit a command to be executed by MUSH (whether by typing it in or
  by having a machine run it, the following steps are performed, in sequence.
  If the command matches something in a step, the matching actions are
  performed and the walk down the list stops.
 
  - If the command was typed in, it is checked against the uppercase-only
    commands (QUIT, WHO, etc).  If so, the command is executed.
 
  - The first letter of the command is checked to see if it is a single-
    character command (", :, etc).  If so, %-substitution and function
    evaluation may be performed (depending on the command), and the command
    is executed.
 
  - The command is checked to see if it is one of the player's channel
    aliases. If so, the comsys command is executed.
 
  - The command is checked to see if it is the 'home' command.  If so, the
    player or object performing the command goes home.
 
  Continued in 'help Command Evaluation2'.
 
& Command Evaluation2
 
  - The command is checked against the exits in its current room.  If one
    matches, the player is moved through the exit. If more than one exit
    matches, one is picked randomly from the exits for which the player
    passes the lock; if the player does not pass any locks, then the exit
    to be tried is picked randomly.
 
  - The command is checked against exits in the Master Room. Multiple
    exit matches are resolved as per above.
 
  - The first word of the command is checked to see if it is an internal
    built-in MUSH command, or something which has been @addcommand'd.
    If it is a built-in, the remainder of the command is broken up into
    arguments; %-substitution and function evaluation may be performed
    on the (split up) arguments; if an @addcommand, evaluation is not
    performed. The command is then executed.
 
  Continued in 'help Command Evaluation3'.
 
& Command Evaluation3
 
  - %-substitution and function evaluation is performed on the command.
    All subsequent attempts to match will be against this evaluated string.
 
  - The command is checked against leave aliases on the player's current
    location. If matched, the player leaves.
 
  - The command is checked against the enter aliases for objects in the
    player's current location. If matched, the player enters the object.
 
  - An attempt to match $commands is performed, in the following order:
    The player himself (if configuration permits), objects in the player's
    location, the player's location itself, and objects in the player's
    inventory. All that match are performed, unless a match was made
    on a STOP-set object (see 'help STOP').
 
  Continued in 'help Command Evaluation4'.
 
& Command Evaluation4
 
  - If local-master-room checking is enabled, and the ZONE flag is
    set on the parent room of the player's location, objects in that
    room are checked for $command matches. STOP applies as above.
 
  - If zones are enabled, and the ZMO of the player's location is a room,
    the command is checked against the exits of the ZMO. Multiple matches
    are resolved as per normal exit movement.
  
  - If zones are enabled, and the ZMO of the player's location is a room,
    objects in that room are checked for $command matches. STOP applies.
 
  - If zones are enabled, and the ZMO of the player's location is not a
    room, the ZMO itself is checked for $command matches. STOP applies.
 
  - If local-master-room checking is enabled, and the ZONE flag is set
    on the parent of the player, objects in that parent's location are
    checked for $command matches. STOP applies as above.
 
  Continued in 'help Command Evaluation5'.
 
& Command Evaluation5
 
  - If zones are enabled, the player's ZMO is checked for $command matches.
    STOP applies as above.
 
  - All objects in the master room are checked for $commmand matches.
    STOP applies as above.
 
  - The master room itself is checked for $command matches. STOP applies.
 
  Note: Commands that can cause other commands to be executed (such as @wait,
  @switch, @trigger, etc) never perform substitution on their arguments, they
  leave the evaluation to the command that is to be executed.  This prevents
  most of the problems with getting objects to perform unintended commands by
  putting a ';', '}', or ',' in an argument.  The @force command is an
  exception in that it evaluates its argument, so it should be used with
  caution (preferably by never using it to pass information that someone else
  entered, use @trigger instead).
 
  Also, the construct '$xx *:%0' does not work (and is very dangerous
  programming), use '$xx *:@force me=%0' if you need this functionality.
 
& VERBS
  Topic: VERBS
 
  For many verbs there are three attributes that specify messages and actions
  associated with the verb in addition to the verb's builtin action.
  The attributes are named Verb, Overb, and Averb.  Verb is the message that
  the enactor sees, Overb is the message that everyone else in the same room
  as the enactor sees, and Averb is a list of commands that are run.
  These attributes may be set using the @<attribute> command, so the commands
  to set the attributes related to the 'drop' command are @drop, @odrop, and
  @adrop.

& WIZARDS
  Topic: WIZARDS
 
  Wizards are the people that help run the game and make sure that everything
  is working properly.  They have special powers to tweak reality in ways
  mortals can only dream of.  Be nice to them, they are going out of their
  way to help keep the game running smoothly.

& Zones
 
  See 'help Zone' for the Zone flag and local master room information,
  and 'help Zone Objects' for multi-control objects using the CONTROL_OK
  flag and ControLock.
 
& Zone Objects
  ZONE OBJECTS
 
  Zones are areas of the MUSH which may be controlled by many people.
  Essentially, they allow group ownership of objects. The have_zones
  config parameter must be enabled.
  
  The default zone is NOTHING. Any building done by a player defaults
  to belonging to the same zone that the player belongs to.
  Every zone is defined by a Zone Master Object (ZMO). The ZMO is an
  ordinary MUSH object owned by some player. A wizard may change the
  zone of an object or player to a ZMO.
  
  If the ZMO is a room, it is called a "Parent room." Most of the
  statements about ZMOs also apply to parent rooms; for details,
  see the help topic PARENT ROOMS.
  
  Continued in 'help Zone Objects2'.
 
& Zone Objects2
 
  Anyone who can pass the Control lock of the ZMO has control over all
  objects in that zone that are set CONTROL_OK. This, in essence, gives
  that player wizard powers within that zone. For this reason, one must
  be extremely careful with the Control locks of ZMOs!
  
  Also, $commands on a ZMO are treated as global within that zone.
  The game attempts to match $commands for the ZMO of the player's
  location, as well as $commands for the player's own zone.
 
& V()
  Function: v(<string>)
 
  The V function can be used as an alternative for percent (%) substitution
  and also as a replacement for get(me/<arg>).  If the argument is two
  characters long or longer and starts with a letter, then the object
  performing the v() call (and its parent, if necessary) is searched for the
  named attribute, and its value is returned if possible.  Otherwise, a
  percent substitution is performed on the argument (so that v(o) is
  equivalent to %o, for instance).  The percent form (%o in the previous
  example) is preferred as it is faster, and there are no longer any security
  problems associated with it.  Note that attributes with single-character
  names cannot be retrieved with v().
 
  A percent-substitution is available for the equivalent of v()'s ability
  to retrieve an attribute: %=<var>, where the variable named <var> is
  literally enclosed within angle-brackets. For instance, v(test) is
  equivalent to %=<test> (and to get(me/test), as well).
 
  See also: GENDER, SUBSTITUTION, PARENT OBJECTS.
 
& wordpos()
  Function: wordpos(<string>, <charpos>[, <delim>)
 
  Returns the number of the word within <string> where the character position
  <charpos> falls.  Spaces between words are treated as belonging to the word
  that follows them.  If <charpos> is not within the string, the value #-1 is
  returned.  Both words and characters are numbered starting at 1.
 
  <delim> may be used to specify a delimiter other than a space.
 
  Example:
    > say wordpos(This is a test, 4)
    You say "1"
    > say wordpos(This is a test, 5)
    You say "2"
    > say wordpos(This is a test, 6)
    You say "2"
    > say wordpos(This is a test, 20)
    You say "#-1"

& type()
  Function: type(<object>)
  Returns a string indicating the object type of <object>, either EXIT,
  PLAYER, ROOM, or THING.
 
  Example:
    > say type(me)
    You say "PLAYER"
    > say type(here)
    You say "ROOM"

& hasflag()
  Function: hasflag(<object>[/<attribute>],<flag>)
 
  Returns true if object <object> has the flag named <flag> set on it.
  You may not be able to retrieve information for objects that you do not
  own.
 
  With an object-attribute pair, this can also be used to check for the
  attribute flags "dark", "hidden", "html", "visual", "no_command", 
  "no_inherit", "no_parse", "locked", "wizard", and "god".
  
  Example:
    > say hasflag(me, wizard)
    You say "0"
    > say hasflag(me, connect) 
    You say "1"

& ANDFLAGS()
  Function:  andflags(<object>,<list of flags>)
 
  This function returns 1 if <object> has all the flags in a specified list,
  and 0 if it does not. The list is specified with a single letter standing
  for each flag, like the output of the FLAGS() function. A '!' preceding
  a flag letter means "not flag".
 
  Thus, ANDFLAGS(me,WD) would return 1 if I was set WIZARD and DARK.
  ANDFLAGS(me,W!Dc) would return 1 if I was set WIZARD, not DARK, and
  CONNECTED.
 
  If a letter does not correspond to any flag, <object> doesn't have it,
  so the function returns 0. There can be an arbitrary number of flags.
  Do not put spaces between flag letters.
 
  See also:  hasflag(), orflags()

& ORFLAGS()
  Function: orflags(<object>,<list of flags>)
 
  This function returns 1 if <object> has at least one of the flags in a
  specified list, and 0 if it does not. The list is specified with a 
  single letter standing for each flag, like the output of the FLAGS()
  function. A '!' preceding a flag letter means "not flag".
 
  Thus, ORFLAGS(here,JA) would return 1 if my location is set JUMP_OK
  or ABODE. ORFLAGS(me,D!c) would return 1 if I am DARK or not CONNECTED.
 
  If a letter does not correspond to any flag, <object> doesn't have it,
  so it is simply ignored. There can be an arbitrary number of flags. Do
  not put spaces between flag letters.
 
  See also:  hasflag(), andflags()

& delete()
  Function: delete(<string>,<first>,<len>)
  Returns <string>, but with <len> characters starting after the character
  at position <first> removed.  In other words, this function copies <first>
  characters, skips <len> characters, and then copies the remainder of the 
  string.
 
  Example:
    > say delete(abcdefgh, 3, 2)
    You say "abcfgh"
    > say delete(Would you like coffee or perhaps tea?, 15, 18)
    You say "Would you like tea?"

& lock()
  Function: lock(<object>[/<whichlock>])
 
  Returns the named lock on <object>.  If you don't specify the lock to get,
  the default lock is returned.  You must control <object>.

& elock()
  Function: elock(<object>[/<whichlock>],<victim>)
 
  Checks if <victim> would pass the named lock on <object>. You must be
  nearby, or control, at least one of the objects.

& LWHO()
  Function: lwho()
  Returns a list of the db numbers of connected players.
 
  Example:
    > WHO
    Player Name          On For Idle  Doing
    Mortal                00:11   0s  
    Evinar                00:12   6m  
    Wizard                00:32   6s  
    3 Players logged in.
    > say lwho()
    You say "#226 #271 #1"
  See also: WHO, conn(), idle().

& OBJ()
  Function: obj(<object>)
 
  Returns the proper objective pronoun (him, her, it, them) for referring to
  <object>, based on the object's Sex attribute.  You must either control
  or be near <object>.

& POSS()
  Function: poss(<object>)
 
  Returns the proper possessive pronoun (his, her, its, their) for referring
  to <object>, based on the object's Sex attribute.  You must either control
  or be near <object>.

& APOSS()
  Function: aposs(<object>)
 
  Returns the proper absolute possessive pronoun (his, hers, its, theirs) for
  referring to <object>, based on the object's Sex attribute.  You must either
  control or be near <object>.

& SUBJ()
  Function: subj(<object>)
 
  Returns the proper subjective pronoun (he, she, it, they) for referring to
  <object>, based on the object's Sex attribute.  You must either control
  or be near <object>.

& NEARBY()
  Function: nearby(obj1,obj2)
 
  Tests if obj1 is near obj2 (if it is in the same location, in obj2's
  inventory, or is obj2's location).  You must control either obj1 or obj2, or
  be near either one of them, if both of these tests fail then 0 is returned.
  This function returns 1 if the two objects are nearby and 0 if not.

& GET()
  Function: get(<object>/<attribute>)
 
  The get function fetches the specified attribute from the named object.
  It can be used to get attributes from objects you own, public and visual
  attributes of objects near you, and public and visual attributes other
  than the description of players wherever they may be.  If the attribute is
  not present on <object>, its parent is searched for the attribute.
 
  A percent-substitution equivalent to 'get(me/<attribute>)' is available.
  This is '%=<attribute>', where the name of the attribute is literally
  enclosed in angle brackets. For instance, 'get(me/test)' is equivalent
  to '%=<test>', and to 'v(test)'.
 
  Example:
    > read me
    > say get(me/desc)
 
  See also: get_eval().
 
& GET_EVAL()
  Function: get_eval(<object>/<attribute>)
 
  The get_eval function returns the specified attribute from the named object
  (just like the get function), except that function references and
  %-substitutions have already been performed.  In function references, 
  'me' refers to the object being looked at, and %-substitutions that refer
  to the enactor (such as %n, %#, etc) refer to the object making the get_eval
  call.  If the attribute is not present on <object>, its parent is searched
  for the attribute.
 
  Example:
    > @va test = This is a get_eval test on %n.  The vb is [get(me/vb)]
    > @vb test = VB from test
    > @vb me = VB from me
    > say get(test/va)
    You say "This is a get_eval test on %n. The vb is [get(me/vb)]"
    > say get_eval(test/va)
    You say "This is a get_eval test on Foobar. The vb is VB from test"
  See also: get().

& DEFAULT()
  Function:  default(<obj>/<attr>,<default case>)
 
  This function returns the value of <obj>/<attr>, as if retrieved via
  the get() function, if the attribute exists and is readable by you.
  Otherwise, it evaluates the default case, and returns that.
  Note that the default case is only evaluated if the attribute does
  not exist or cannot be read.
 
  This is useful for code that needs to return the value of an attribute,
  or an error message or default case, if that attribute does not exist.
 
  Examples:
    > &TEST me=apple orange banana
    > say default(me/Test, No fruits!)
    You say "apple orange banana"
    > &TEST ME
    > say default(me/Test, No fruits!)
    You say "No fruits!"
 
  See also:  get(), get_eval(), u(), edefault(), udefault().
 
& EDEFAULT()
  Function:  edefault(<obj>/<attr>,<default case>)
 
  This function returns the evaluated value of <obj>/<attr>, as if
  retrieved via the get_eval() function, if the attribute exists and
  is readable by you. Otherwise, it evaluates the default case, and
  returns that. The default case is only evaluated if the attribute
  does not exist or cannot be read.
 
  Example:
    > &TEST me=You have lost [rand(10)] marbles.
    > say edefault(me/Test,You have no marbles.)
    You say "You have lost 6 marbles."
    > &TEST me
    > say edefault(me/Test,You have no marbles.)
    You say "You have no marbles."
  
  See also:  get(), get_eval(), u(), default(), udefault().
 
& UDEFAULT()
  Function:  udefault([<obj>/]<attr>,<default case>[,<arg>]...)
 
  This function returns the value of the user-defined function
  as defined by <attr> (or <obj>/<attr>), as if retrieved via
  the u() function, with <args>, if the attribute exists and is
  readable by you.
 
  Otherwise, it evaluates the default case, and returns that. The
  default case is only evaluated if the attribute does not exist
  or cannot be read.
 
  Examples:
    > &TEST me=[center(%0,5,*)]
    > say udefault(Test,-- BOOM --,ACK)
    You say "*ACK*"
    > &TEST me
    > say udefault(me/Test,-- BOOM --,ACK)
    You say "-- BOOM --"
 
  See also:  get(), get_eval(), u(), default(), edefault().

& TIME()
  Function: time()
 
  Gives you the current time.
  WARNING!  This is the time on the machine that the mud is running on, and
  not where you are.
 
  Example:
    > say time()
    You say "Thu Dec 19 09:48:06 1991"
  See also: convsecs(), convtime(), secs().

& RAND()
  Function: rand(<num>)
 
  Rand returns an integer between 0 and num-1.
 
  Example:
    > say rand(10)
    You say "6"
    > say rand(10)
    You say "1"
    > say rand(10)
    You say "4"
    > say rand(10)
    You say "9"
    > say rand(10)
    You say "1"

& DIE()
  Function: die(<number of times to roll die>, <number of sides on die>)
 
  This function simulates rolling dice. It "rolls" a die with a given
  number of sides, a certain number of times, and sums the results.
  For example, 'die(2,6)' would roll "2d6" -- two six-sided dice,
  generating a result in the range 2-12.
 
& EXIT()
  Function: exit(<object>)
 
  Exit returns the first exit on the list of exits in the object.  Dark exits
  are not listed, unless you own the object.  Unlike LEXITS(), this function
  does not provide information about exits in parent objects.
 
  See also: con(), lcon(), lexits(), next().

& ABS()
  Function: abs(<number>)
 
  Returns the absolute value of its argument.
  <number> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say abs(4)
    You say "4"
    > say abs(-4)
    You say "4"
    > say abs(0)
    You say "0"

& MAX()
  Function: max(<number1>,<number2>[,<numberN]...)
 
  Returns the largest integer from among its arguments.
  Up to 30 arguments may be specified.
  <numberN> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say max(2,4)
    You say "4"
    > say max(-100,50,0,25)
    You say "50"
 
  See also: min(), lmax()

& MIN()
  Function: min(<number1>,<number2>[,<numberN]...)
 
  Returns the smallest integer from among its arguments.
  Up to 30 arguments may be specified.
  <numberN> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say min(2,4)
    You say "2"
    > say min(-100,50,0,25)
    You say "-10"
 
  See also: max(), lmin()

& ADD()
  Function: add(<number1>,<number2>[,<numberN>]...)
 
  Returns the result of adding its arguments together.
  You may add up to 30 numbers in one add() call.
  <numberN> may be a floating point number, and a floating point result
  is returned.
 
  Example:
    > say add(2,4)
    You say "6"
    > say add(5,3,7,-4)
    You say "11"
 
  See also: ladd(), div(), mod(), mul(), sub().
 
& SUB()
  Function: sub(<number1>,<number2>)
 
  Returns the result of subtracting <number2> from <number1>.
  The numbers may be floating point numbers, and a floating point result
  is returned.
 
  Example:
    > say sub(5,2)
    You say "3"
  See also: add(), div(), mod(), mul().

& MUL()
  Function: mul(<number1>,<number2>[,<numberN>]...)
 
  Returns the result of multiplying its arguments together.
  <numberN> may be a floating point number, and a floating point result
  is returned.
 
  Example:
    > say mul(3,5)
    You say "15"
    > say mul(3,5,-2)
    You say "-30"
  See also: add(), div(), fdiv(), mod() round(), sub(), trunc().

& DIV()
  Function: div(<number1>,<number2>)
 
  Returns the integer quotient from dividing <number1> by <number2>.
  <numberN> may be a floating point number, and an integer result is returned.
 
  Example:
    > say div(15,3)
    You say "5"
    > say div(16,3)
    You say "5"
    > say div(17,3)
    You say "5"
    > say div(18,3)
    You say "6"
    > say div(-17,3)
    You say "-5"
  This function may also be called as idiv().
  See also: add(), fdiv(), mod(), mul(), round(), sub(), trunc().

& FDIV()
  Function: fdiv(<number1>,<number2>)
 
  Returns the floating point quotient from dividing <number1> by <number2>.
  <number> may be a floating point number, and a floating point result is
  returned.
 
  Results:
    > say fdiv(15,3)
    You say "5"
    > say fdiv(16,3)
    You say "5.333333"
    > say fdiv(17,3)
    You say "5.666667"
    > say fdiv(18,3)
    You say "6"
    > say fdiv(-17,3)
    You say "-5.666667"
    > say fdiv(10,3.5)
    You say "2.857143"
  See also:   See also: add(), div(), mod(), mul(), round(), sub(), trunc().
 
& MOD()
  Function: mod(<integer1>,<integer2>)
 
  Returns the integer remainder from dividing <integer1> by <integer2>.
 
  Example:
    > say mod(15,3)
    You say "0"
    > say mod(16,3)
    You say "1"
    > say mod(17,3)
    You say "2"
    > say mod(18,3)
    You say "0"
    > say mod(-17,3)
    You say "-2"
 
  See also: add(), fdiv(),div(), mul(), round(), sub(), trunc().

& DIST2D()
  Function: dist2d(x1, y1, x2, y2)
 
  Returns the integer distance between the Cartesian points in two dimensions
  (x1,y1) and (x2,y2).
 
  Example:
    > say dist2d(0,0,3,4)
    You say "5"
 
  See also: dist3d()

& DIST3D()
  Function: dist3d(x1, y1, z1, x2, y2, z2)
 
  Returns the integer distance between the Cartesian points in three
  dimensions (x1,y1,z1) and (x2,y2,z2).
 
  Example:
    > say dist3d(0,0,0,10,15,20)
    You say "27"
 
  See also: dist2d()

& VADD()
  vadd(<vector>,<vector>[,<delim>][,<output delim>])
 
  Returns the sum of two vectors. A vector is a list of numbers
  separated by spaces or a delimiter, and may have any number of
  dimensions.
 
  Examples:
    > @pemit me=vadd(1 2 3,4 5 6)
      5 7 9
    > @pemit me=vadd(0|0|0,1|2|3,|,-)
      1-2-3
 
& VDIM()
  vdim(<vector>[,<delim>])
 
  Returns the dimensions of a vector.
 
  Example:
    > @pemit me=vdim(1 2 3 4)
      4
 
& VDOT()
  vdot(<vector>,<vector>[,<delim>][,<output delim>])
 
  Returns the dot product of two vectors. The dot product of two
  vectors is a scalar. (a,b,c) * (x,y,z) = aw + bx + cz
 
  Example:
    > @pemit me=vdot(1 2 3,2 3 4)
      20
 
& VMAG()
  vmag(<vector>[,<delim>]
 
  Returns the magnitude of a vector, using a euclidean distance metric.
  That is, for vector a b c d, returns sqrt(a^2+b^2+c^2+d^2).
  
  Example:
    > @pemit me=vmag(3 4) 
    5
 
& VMUL()
  vmul(<vector|number>,<vector|number>[,<delim>][,<output delim>])
 
  Returns the result of either multiplying a vector by a number (scalar
  multiplication), or an elementwise multiplication of two vectors.
 
  Examples:
    > @pemit me=vmul(1 2 3,2)
      2 4 6
    > @pemit me=vmul(1 2 3,2 3 4)
      2 6 12
 
& VSUB()
  vsub(<vector>,<vector>[,<delim>][,<output delim>])
 
  Returns the difference between two vectors.
 
  Example:
    > @pemit me=vsub(3 4 5,3 2 1)
      0 2 4
    > @pemit me=vsub(6-4-2,5-2-0,-)
      1-2-2
 
& VUNIT()
  vunit(<vector>[,<delim>][,<output delim>])
 
  Returns the unit vector (a vector of magnitude 1), which points
  in the same direction as the given vector.
 
  Examples:
    > @pemit me=vunit(2 0 0)
      1 0 0
    > @pemit me=vmul(vunit(5 6 7),vmag(5 6 7))
      5 6 7

& INC()
  Function: inc(<number>)
 
  Returns <number>, incremented by 1 (the <number>, plus 1). It is
  equivalent to add(<number>, 1) but is faster and more efficient.
  Decimal places will be truncated.
 
  See also: dec(), add(), sub(). 

& DEC()
  Function: dec(<number>)
 
  Returns <number>, decremented by 1 (the <number>, minus 1). It is
  equivalent to sub(<number>, 1) but is faster and more efficient.
  Decimal places will be truncated.
 
  See also: inc(), add(), sub(). 

& LADD()
  Function:  ladd(<list of numbers>[,<delim>])
 
  Adds a list of numbers together.
 
  Examples:
    > say [ladd(1 3 5 -1)]
    You say, "8"
    > say [ladd(1:2:3,:)]
    You say, "6" 
 
  See also: add().
 
& LMIN()
  Function:  lmin(<list of numbers>[,<delim>])
 
  Obtains the smallest number out of a list of numbers (i.e., the minimum).
 
  Example:
    > say [lmin(3, 1.1, 5)]
    You say "1.1"
 
  See also: min().
 
& LMAX()
  Function:  lmax(<list of numbers>[,<delim>])
 
  Obtains the largest number out of a list of numbers (i.e., the minimum).
 
  Example:
    > say [lmax(3.2, 1 , 5)]
    You say "5"
 
  See also: max().
 
& LAND()
  Function:  land(<list of strings>[,<delim>])
 
  Takes a list of strings, and returns 1 if all words in the string are
  non-zero numbers, and 0 otherwise.
 
  Example:
    > say [land(1 3 x 5)]
    You say "0"
    > say [land(2 -1 4)]
    You say "1"
 
  See also: and().
 
& LANDBOOL()
  Function:  landbool(<list of strings>[,<delim>])
 
  Takes a list of strings, and returns 1 if all the words in the string
  have a boolean true value, and 0 otherwise.
 
  Example:
    > say [landbool(1 x #2)]
    You say "1"
    > say [landbool(1 x 0)]
    You say "0"
 
  See also: andbool(). 
 
& LOR()
  Function:  lor(<list of strings>[,<delim>])
 
  Takes a list of strings, and returns 1 if at least one of the words in
  the string is a non-zero number, and 0 otherwise.
 
  Example:
    > say [lor(1 x 5)]
    You say "1"
    > say [lor(x 0 #2)]
    You say "0"
 
  See also: or().
 
& LORBOOL()
  Function:  lorbool(<list of strings>[,<delim>])
 
  Takes a list of strings, and returns 1 if at least one of the words in
  the string has a boolean true value, and 0 otherwise.
 
  Example:
    > say [lorbool(0 x #2)]
    You say "1"
 
  See also: orbool(). 
 
& FIRST()
  Function: first(<string>[, <delim>])
 
  Returns the first word of a string, that is, everything to the left
  of the first space in the string, or the entire string if there are
  no spaces in the string.

  <delim> may be used to specify a word delimiter other than a space.
 
  Example:
    > say first(This is a test)
    You say "This"
    > say first(Would you like coffee, or perhaps tea)
    You say "Would"
    > say first(List&with&nonstandard&delimiters,&)
    You say "List"
  See also: rest(), last().

& REST()
  Function: rest(<string>[, <delim>])
 
  The rest function takes a string, returns all the string except the first
  word, that is, everything to the right of the first space, or an empty 
  string, or the empty string if there are no spaces in the string.  
 
  <delim> may be used to specify a word delimiter other than a space.
 
  Example:
    > say rest(This is a test) 
    You say "is a test"
    > say rest(Would you like coffee, or perhaps tea) 
    You say "you like coffee, or perhaps tea"
    > say rest(List!with!different!delimiters,!)
    You say "with!different!delimiters"
 
  See also: first(), last().

& LAST()
  Function: last(<string>[, <delim>])
 
  Returns the last word of a string, that is, everything to the right
  of the last space in the string, or the entire string if there are no 
  spaces in the string.
 
  <delim> may be used to specify a word delimiter other than a space.
 
  Example:
    > say last(This is a test)
    You say "test"
    > say last(Happy-Fun-Test-Thing,-)
    You say "Thing"
 
  See also:  first(), rest().

& LASTCREATE()
  Function: lastcreate(<object>, <type>)

  Returns the dbref of the last object of <type> that was created by
  <object>. You must control <object>.
 
  In general: If <type> is 'R', it will be the dbref of the object's most
  recent @dig. If it is 'E', it will be the dbref of the object's most 
  recent @open. If it is 'T', it will be the dbref of the object's most
  recent @create. If it is 'P', it will be the dbref of the object's
  most recent @pcreate.
 
  Note that @clone will set the 'most recent' in accordance with the
  type of the object being cloned.

& OBJMEM()
  Function: objmem(<object>[/<attribute pattern>])
 
  If no attribute pattern is specified, this returns the number of bytes
  of memory consumed by an object, including both attribute text and
  object overhead.
 
  If an attribute wildcard pattern is specified, this returns the number
  of bytes of memory consumed by attribute text for those attributes on
  <object>. To just get a count of the number of bytes used by all
  attribute text on an object, use 'objmem(<object>/*)'. You must be
  able to read an attribute in order to check its size.
 
& STRLEN()
  Function: strlen(<string>)
 
  Returns the number of characters in <string>.
 
  Example:
    > say strlen(This is a test)
    You say "14"
    > say strlen(Would you like coffee, or perhaps tea)
    You say "37"

& MID()
  mid(<string>, <first>, <length>)
 
  Mid returns a segment of the string, the <length> characters to the
  right of the <first> character.  Note that the first character in a
  string is numbered zero, and not one.

& COMP()
  comp(<string1>, <string2>)
 
  Comp compares two strings.  It returns 0 if they are the same, 1 if
  string2 is less than/precedes alphabetically string1, and -1 
  otherwise.
& S()
  s(string)
 
  This function performs pronoun substitution in a string, and then returns
  that string.  As usually, %n is the name, %s the subjective pronoun, %o the
  objective, %p the possessive, and %a the absolute possessive.  It is
  important to note that the pronoun is that of the triggering object.
 
  So, if the ve of an object were: "[s(This is %n)], and I were to 
  type @trigger <object>/ve, it would return "This is <myname>", but 
  if vf were @trigger me/ve, then triggering the vf makes the ve 
  return "This is <object>"

& LEFT()
  Function: left(<string>, <number>)
 
  This function returns the first <number> characters from the left-hand
  side of <string>.
 
  Example:
    > say left(flipper,3)
    You say "fli"
 
  See also: right(), mid()

& RIGHT()
  Function: right(<string>, <number>)
 
  This function returns the last <number> characters from the right-hand
  side of <string>.
 
  Example:
    > say right(foobarbaz,4)
    You say "rbaz"
 
  See also: left(), mid()

& LPOS()
  Function: lpos(<string>, <character>)
 
  This function returns a list of the positions that <character> occupies
  in <string>, with the first character of the string being 0. (Note that
  this differs from the pos() function, but it consistent with functions
  such as mid().)
 
  If <character> is null, a space is assumed.
 
  Example:
    > say lpos(a-bc-def-g,-)
    You say "1 4 8"
 
& POS()
  pos(<string1>,<string2>)
 
  This function returns the position that string1 begins in string2,
  with the first position being 1.
  If string1 is not in string2, then it returns #-1.
 
  Example: pos(man,superman) returns 6
& MATCH()
  Function: match(<string>, <pattern>[, <delim>])
 
  This function matches <pattern> against each word of <string>, returning
  the number of the first word that matches.  If no words match then 0 is
  returned.  The case of the characters being matched is not significant.
 
  The pattern may contain the wildcards '*' and '?'.  '?' matches any one
  character, while '*' matches any number of characters, including none.
  So 's?x' would match 'sex' or 'six', but not to 'socx', but 's*x' would
  match any of them.

  <delim> may be used specified to specify a delimiter other than a space.

  Examples:
    > say match(This is a test, test)
    You say "4"
    > say match(This is a test, is)
    You say "2"
    > say match(This is a test, *is*)
    You say "1"
    > say match(This is a test, *not*)
    You say "0"
    > say match(This is a test, is a)
    You say "0"
  See also: LISTS, member(), matchall(), strmatch().

& MATCHALL()
  Function: matchall(<string>,<pattern>[,<delim>][,<output delim>])
 
  This function works identically to the match() function, save that it
  returns all matches, not just the first: It returns the index numbers of
  all words in the list <string> which match <pattern>. If none match, an
  empty string is returned.
 
  The output delimiter for this function works differently than other list
  functions -- if not specified, it defaults to a space, NOT to the input
  delimiter.
 
  Examples:
    > say matchall(This is a test of a test,test)
    You say "4 7"
    > say matchall(apples|bananas|oranges|pears,*a*e*,|)
    You say "1 3"
     > say matchall(apples bananas oranges pears,*a*e*, ,+)
    You say "1+3"
 
  See also: LISTS, match(), strmatch(). 
& STRMATCH()
  Function: strmatch(<string>,<pattern>)
 
  This function matches <pattern> against the entire <string>, returning 1
  if it matches and 0 if it does not.  The case of the characters being
  matched is not significant.
 
  The pattern may contain the wildcards '*' and '?'.  '?' matches any one
  character, while '*' matches any number of characters, including none.
  So 's?x' would match 'sex' or 'six', but not to 'socx', but 's*x' would
  match any of them.
 
  Examples:
    > say strmatch(This is a test,*Test)
    You say "1"
    > say strmatch(This is a test,*This)
    You say "0"
    > say strmatch(This is a test,*is*is*)
    You say "1"
 
  See also: match(), member(), regmatch().

& REGMATCH()
  regmatch(<string>,<regexp>[,<register list>])
 
  This function matches the regular expression <regexp> against the
  entirety of <string>, returning 1 if it matches and 0 if it does not.
 
  If <register list> is specified, there is a side-effect: any
  parenthesized substrings within the regular expression will be set
  into the specified local registers, in the order they were specified
  in the list. <register list> can be a list of one through nine numbers.
  If the specified register is -1, the substring is not copied into a
  register.
 
  For example, if <string> is 'cookies=30', and <regexp> is '(.+)=([0-9]*)'
  (parsed; note that escaping may be necessary), then the 0th substring
  matched is 'cookies=30', the 1st substring is 'cookies', and the 2nd
  substring is '30'. If <register list> is '0 3 5', then %q0 will become
  "cookies=30", %q3 will become "cookies", and %q5 will become "30".
  If <register list> was '0 -1 5', then the "cookies" substring would
  simply be discarded.
 
  See 'help regexp syntax' for an explanation of regular expressions.
 
& REGPARSE()
  regparse(<string>,<regexp>,<list of variable names>)
 
  This side-effect function matches the regular expression <regexp>
  against the entirety of <string>; if there's a match, it places
  the parenthesized substrings within the regular expression, into
  the corresponding named variables. <list of variable names> can be
  up to ten strings.
 
  For example, if <string> is 'cookies=30' and <regexp> is '(.+)=([0-9]*)'
  and <list> is 'x y z', the the 0th substring matched is 'cookies=30'
  (which is set into the named variable 'x'), the 1st substring is
  'cookies' (set into 'y'), and the 2nd substring is '30' (set into 'z').
 
  See 'help regexp syntax' for an explanation of regular expressions.
 
& STREQ()
  streq(<string 1>,<string 2>)
 
  This function returns 1 if <string 1> and <string 2> are the same
  (case-insensitive), and 0 if they are not. Whitespace is ignored.
 
  Examples:
    > say streq(This Is A Test,this is a test)
    You say "1"
    > say streq(testing,test)
    You say "0"
 
  See also: strmatch(), comp().
 
& ELEMENTS()
  elements(<list of words>,<list of numbers>[,<delim>][,<output delim>])
 
  This function returns the words in <list of words> that are in the
  positions specified by <list of numbers>. Optionally, a list delimiter
  other than a space can be specified, for both input and output.
 
  Examples:
    > say elements(Foo Ack Beep Moo Zot,2 4)
    You say "Ack Moo"
    > say elements(Foof|Ack|Beep|Moo,3 1,|)
    You say "Beep|Foof"
    > say elements(Foof|Ack|Beep|Moo,3 1,|,-)
    You say "Beep-Foof"

& EXTRACT()
  extract(<string>, <first>, <length>[, <delim>])
 
  Extract returns a string of length words, starting with the first 
  word. Unlike letters, the first word in a string is number 1, 
  instead of 0.
 
  <delim> may be used to specify a delimiter other than a space.

  Examples:
    > say extract(This is a really neat example, 4, 2)
    You say "really neat"
    > say extract(Another@funky@test@for@extract, 3, 3)
    You say "test@for@extract" 
  See also: index(), insert(), ldelete(), replace().

& INDEX()
  Function: index(<list>,<character>,<first>,<length>)
  
  This function is similar to EXTRACT(), except that an item in the
  list may be more than one word; instead of a space being used to
  separate items in the list, <character> is used. The function returns 
  <length> items starting from that in the <first> position. Trailing
  spaces are trimmed. The comma cannot be used as the <character> separator. 
 
  Example:
    > say [index(Cup of Tea | Mug of Beer | Glass of Wine, |, 2, 1)]
    You say, "Mug of Beer"
  See also: extract().

& GRAB()
  Function:  grab(<list>, <pattern>[, <delim>])
  
  This function matches <pattern> against each word in <list>, returning
  the first word that matches. If no words match, then an empty string
  is returned. The match is not case-sensitive, and wildcard characters
  are permitted. <delim> may be used to specify a list delimiter other
  than a space.
 
  Examples:
    > say grab(This is a new test,?e*)
    You say "new"
    > say grab(Holodeck:#10~Airlock:#58~Dorm:#12~Brig:#83,Airlock:*,~)
    You say "Airlock:#58"
 
  See also: LISTS, match().
 
& FLAGS()
  flags(<object>)
 
  Flags returns a string consisting of the flags attached to the 
  object. The string is, however, just one word.  Note that @switch
  is case-INsensitive.  i.e. p=P as far as it is concerned.  I wish
  that P=NP....
& NUM()
  num(<object>)
 
  Returns the dbref number of the object, which must be in the same 
  room as the object executing num.
  See also: locate().
& CON()
  con(<object>)
 
  Con returns the first object in the list of objects carried by 
  thing. Just the first, and only the first.  See NEXT.
& LOC()
  Function: loc(<object>)
 
  Returns the number of the location where <object> is.  You must either
  control the object or be nearby for it to work.  When used on an exit it
  returns the destination of the exit.  You can also use loc() to find the
  location of players that are not set UNFINDABLE.
 
  Example:
    > look
    Mortal's Room(#367R)
    A bare room with nothing in it but a bed and a chair.
    Contents:
    hat(#368)
    > say loc(me)
    You say "#367"
    > enter hat
    hat(#368)
    Contents:
    cat(#325)
    > say loc(me)
    You say "#368"
    > say loc(here)
    You say "#367"
  See also: rloc(), room(), where().

& RLOC()
  Function: rloc(<object>,<levels>)
 
  This function may be used to get the location of an object's location
  (for which you would previously use 'loc(loc(<object>))', which fails if you
  don't control <object>'s location).  <levels> indicates the number of
  nested 'loc' calls to make, so 'loc(loc(<object>))' could be replaced with
  'rloc(<object>,2)'.  If rloc() encounters a room, the dbref of the room
  is returned.
 
  You must either control the object or be nearby for it to work.  When used
  on an exit it returns the destination of the exit.  You can also use rloc()
  to find the location of players that are not set UNFINDABLE.
 
  rloc(<object>,0) is the same as num(<object>), and rloc(<object>,1) is the
  same as loc(<object>).
 
  See also: loc(), where().

& WHERE()
  Function: where(<object>)
 
  This function returns the "true" location of an object. You must control
  the object or be near it in order for it to work. For players and things,
  the "true" location is the normal location of the object. For exits, the
  "true" location is the source room. For rooms, it is #-1.
  See also: loc(), rloc().

& OWNER()
  Function: owner(<object>)
            owner(<object>/<attrib>)
 
  The first form of the owner() function returns the dbref of the owner of the
  object.  The object must either be yours or nearby.
 
  The second form returns the owner of an attribute on the named object.
  You must own either the object or the attribute.

& NAME()
  name(<dbref>)
 
  This function returns the name of the indicated object.  When called with
  an exit it returns the only the first alias.

  See also: fullname().

& FULLNAME()
  Function: fullname(<dbref>)
  
  This function returns the full name of the indicated object.  This is the
  same as name() in all cases except when <dbref> is an exit, then all the
  aliases are returned as well.
 
  See also: name().

& NEXT()
  next(<thing>)
 
  If thing is an exit in a room, then next will return the next 
  nondark exit in the list of exits for that room.  If thing is an 
  object, then next will return the next object in the inventory list 
  that the object is in.  Otherwise, it returns a '#-1' string.

& SHL()
  shl(<number>, <count>)
 
  This function returns the result of leftwards bit-shifting
  <number> by <count> times.
 
  This is equivalent to mul(<number>, power(2, <count>)), but is
  faster.
 
  Example:
    > say [shl(16, 2)]
    You say "64"
 
  See also: shr(), band(), bnand(), bor().
 
& SHR()
  shr(<number>, <count>)
 
  This function returns the result of rightwards bit-shifting
  <number> by <count> times.
 
  This is equivalent to div(<number>, power(2, <count>)), but is
  faster.
 
  Example:
    > say [shr(16, 2)]
    You say "4"
 
  See also: shl(), band(), bnand(), bor().
 
& BAND()
  band(<number>, <number>)
 
  Intended for use on a bitfield, this function performs a binary AND
  between two numbers.
 
  For example, the number 80 is equivalent to the binary representation
  (divided into groups of four numbers, for easier reading), 0010 1000.
  The bits for "16" and "64" are "on", but no other bits are on.
 
  This function is most useful for checking if a bit in a given bitfield
  is "on".  If it is, the function returns the value of that bit;
  [band(80,16)] or [band(80,64)] would return true values (16 or 64,
  respectively), while [band(80,32)] would return zero, a false value.
 
  See also: shl(), shr(), bnand(), bor().
 
& BNAND()
  band(<number>, <number>)
 
  Intended for use on a bitfield, this function performs a binary AND
  between a number and the complement of another number. This function
  is most useful for turning off bits in a bitfield.
 
  See also: shl(), shr(), band(), bor().
 
& BOR()
  bor(<number>, <number>)
 
  Intended for use on a bitfield, this function performs a binary OR
  between two numbers. It is most useful for "turning on" bits in a
  bitfield.
 
  See also: shl(), shr(), band(), bnand().
 
& ANDBOOL()
  Function: andbool(<boolean1>,<boolean2>[,<booleanN>]...)
 
  Takes two or more booleans, and returns 1 if they are all each equivalent
  to true(1).
 
  This function stops evaluating cases as soon as something is false.
 
  See also: BOOLEAN VALUES, t(), orbool(), notbool(), xorbool(), and().
& ORBOOL()
  Function: orbool(<boolean1>,<boolean2>[,<booleanN>]...)
 
  Takes two or more booleans, and returns 1 if at least one is equivalent
  to true(1).
 
  This function stops evaluating cases as soon as something is true.
 
  See also: BOOLEAN VALUES, t(), andbool(), notbool(), xorbool(), or().
& T()
  Function: t(<boolean>)
 
  Takes a boolean value, and returns 0 if it is false, and 1 if it is
  true.
 
  See also: BOOLEAN VALUES, notbool(), andbool(), orbool(), xorbool().
& NOTBOOL()
  Function: notbool(<boolean>)
 
  Takes a boolean value, and returns its inverse.  So, if the input is
  equivalent to true(1) it returns a 0, and if the input is equivalent to
  false(0), it returns a 1.
 
  See also: BOOLEAN VALUES, t(), andbool(), orbool(), xorbool(), not().
& XORBOOL()
  Function: xorbool(<boolean1>,<boolean2>[,<booleanN>]...)
 
  Takes two or more booleans, and returns 1 if an odd number of them are
  equivalent to true(1).
 
  See also: BOOLEAN VALUES, t(), andbool(), norbool(), orbool(), xor().
& AND()
  Function: and(<number1>,<number2>[,<numberN>]...)
 
  Takes two or more strings, and returns 1 if they are all non-zero
  numbers.
 
  This function stops evaluating as soon as something is false.
 
  See also: land(), andbool(), or(), xor(), not()
 
& OR()
  Function: or(<number1>,<number2>[,<numberN>]...)
  
  Takes two or more strings, and returns 1 if at least one is a non-zero
  number.
 
  This function stops evaluating as soon as something is true.
 
  See also: lor(), orbool(), and(), xor(), not()
 
& NOT()
  Function: not(<number>)
 
  If the input is a non-zero number, returns 0. If it is 0 or the
  equivalent (such as a non-numeric string), returns 1.
 
  See also: notbool(), and(), or(), xor()
& XOR()
  Function: xor(<number1>,<number2>[,<numberN>]...)
 
  Takes two or more strings, and returns 1 if an odd number of them
  are non-zero numbers.
 
  See also: xorbool(), and(), or(), not()
& gt()
  Function: gt(<number1>,<number2>)
 
  Takes two numbers, and returns 1 if and only if <number1> is greater than
  <number2>, and 0 otherwise.  Warning: passing anything but numbers will
  produce unexpected results, as non-numeric strings usually are treated
  as numeric 0.
 
  Example:
    > say gt(4,5)
    You say "0"
    > say gt(5,5)
    You say "0"
    > say gt(6,5)
    You say "1"
    > say gt(foo, bar)
    You say "0"
  See also: lt(), lte(), gte(), eq(), neq(), ncomp(), comp().

& gte()
  Function: gte(<number1>,<number2>)
 
  Takes two numbers, and returns 1 if and only if <number1> is greater than
  or equal to <number2>, and 0 otherwise.  Warning: passing anything but
  numbers will produce unexpected results, as non-numeric strings usually are
  treated as numeric 0.
 
  Example:
    > say gte(4,5)
    You say "0"
    > say gte(5,5)
    You say "1"
    > say gte(6,5)
    You say "1"
    > say gte(foo, bar)
    You say "1"
  See also: lt(), lte(), gt(), eq(), neq(), ncomp(), comp().

& lt()
  Function: lt(<number1>,<number2>)
 
  Takes two numbers, and returns 1 if and only if <number1> is less than
  <number2>, and 0 otherwise.  Warning: passing anything but numbers will
  produce unexpected results, as non-numeric strings usually are treated
  as numeric 0.
 
  Example:
    > say lt(4,5)
    You say "1"
    > say lt(5,5)
    You say "0"
    > say lt(6,5)
    You say "0"
    > say lt(foo, bar)
    You say "0"
  See also: lte(), gte(), gt(), eq(), neq(), ncomp(), comp().

& lte()
  Function: lte(<number1>,<number2>)
 
  Takes two numbers, and returns 1 if and only if <number1> is less than or
  equal to <number2>, and 0 otherwise.  Warning: passing anything but numbers
  will produce unexpected results, as non-numeric strings usually are treated
  as numeric 0.
 
  Example:
    > say lte(4,5)
    You say "1"
    > say lte(5,5)
    You say "1"
    > say lte(6,5)
    You say "0"
    > say lte(foo, bar)
    You say "1"
  See also: lt(), gte(), gt(), eq(), neq(), ncomp(), comp().

& eq()
  Function: eq(<number1>,<number2>)
 
  Takes two numbers, and returns 1 if they are equal and 0 if they are not.
  Warning: passing anything but numbers will produce unexpected results,
  as non-numeric strings usually are treated as numeric 0.
 
  Example:
    > say eq(1,-1)
    You say "0"
    > say eq(5,5)
    You say "1"
    > say eq(foo, bar)
    You say "1"
  See also: lt(), lte(), gte(), gt(), neq(), ncomp(), comp().

& neq()
  Function: neq(<number1>,<number2>)
 
  Takes two numbers, and returns 1 if they are not equal and 0 if they are
  equal.  Warning: passing anything but numbers will produce unexpected
  results, as non-numeric strings usually are treated as numeric 0.
 
  Examples:
    > say neq(1,-1)
    You say "1"
    > say neq(5,5)
    You say "0"
    > say neq(foo, bar)
    You say "0"
  See also: lt(), lte(), gte(), gt(), eq(), not(), ncomp(), comp().

& ncomp()
  Function: ncomp(<number1>, <number2>)
 
  This function returns 0 if the two numbers are equal, 1 if the first
  number is greater than the second number, and -1 if the first number
  is less than the second number.
 
  This function is useful for writing sortby() routines and other
  instances where it is useful to have a numerical counterpart to
  the comp() function.
 
  See also: lt(), lte(), gte(), gt(), eq(), neq(), not(), comp().
 
& cat()
  Function: cat(<string>[,<stringN>])
 
  cat returns a string made up of the contents of string1 through stringN,
  with each string separated from its neighbors by a space.
 
  Example:
    > say cat(this is, a test)
    You say "this is a test"
    > say cat(This is,another,test of the,CAT function)
    You say "This is another test of the CAT function"

& member()
  Function: member(<list>, <word>[, <delim>])
 
  Member takes a list and a word, and returns the position of that word
  within the list.  If the word does not occur in the list, then 0 is
  returned.  Unlike match(), member() does not check for wildcarding,
  and the cases of <list> and <word> are significant.  A word is defined as
  a string which has no interior spaces.  So 'hello' would be one word,
  while 'hello there' would be two.

  <delim> may be used to specify a delimiter other than a space.
 
  Example:
    > say member(This is a member test, member)
    You say "4"
    > say member(This is a member test, Member)
    You say "0"
    > say member(This is a member test, *e*)   
    You say "0"
    > say member(This is a member test, is a)
    You say "#-1 CAN ONLY TEST ONE ELEMENT"
 
  See also: LISTS, match(), strmatch().

& remove()
  Function: remove(<list>, <word>[, <delim>])
 
  Remove takes a list and a word, and returns the list, with the word deleted
  from it.  <delim> may be used to specify a delimiter other than a space.
 
  Example:
    > say remove(this is a test, is)
    You say "this a test"
    > say remove(You can't remove, this)
    You say "You can't remove"
    > say remove(You can't remove multiple words, You can't)
    You say "#-1 CAN ONLY DELETE ONE ELEMENT"
    > say remove(How about an o-separated list, w ab, o) 
    You say "Hout an o-separated list"

& RESTARTS()
  Function: restarts()
 
  Returns a number indicating the number of times that the MUSH has
  been restarted (in the sense of @restart, not a shut down and
  start up). When the MUSH is started, this number is 0; each time
  the MUSH is @restart'd, this number increments by 1.
 
  This is useful if you have, for example, things executed via
  @startup that should behave differently depending on whether
  or not the MUSH is starting "fresh" (with no players logged in,
  likely meaning things should be reset to "clean" states, etc.).
  
& RESTARTTIME()
  Function: restarttime()
 
  Returns a string which is the time the MUSH last restarted. The time
  is in the same format as the TIME() function returns.
 
  See also:  restarts(), starttime(), convtime().
 
& STARTTIME()
  Function: starttime()
 
  Returns a string which is the time the MUSH last rebooted.  The time
  is in the same format as the TIME() function returns.
 
  Example:
    > say starttime()
    You say "Sat Dec  7 00:09:13 1991
 
  See also: restarttime(), convtime().

& SECS()
  Function: secs()
 
  Returns the number of elapsed seconds since midnight, January 1, 1970.
  This is an easy way to time things.
 
  Example:
     > say secs()
     You say "692636020"
     ... wait a bit ...
     > say secs()
     You say "692636043"
  See also: convsecs(), convtime(), time().

& WORDS()
  words(<string>[, <delim>])
 
  Returns the number of words in <string>.  <delim> may be used to specify
  a delimiter other than a space.
 
  Example:
    > say words(This is a test)
    You say "4"
    say words(Would you like coffee or perhaps tea?)
    > You say "7"
    say words(This:is:a:colon:separated:list,:)
    > You say "6"

& VERSION()
  Function: version()
 
  Returns a string which contains various version information for the MUSH
  you're on.
 
  Example:
     > version
     TinyMUSH Beta version 2.0 patchlevel 0 #3
     Build date: Thu Dec  5 10:10:07 EST 1991
     > say version()
     You say "TinyMUSH Beta version 2.0 patchlevel 0 #3"

& HOME()
  home(<object>)
 
  Returns the object's home.
 
  Example:
    > exam me
    Mortal(#226Pc)
    Type: PLAYER Flags: CONNECTED
    Desc:Just a plain, old boring Mortal. You know.
    Owner: Mortal  Key: VA:foobar Clams: 920
    Last:Thu Dec 19 08:57:21 1991
    Home: Mortal's Room(#367R)
    Location: The Town Square
    > say home(me)
    You say "#367"

& MONEY()
  Function: money(<object>)
 
  Returns an integer equal to the amount of money <object> has (if it is a
  player) or is worth (otherwise).
  Example:
    > score
    You have 1052 clams.
    > say money(me)
    You say "1052"
    > exam sac test
    Sac Test(#287V)
    Type: THING Flags: VISUAL
    Owner: Beaker  Key: *UNLOCKED* Clams: 20
    Home: Limbo(#0RLDAJ)
    Location: The Town Square
    > say money(sac test)
    You say "20"

& XCON()
  Function: xcon(<object>, <element number>, <number of objects>)
 
  Returns a space-separated list of contents of <object>, starting from
  the <element number>'d object contained, up to <number of objects>. 
  This is useful for contents lists where a normal lcon() call would 
  exceed the maximum buffer length for function output.
 
  Example:
    > i
    t1(#366)
    t2(#411)
    t3(#700)
    t4(#108)
    radio(#223)
    The Wizard's Pointy Hat(#188SO)
    You have 42463 clams.
    > say xcon(me,3,3)
    You say "#700 #108 #223"
 
& LCON()
  Function: lcon(<object>)
 
  Returns a space-separated list of the contents of <object>.
 
  Example:
    > i
    t1(#366)
    radio(#223)
    The Wizard's Pointy Hat(#188SO)
    You have 42463 clams.
    > say lcon(me)
    You say "#366 #223 #188"
  See also: lexits(), @dolist.

& LEXITS()
  Function: lexits(<loc>)
 
  Returns a space-separated list of the exits in <loc> and its parents.
  Dark exits are not returned unless you own the location.
 
  Example:
    > look here
    The Town Square
    You are in the town square.  All around you .....
    Obvious exits:
    foo  up  southeast  sw  north  
    > say lexits(here)
    You say "#302 #10 #9 #8 #6"
  See also: lcon(), @dolist, PARENT OBJECTS.

& SECURE()
  Function: secure(<string>)
 
  Returns <string> after replacing the characters [](){};,%\$ with spaces.
  This prevents strings entered by players from causing undesired side
  effects when used, such as making your object perform unintended commands
  or give out information to which you have access.  Note that this function
  is only needed when the resulting string is to be passed through the @force
  command or be used as an attribute for an object (like the success message
  for a mail message object).
 
    > @va me=Sneak a peek at Wiz's desc... [get(#1/desc)]
    > say secure(%va)
    You say "Sneak a peek at Wiz's desc...  get #1/desc  "
    > say secure($foobar:this {is} a really, tough ; test.)
    You say " foobar:this is a really tough   test."
 
  Note: 'say secure(Sneak a peek at Wiz's desc... [get(#1/desc)])' does not
  produce the expected result because the argument is evaluated BEFORE being
  processed by secure(), therefore the [get()] call has already been
  performed.
  See also: escape().

& ESCAPE()
  Function: escape(<string>)
 
  Returns <string> after adding an escape character (\) at the start of the
  string and also before each of the characters %;[]{}\ that appear in the
  string.  This prevents strings entered by players from causing undesired
  side effects when used, such as making your object perform unintended
  commands or give out information to which you have access.  Note that this
  function is only needed when the resulting string is to be passed through
  the @force command or be used as an attribute for an object (like the
  success message for a mail message object).  This function has the 
  advantage over the secure() function in that the string the user sees
  after evaluating it is the same as the original string.
 
  Example:
    You say "\Sneak a peek at Wiz's desc... \[get(#1/desc)\]"
 
  Note: 'say escape(Sneak a peek at Wiz's desc... [get(#1/desc)])' does not
  produce the expected result because the argument is evaluated BEFORE being
  processed by escape(), therefore the [get()] call has already been
  performed.
  See also: secure().

& LIT()
  Function: lit(<string>)
 
  Returns the string literally -- unparsed and unevaluated.
 
& TRANSLATE()
  Function: translate(<string>, <type>)
 
  If given a type of '1' or 'p' (for "percent substitutions"), this
  function takes <string> and converts all raw ANSI color codes and
  other special characters to MUSH substitutions.
 
  If given a type of '0' or 's' (for "strip"), this function takes
  <string> and strips all raw ANSI color codes and other special
  characters.
 
& ANSI()
  Function: ansi(<codes>,<string>)
 
  This allows you to highlight a string using ANSI terminal effects. The
  string is terminated with a "return to normal" code, and the codes are
  utilized in the order they are specified. The codes are:
 
        f - flash                       i - inverse
        h - hilite                      n - normal
        u - underline

        x - black foreground            X - black background
        r - red foreground              R - red background
        g - green foreground            G - green background
        y - yellow foreground           Y - yellow background
        b - blue foreground             B - blue background
        m - magenta foreground          M - magenta background
        c - cyan foreground             C - cyan background
        w - white foreground            W - white background
 
  For example, "ansi(fc, Test)" would hilight "Test" in flashing cyan.
 
  Continued in 'help ansi2'.
 
& ANSI2
 
  The percent substitution %x<color code> can be used instead of ansi().
  For example, the equivalent to [ansi(rBf,Color!)] would be:
  %xr%xB%xfColor!%xn
 
  However, note that these are not exactly equivalent. The ansi() function
  "compacts" ANSI codes, taking advantage of the fact that the ANSI standard
  allows multiple ANSI attributes to be specified within an ANSI control
  string. Thus, if you are trying to @edit or edit() a string with ANSI
  characters embedded via the ansi() function, for instance, you may not
  be able to edit the ANSI sequence directly. If you need to be able to
  do this (for instance, to change the equivalent of '%xg' into '%xy'),
  you should use the %x-substitutions instead.
  
  The %xn (to return to normal) is not necessary, but if it is not specified,
  the ANSI color codes will continue to the end of the string.
 
  See also: ANSI, NOBLEED, stripansi().
 
& STRIPANSI()
  Function: stripansi(<string>)
 
  Strips the ANSI control sequences from a string.
 
  See also: ANSI, NOBLEED, ansi().
 
& MUDNAME()
  Function: mudname()
 
  Returns the name of the MUD.  This is usually (but not necessarily) the name
  that appears in the various mud lists, and is the name that the mud is
  listed under in reports from RWHO servers (that is, if the mud sends its
  WHO information to an RWHO server).
 
  Example:
    > say mudname()
    You say "TestMUSH"

& CAPSTR()
  Function: capstr(<string>)
 
  Returns <string> with the first character capitalized.  If the first
  character is not a letter, this function returns the string unmodified.
 
  Example:
    > say capstr(this is a string I want capitalized)
    You say "This is a string I want capitalized"
  See also: lcstr(), ucstr().

& LCSTR()
  Function: lcstr(<string>)
 
  Returns <string> with all letters converted to lowercase.
 
  Example:
    > say lcstr(This is something I want to TEST)
    You say "this is something i want to test"
  See also: capstr(), ucstr().

& UCSTR()
  Function: ucstr(<string>)
 
  Returns <string> with all letters converted to uppercase.
 
  Example:
    > say ucstr(This is a test, really!)
    You say "THIS IS A TEST, REALLY!"
  See also: capstr(), lcstr().

& LNUM()
  Function:  lnum(<number>[,<other>][,<sep>])
 
  If only given one argument, this function returns a list of numbers from
  0 to <number>-1.  <number> must be at least 1.
 
  If given at least two arguments, this function returns a list of numbers
  from <number> to <other>. If <other> is less than <number>, the list
  will return in descending order. Negative integers are permissible.
  <sep> is used as the separator character, if given.
 
  Examples:
    > say lnum(5) 
    You say "0 1 2 3 4"
    > say lnum(3,7)
    You say "3 4 5 6 7"
    > say lnum(4,-2)
    You say "4 3 2 1 0 -1 -2"
    > say lnum(2,6,|)
    You say "2|3|4|5|6"
 
& LRAND()
  Function: lrand(<range bottom>,<range top>,<times>,[,<output delim>])
 
  Returns a list with <times> elements separated by <output delim> (or
  a space if not specified), of random numbers between <range bottom>
  and <range top>.
 
  For instance, 'lrand(3, 6, 5)' would generate five random numbers
  in the range 3 - 6 (i.e., 3, 4, 5, or 6), such as '4 6 3 5 6'.
  
  See also: rand(), die(), lnum()
 
& LATTR()
  Function: lattr(<object>[/<wild-pattern>])
 
  Returns a list of the attributes set on <object>.  If <wild-pattern> is
  given, only attributes matching it are returned.
 
  Example:
    > exam me
    Mortal(#226Pc)
    ....
    VC:Mon Sep  9 12:09:01 1991
    VE:baz
    Last:Thu Dec 19 08:57:21 1991
    VV(#2+):Foof!
    Domain:Abusees
    ....
    > say lattr(me)
    You say "Desc VC VE Last VV Domain"
    > say lattr(me/v*)
    You say "VC VE VV"
 
  See also: @dolist.

& REVERSE()
  Function: reverse(<string>)
 
  Reverses the order of the characters of <string>.
 
  Examples:
    > say reverse(This is a test)
    You say "tset a si sihT"
    > say reverse(This is a test, Really...)
    You say "...yllaeR ,tset a si sihT"
    > say reverse(A man, a plan, a canal -- Panama!)
    You say "!amanaP -- lanac a ,nalp a ,nam A"
  See also: revwords().

& REVWORDS()
  Function: revwords(<string>[, <delim>])
 
  Reverses the order of the words of <string>.  A word is considered to be
  any sequence of nonblank characters, separated by blanks, so punctuation
  characters that follow a word are considered part of the word.

  <delim> may be used to specify a delimiter other than a space.
 
  Examples:
    > say revwords(This is a test, Really...)
    You say "Really... test, a is This"
    > say revwords(Was it a cat I saw?)
    You say "saw? I cat a it Was"
  See also: reverse().

& BEFORE()
  Function: before(<string1>, <string2>)
 
  Returns the portion of <string1> that occurs before <string2>.  If <string2>
  does not occur in <string1>, the entire string is returned.
  If you want to return the portion of the string after the first space,
  use the first() function instead.
 
  Examples:
    > say before(This is a test,a)
    You say "This is "
    > say before(This is a test,is)
    You say "Th"
    > say before(This is a test, nope) 
    You say "This is a test"
  See also: after(), first(), rest().

& AFTER()
  Function: after(<string1>, <string2>)
 
  Returns the portion of <string1> that occurs after <string2>.  If <string2>
  does not occur in <string1>, a null string is returned.
  If you want to return the portion of the string after the first space,
  use the rest() function instead.
 
  Examples:
    > say after(This is a test,a)
    You say " test"
    > say after(This is a test,is)
    You say " is a test"
    > say after(This is a test, nope)
    You say ""
  See also: before(), first(), rest().

& ROOM()
  Function: room(obj)
 
  Returns the number of the room that <obj> is in, or would be in if it
  executed LEAVE commands until it got to a room.  You can find out the
  containing room of objects you own, nearby objects, and findable players.
 
  Example:
    > i
    You are carrying:
    hat(#368)
    cat(#325)
    > look
    Mortal's Room(#367R)
    A bare room with nothing in it but a bed and a chair.
    > say I am in [room(me)], the cat is in room [room(cat)].
    You say "I am in #367, the cat is in room #367."
    > @fo hat=get cat 
    cat has left.
    > say The cat is in [loc(#325)] within room [room(#325)].
    You say "The cat is in #368 within room #367."
  See also: loc(), UNFINDABLE.

& SEARCH()
  Function: search([<player>] [<class>=<restriction>[,<low>[,<high>]]])
 
  The search() function returns a list of objects that match the search
  criteria, which are the same as with the @search command.  This function
  costs as much as the @search command, so repeated use is expensive.
 
  Caution: if you use the [ and ] characters in an Eval selection you will
  need to escape them.
 
  Examples:
    > say search()
    You say "#226 #289 #325 #364 #368 #369"
    > @stats me
    6 objects = 0 rooms, 0 exits, 5 things, 1 players. (0 garbage)
    > say search(eval=\[eq(money(##),1)\])
    You say "#289 #325 #364 #368 #369"
    > say search(player=wizard)
    You say "#1"
  See also: @search, SEARCH CLASSES.

& STATS()
  Function: stats([<player>])
 
  This function returns information about the number of objects on the MUSH,
  much like the @stats command.  If the argument is omitted or is 'all', then
  the stats for the entire MUSH are returned, otherwise the stats for the
  named player are returned.  You can only get stats for yourself.
 
  The stats are returned as a set of 6 numbers, in the same order as reported
  by the @stats command: total objects, rooms, exits, things, players, and
  garbage.  This command costs as much as the equivalent @stats command (ie:
  '@stats/all' or '@stats <player>', not the free '@stats').
 
  Examples:
    > @stats me
    6 objects = 0 rooms, 0 exits, 5 things, 1 players. (0 garbage)
    > say stats(me)
    You say "6 0 0 5 1 0"
    > say stats()
    You say "377 51 165 134 20 7"
    > @stats/all
    377 objects = 51 rooms, 165 exits, 134 things, 20 players. (7 garbage)
  See also: @stats.

& ITER()
  Function: iter(<list>, <eval>[, <delim>][, <output delim>])
 
  <list> is a <delimiter>-separated list of arbitrary strings. <eval> is a
  string that is to be evaluated once for each item in <list>, replacing
  the special symbol ## with the corresponding item from <list>, and 
  the special symbol #@ with the position of the item in the list.
  The special tokens can be escaped out, i.e., '\##' returns a literal '##'.
 
  A list of the results of these evaluations is returned to the caller; if
  <output delim> is specified, it is used; otherwise, a space is used.
 
  Multiple iter()s and list()s can be nested, with the ## and #@ tokens
  evaluating appropriately at each level. The nesting level can also
  be obtained, using the '#!' token.
 
  The effect is very similar to @dolist, except that the results are made
  into a list and returned, not executed. Note that @dolist's use of ##
  and #@ conflicts with iter()'s, though.
 
  Continued in 'help ITER2'.
 
& ITER2
 
  Examples:
    > say [iter(This is a test,strlen(##))]
    You say "4 2 1 4"
    > say [iter(1|2|3,#@/[add(##,1)],|,-)]
    You say "1/2-2/3-3/4"
    > say [iter(lcon(me),name(##),,+)]
    You say "apple+banana+orange"
    > say [iter(1-2-3-4,inc(##),-,@@)]
    You say "2345"
    > say [iter(1 2 3 4,inc(##),%b,%r)]
    You say "2
    3
    4
    5"
 
  See also: @dolist, parse(), list(), loop(), map(), DELIMITERS.
 
& LIST()
  Function: list(<list>, <eval>[, <delim>])
 
  This function behaves identically to iter(), but, instead of returning
  a list of words, it returns each result on a separate line, outputting
  it directly to the enactor. The result of the function itself is an
  empty string.
 
  Example:
    > say "[list(apples bananas oranges,#@ - ## - [strlen(##)])]"
    1 - apples - 6
    2 - bananas - 7
    3 - oranges - 7
    You say ""
    > @eval list(lnum(1,5),## - #@ - #! - [iter(lnum(##),##:#@:#!)])
    1 - 1 - 1 - 0:1:2
    2 - 2 - 1 - 0:1:2 1:2:2
    3 - 3 - 1 - 0:1:2 1:2:2 2:3:2
    4 - 4 - 1 - 0:1:2 1:2:2 2:3:2 3:4:2
    5 - 5 - 1 - 0:1:2 1:2:2 2:3:2 3:4:2 4:5:2
 
  See also: iter(), parse(), loop().
 
& LOOP()
  Function: loop(<list>, <eval>[, <delim>])
 
  This function behaves identically to parse(), but, instead of returning
  a list of words, it returns each result on a separate line, outputting
  it directly to the enactor. The result of the function itself is an
  emtpy string.
 
  This function is also otherwise identical to list(), except that 
  successive calls of it cannot be nested. The replacement of the
  '##' and '#@' tokens is "blind", i.e., it simply goes through the
  evaluation string without regard for nesting. As a result, it handles
  escapes in a different manner than iter().
 
  This function is provided for backwards compatibility.
 
  See also: iter(), parse(), list(), map().
 
& LOCATE()
  Function: locate(<looker>,<string>,<where>)
 
  The locate function is used to look for an object from the perspective of
  <looker> (You must own <looker>).  The database number of the item that
  is found is returned.  The <where> parameter specifies a list of places to
  look, from this list:
    a    - Look for absolute references (#<number>)
    c    - Look for exits carried by <looker> (and by <looker>'s parents).
    e    - Look for exits in <looker>'s location (and the location's parents).
    h    - Look for 'here', which matches <looker>'s location.
    i    - Look in <looker>'s inventory.
    m    - Look for 'me', which matches <looker>.
    n    - Look for <looker>'s neighbors (other objects in the same location).
    p    - Look for player names prefixed by a '*'
    *    - Look for everything in the above list.
{ 'help locate2' for more }
& locate2
  You may also specify qualifiers in <where> to help resolve possible
  ambiguities:
    E    - Prefer exits over other types.
    L    - Prefer unlocked exits over locked exits.
    P    - Prefer players over other types.
    R    - Prefer rooms over other types.
    T    - Prefer things over other types.
    V    - Report "Can't find..." and "Which one..." errors to <looker>.
    X    - Select randomly if search finds multiple ("ambiguous") matches.
 
  If nothing matches, the value #-1 is returned.  If more than one thing
  matches, but nothing matches exactly, the value #-2 is returned.  If more
  than one thing exactly matches, one is chosen at random.  If you specify
  more than one type preference (E, P, R, or T), then the last one entered
  is the one that is obeyed.  The default is for no type to be preferred.
 
( 'help locate3' for more )
& LOCATE3
  Examples:
    > i
    test1(#378)
    test(#376)
    You have 42463 clams.
    > look
    Nullspace(#250R)
    test1(#382)
    > say locate(me,test,i)
    You say "#376"
    > say locate(me,test,n)
    You say "#382"
    > say locate(me,test1,in)
    You say "#378"
    > say locate(me,test1,in)
    You say "#382"
    > say locate(me,tes,in)
    You say "#-2"
    > say locate(here,tes,*)
    You say "#382"
    > say locate(me,out,e)
    You say "#252"
    > say locate(me,here,*)
    You say "#250"
 
  See also: num(), PARENT OBJECTS.

& EDIT()
  Function: edit(<string>,<from>,<to>)
 
  This function edits <string>, replacing all occurrences of the substring
  <from> with the string <to>.  If <from> is '$', then <to> is appended to
  <string>, while if <from> is '^', then it is prepended. edit()'s arguments
  can have ANSI characters embedded within them. However, because MUSH
  typically appends a terminating 'normal' ANSI string to strings, the
  terminating 'normal' is stripped for <from> and <to>. If you really need
  a 'normal', you should put '%xn%xn' at the end of the string.
  
  Examples:
    > say edit(This is a test,is,x)   
    You say "Thx x a test"
    > say edit(Atlantic,^,Trans)
    You say "TransAtlantic"
    > say translate(edit(FOO-%xrBAR-BAZ,%xrB,%xyB),p)
    You say "FOO-%xyBAR-BAZ%xn"
    > say translate(edit(FOO-BAR-BAZ,BAR,%xyBAR%xn%xn),p)
    You say "FOO-%xyBAR%xn-BAZ"
 
  See also: @edit.
 
& OBJEVAL()
  Function:  objeval(<object>,<expression>)
 
  This function allows you to evaluate <expression> from the viewpoint of
  <object>. You must own <object>, or have Wizard powers. If you do not,
  the function defaults to evaluating from your viewpoint.
  
  This function is useful for securing privileged objects which need
  to evaluate attributes on things owned by other, or otherwise restrict
  access to privileged information. For example, it's useful for a global
  '+who' object to call the LWHO() function from the viewpoint of the
  enactor (i.e, a 'objeval(%#,lwho())' call), so that if the player is
  mortal, DARK wizards are hidden, but if the player is a wizard, DARK
  wizards appear on the list.
 
& U()
  Function: u([<obj>/]<attr>[,<arg>]...)
 
  The u function evaluates an attribute, either from the object performing the
  function or from another object you own, passing in arguments and returning
  the result.

  When evaluating the fetched attribute, %# refers to the original enactor and
  not the 'calling' object, and 'me' refers to the object that supplied the
  attribute.
 
  Examples:
    > @va me=Word is [extract(v(vb),add(%0,1),1)], arg2 is %1.
    > @vb me=This is a test of the u function.
    > say u(va,4,Testing 123)
    You say "Word is of, arg2 is Testing 123."
    > say u(va,7)
    You say "Word is function., arg2 is ."
    > say u(me/va,6,Foobar)
    You say "Word is u, arg2 is Foobar."
  See also: s(), v(), get(), get_eval(), map().

& ULOCAL()
  Function:  ulocal([<obj>/]<attr>[,<arg>]...)
 
  The ulocal() function is almost identical to u() in function:  it
  evaluates an attribute, either from the object performing the function,
  or another object that you control or has the same owner as you, passing
  in arguments and returning the result. When evaluating the fetched
  attribute, %# refers to the original enactor and not the 'calling' object;
  'me' refers to the object that supplied the attribute.
 
  However, unlike the u() function, the global registers r(0) through r(9)
  (%q0 - %q9) are preserved in their initial state. This means that functions
  "below" the level of the u() can reset global registers for temporary
  calculations, without needing to worry about "clobbering" the original
  values.
 
  This makes ulocal() particularly useful for global or shared code which
  calls arbitrary u() functions, where global register values need to be
  preserved from accidental user clobbering.
 
  See "help ulocal2" for examples.
 
& ULOCAL2
  Example of ulocal():
    > &FRUIT me=apples bananas oranges pears
    > &SUB-FUNCTION me=[setq(0,v(FRUIT))][extract(%q0,match(%q0,%0),1)]
    > &TOP-FUNCTION me=[setq(0,are delicious!)][ulocal(SUB-FUNCTION,%0)] %q0
    > say u(TOP-FUNCTION,b*)
    You say "bananas are delicious!"
 
  If SUB-FUNCTION had been called with u() instead of ulocal():
    > &TOP-FUNCTION me=[setq(0,are delicious!)][u(SUB-FUNCTION,%0)] %q0
    > say u(TOP-FUNCTION,b*)
    You say "bananas apples bananas oranges pears"
 
  In this second example, in SUB-FUNCTION, %q0 was set to "apples bananas
  oranges pears", so that when the u() "returned" and TOP-FUNCTION evaluated
  %q0, this is what was printed. In the first example, ulocal() reset the
  value of %q0 to its original "are delicious!"
 
  See also:  u(), setq(), r()
& SWITCH()
  Function: switch(<str>[,<pat1>,<res1>]...[,<dflt>])
 
  The switch() function compares <str> against <pat1>, <pat2>, etc (allowing
  * to match any number of characters and ? to match any 1 character), and
  returns the corresponding <resN> parameter for the first <patN> pattern
  that matches.  If none match, then the default result <dflt> is returned.
  The evaluated value of <str> can be obtained as '#$'. If switch() and
  switchall() are nested, the nest level can be obtained with '#!'.
 
  Example:
    > say switch(c,*a*,A,*b*,B,*c*,C,*d*,D,E)
    You say "C"
    > say switch(f,*a*,A,*b*,B,*c*,C,*d*,D,E)
    You say "E"
    > say switch(cab,*a*,A,*b*,B,*c*,C,*d*,D,E)
    You say "A"
    > say switch(f,*a*,A,*b*,B,*c*,C,*d*,D)  
    You say ""
    > say switch(words(foo bar baz),0,No words,1,1 word,#$ words)
    You say "3 words"
 
  See also: @switch, switchall(), match().
 
& SWITCHALL()
  Function: switch(<str>[,<pat1>,<res1>]...[,<dflt>])
 
  The switchall() function compares <str> against <pat1>, <pat2>, etc.
  (allowing * to match any number of characters and ? to match any 1
  character), and returns the corresponding <resN> parameters (without
  any delimiters) for all <patN> patterns that match.  If none match,
  then the default result <dflt> is returned. The evaluated value of
  <str> can be obtained as '#$'. If switchall() and switch() are
  nested, the nest level can be obtained with '#!'.
 
  Example:
    > say switchall(c,*a*,A,*b*,B,*c*,C,*d*,D,E)
    You say "C"
    > say switchall(dab,*a*,A,*b*,B,*c*,C,*d*,D,E)
    You say "ABD"
    > say switchall(f,*a*,A,*b*,B,*c*,C,*d*,D,E)  
    You say "E"
 
  See also: @switch, switch(), match().
  
& NONZERO()
  Function: nonzero(<condition>,<string if non-zero>,<string if zero>)
 
  If <condition> is non-zero (defined as a non-null string that is
  not the number zero, '0'), then the <string if non-zero> is returned.
  Otherwise the <string if zero> is returned. Those two strings are not
  evaluated until appropriate (i.e., if the string is non-zero, the
  string-if-zero will not be evaluated, and vice versa).
 
  Examples:
    > say [nonzero(0,not zero,zero)] - [nonzero(1,not zero,zero)]
    You say "zero - not zero"
    > say [nonzero(,null,not null)] - [nonzero(foo,null,not null)]
    You say "null - not null"
   
  See also: ifelse(), switch(), case().
 
& IFELSE()
  Function: ifelse(<condition>,<string if true>,<string if false>)
 
  If <condition> is true (defined as a true boolean), then the
  <string if true> is returned. Otherwise, the <string if false>
  is returned. The true and false strings are not evaluated until
  appropriate (i.e., if the condition is true, the string-if-false
  will not be evaluated, and vice versa).
 
  Examples:
    > say [ifelse(1,true,false)] - [ifelse(0,true,false)]
    You say "true - false"
    > say [ifelse(test,true,false)] - [ifelse(,true,false)]
    You say "true - false"
    > say [ifelse(#5,true,false)] - [ifelse(#-1,true,false)]
    You say "true - false"
  
  See also: nonzero(), switch(), case(), BOOLEAN VALUES.
 
& LOCALIZE()
  Function: localize(<expression>)
 
  This function evalutes <expression> in a 'local' scope; this means
  that the r-registers are preserved before <expression> is evaluated,
  and restored after the evaluation. This allows the <expression>
  embedded within to access the previous values of the r-registers,
  without causing side-effects further "up" the code by altering the
  value of those r-registers outside the scope of the <expression>'s
  block of code.
 
  See also:  ulocal(), objeval(), s().
  
& SPACE()
  Function: space(<count>)
 
  Returns the number of indicated spaces.  If <count> is missing, negative,
  or cannot be converted to a number, one space is returned.  This function
  is useful when you want to pass a single space (or more than one) as a
  function to an argument, because normally leading and trailing spaces are
  stripped from function arguments.
 
  Examples:
    > say space(4)
    You say "    "
    > say edit(Foo bar bletch, space(), X)
    You say "FooXbarXbletch"

& PARENT()
  Function: parent(<obj>)
 
  Returns the parent of <obj>.  Returns #-1 if <obj> cannot be found or
  if you do not own <obj> and it is not set VISUAL.
 
  Example:
    > say parent(me)
    You say "#-1"
    > say My va is [v(va)].
    You say "My va is "
    > @parent me=test
    Parent set.
    > say parent(me)
    You say "#323"
    > say My va is [v(va)].
    You say "My va is Testing 123"
  See also: @parent, PARENT OBJECTS.

& SIGN()
  Function: sign(<number>)
 
  Returns -1, 0, or 1 depending on whether its argument is negative, zero, or
  positive (respectively).
 
  Example:
  > say sign(-4)
  You say "-1"
  > say sign(4)
  You say "1"
  > say sign(0)
  You say "0"
  > say sign(-1)
  You say "-1"

& CONN()
  Function: conn(<player>)
 
  Returns the number of seconds that <player> has been connected.  If <player>
  is not connected then -1 is returned.  If <player> is connected more than
  once, the longest connect time is returned.
 
  Example:
    > WHO
    Player Name          On For Idle  Doing
    Wizard                00:04   1m
    Mortal                00:11   0s  
    Evinar                00:12   6m  
    Wizard                00:32   6s  
    3 Players logged in.
    > say conn(wiz)
    You say "251"
    > say conn(e)
    You say "770"
    > say conn(frobozz)
    You say "-1"
  See also: WHO, idle(), lwho().

& IDLE()
  Function: idle(<player>)
 
  Returns the number of seconds that <player> has been idle.  If <player>
  is not connected then -1 is returned.  If <player> is connected more than
  once, the smallest idle time is returned.
 
  Example:
    > WHO
    Player Name          On For Idle  Doing
    Wizard                00:04   1m
    Mortal                00:11   0s  
    Evinar                00:12   6m  
    Wizard                00:32   6s  
    3 Players logged in.
    > say idle(wiz)
    You say "6"
    > say idle(e)
    You say "371"
    > say idle(frobozz)
    You say "-1"
  See also: WHO, conn(), lwho().

& CONVSECS()
  Function: convsecs(<seconds>)
 
  This function converts seconds to a time string, based on how many
  seconds the number is after Jan 1, 1970.
 
  Example:
    > say secs()
    You say "709395750"
    > say convsecs(709395750)
    You say "Wed Jun 24 10:22:54 1992"
  This function may also be called as secs2time().
  See also: convtime(), secs(), time().

& CONVTIME()
  Function: convtime(<time string>)
 
  This functions converts a time string to the number of seconds since
  Jan 1, 1970. A time string is of the format: Ddd MMM DD HH:MM:SS YYYY
  where Ddd is the day of the week, MMM is the month, DD is the day
  of the month, HH is the hour in 24-hour time, MM is the minutes,
  SS is the seconds, and YYYY is the year.
  If you supply an incorrectly formatted string, it will return -1.
 
  Example:
    > say time()
    You say "Wed Jun 24 10:22:54 1992"
    > say convtime(Wed Jun 24 10:22:54 1992)
    You say "709395774"
  This function may also be called as time2secs().
  See also: convsecs(), secs(), time().

& CONFIG()
  Function:  config(<parameter name>)
 
  This function returns the value of the named configuration parameter.
  Not all configuration options can be obtained this way; some are protected
  for security reasons, while others don't have a single simple value
  (access directives, for instance).
 
& SHUFFLE()
  Function:  shuffle(<word1> <word2> <...<wordN>[,<delim>][,<output delim>])
 
  This function shuffles the order of words in a list, returning a random
  permutation of its elements.
 
  Example:
    > say shuffle(foo bar baz gleep)
    You say "baz foo gleep bar"
    > say shuffle(foo-bar-baz-gleep,-,+)
    You say "baz+foo+gleep+bar"
 
& SCRAMBLE()
  Function:  scramble(<string>)
 
  This function scrambles a string, returning a random permutation of its
  characters. Note that this function does not pay any attention to spaces
  or other special characters; it will scramble these characters just like
  normal characters.
 
  Example:
    > say scramble(abcdef)
    You say "cfaedb"
 
  See also:  SHUFFLE()

& SORT()
  Function: sort(<list>[, <sort type>[, <delim>][, <output delim>])
 
  Takes a list of words, numbers, or dbref, and sorts them into ascending
  order.  Lexicographic order is used for words, and numeric order is used
  for numbers and dbrefs.
 
  <sort type> may be used to specify the type of sort to perform (use d for
  dbref, n for integer numeric, f for floating numeric, and a for
  alphanumeric).  If omitted or left blank, the sort() function will
  automatically determine the type of sort to perform.
 
  If delimiters are specified, they are used to separate items in the list.
  You may specify them without a sort type by passing a null <sort type> .
 
  Examples:
    > say sort(This is a test)
    You say "This a is test"
    > say sort(98 99 100 101)
    You say "98 99 100 102"
    > say sort(foo-bar-bletch,,-,+)
    You say "bar+bletch+foo"

& SETDIFF()
  Function: setdiff(<list1>, <list2>[, <delim>][, <output delim>])
 
  This function returns the difference of two sets -- i.e., the elements in
  <list1> that aren't in <list2>. The list that is returned is sorted.
 
  If delimiters are specified, they are used to separate the lists.
 
  Example:
    > say setdiff(foo baz gleep bar, bar moof gleep)
    You say, "baz foo"
    > say setdiff(foo-baz-gleep-bar, bar-moof-gleep,-,+)
    You say "baz+foo"
 
  See also: setinter(), setunion(), sort().

& SETINTER()
  Function: setinter(<list1>, <list2>[, <delim>][, <output delim>])
 
  This function returns the intersection of two sets -- i.e., the elements
  that are in both <list1> and <list2>. The list that is returned is sorted.
 
  If delimiters are specified, they are used to separate the lists.
 
  Example:
    > say setinter(foo baz gleep bar, bar moof gleep)
    You say, "bar gleep"
    > say setinter(foo-baz-gleep-bar, bar-moof-gleep,-,+)
    You say, "bar+gleep"
 
  See also: setdiff(), setunion(), sort().

& SETUNION()
  Function: setunion(<list1>, <list2>[, <delim>][, <output delim>])
 
  This function returns the union of two sets -- i.e., all the elements of
  both <list1> and <list2>, minus any duplicate elements. Think of it as
  CAT() without duplicated words.  The list returned is sorted.
 
  If delimiters are specified, they are used to separate the lists.
  
  Example:
    > say setunion(foo baz gleep bar, bar moof gleep)
    You say, "bar baz foo gleep moof"
    > say setunion(foo-baz-gleep-bar, bar-moof-gleep,-,+)
    You say, "bar+baz+foo+gleep+moof"
 
  See also: setdiff(), setinter(), sort().

& MERGE()
  Function: merge(<string1>,<string2>,<character>)
  
  This function merges <string1> and <string2>, depending on <character>.
  If a character in <string1> is the same as <character>, it is replaced
  by the character in the corresponding position in <string2>.  The two
  strings must be of the same length.
  
  Spaces need to be treated specially. A null character is considered to
  equal a space, for <character>.
  
  Examples:
    > say merge(AB--EF,abcdef,-)
    You say, "ABcdEF"
    > say merge(AB[space(2)]EF,abcdef,)
    You say, "ABcdEF"
  See also: splice().

& REPEAT()
  Function: repeat(<string>,<number>)
  
  This function simply repeats <string>, <number> times.  No spaces are
  inserted between each repetition.
  
  Example:
    > say repeat(Test, 5)
    You say, "TestTestTestTestTest"

& SPLICE()
  Function: splice(<list1>, <list2>, <word>[, <delim>][, <output delim>])
  
  This function splices <list1> and <list2> together. <list1> and <list2>
  are space-separated lists of words.
  
  If a word in <list1> is the same as <word>, it is replaced by the word
  in the corresponding position in <list2>.  Both lists must have the
  same number of words.
 
  Delimiters other than a space may be specified.
 
  Example:
    > say splice(foo bar baz,eek moof gleep,bar)
    You say, "foo moof baz"
    > say splice(foo-bar-baz,eek-moof-gleep,bar,-,+)
    You say, "foo+moof+baz"

  See also: merge().

& PI()
  Function: pi()
 
  Returns the value of the trigonometric constant pi to nine decimal places.
 
  Example:
    > say pi()
    You say "3.141562654"
  See also: acos(), asin(), atan(), cos(), sin(), tan().

& E()
  Function: e()
  Returns the value of the numeric constant e to nine decimal places.
 
  Example:
    > say e()
    You say "2.718281828"
  See also: exp(), ln(), log(), power().

& SIN()
  Function: sin(<number>)
 
  Returns the sine of <number>, expressed in radians.
 
  Examples:
    > say sin(0)
    You say "0"
    > say sin(fdiv(pi(),2))
    You say "1"
    > say sin(fdiv(pi(),4))
    You say "0.707107"
    > say sin(fdiv(pi(),6))
    You say "0.5"
  See also: acos(), asin(), atan(), cos(), pi(), tan().

& COS()
  Function: cos(<number>)
 
  Returns the cosine of <number>, expressed in radians.
 
  Examples:
    > say cos(0)
    You say "1"
    > say cos(fdiv(pi(),2))
    You say "0"
    > say cos(fdiv(pi(),4))
    You say "0.707107"
    > say cos(fdiv(pi(),6))
    You say "0.866025"
  See also: acos(), asin(), atan(), pi(), sin(), tan().

& TAN()
  Function: tan(<number>)
 
  Returns the tangent of <number>, expressed in radians.
 
  Examples:
    > say tan(0)
    You say "0"
    > say tan(1)
    You say "1.557408"
    > say tan(fdiv(pi(),4))
    You say "1"
  See also: acos(), asin(), atan(), cos(), pi(), sin().

& ASIN()
  Function: asin(<number>)
 
  Returns the arcsine of <number>, expressed in radians.
 
  Examples:
    > say asin(0)
    You say "0"
    > say asin(1)
    You say "1.570796"
    > say asin(0.707101)
    You say "0.78539"
    > say asin(0.5)
    You say "0.523599"
  See also: acos(), atan(), cos(), pi(), sin(), tan().

& ACOS()
  Function: acos(<number>)
 
  Returns the arc-cosine of <number>, expressed in radians.
 
  Examples:
    > say acos(0)
    You say "1.570796"
    > say acos(1)
    You say "0"
    > say acos(0.707101)
    You say "0.785406"
    > say acos(0.866025)
    You say "0.5236"
  See also: asin(), atan(), cos(), pi(), sin(), tan().

& ATAN()
  Function: atan(<number>)
 
  Returns the arctangent of <number>, expressed in radians.
 
  Examples:
    > say atan(0)
    You say "0"
    > say atan(1)
    You say "0.785398"
    > say atan(1.557408)
    You say "1"
  See also: acos(), asin(), cos(), pi(), sin(), tan().

& FLOOR()
  Function: floor(<number>)
 
  Returns the largest integer less than or equal to <number>.  <number> may be
  a floating point number, and an integer result is returned.
 
  Examples:
    > say floor(5)
    You say "5"
    > say floor(5.2)
    You say "5"
    > say floor(5.8)
    You say "5"
    > say floor(-5)
    You say "-5"
    > say floor(-5.2)
    You say "-6"
  See also: ceil(), div(), mod(), round(), trunc().

& CEIL()
  Function: ceil(<number>)
 
  Returns the smallest integer greater than or equal to <number>.  <number>
  may be a floating point number, and an integer result is returned.
 
  Examples:
    > say ceil(5)
    You say "5"
    > say ceil(5.2)
    You say "6"
    > say ceil(5.8)
    You say "6"
    > say ceil(-5)
    You say "-5"
    > say ceil(-5.2)
    You say "-5"
  See also: div(), floor(), mod(), round(), trunc().

& TRUNC()
  Function: trunc(<number>)
 
  Returns the value of <number> after truncating off any fractional value.
  <number> may be a floating point number, and an integer result is returned.
 
  Examples:
    > say trunc(5)
    You say "5"
    > say trunc(5.2)
    You say "5"
    > say trunc(5.8)
    You say "5"
    > say trunc(-5)
    You say "-5"
    > say trunc(-5.2)
    You say "-5"
  See also: div(), floor(), mod(), round().

& ROUND()
  Function: round(<number>,<places>)
 
  Rounds <number> to <places> decimal places.  <number> may be
  a floating point number, and an integer result may be returned.
 
  Examples:
    > say round(5,0)
    You say "5"
    > say round(5.123,1)
    You say "5.1"
    > say round(9.8765,3)
    You say "9.877"
    > say round(5.5,0)
    You say "6"
    > say round(-5.5,0)
    You say "-6"
  See also: div(), floor(), mod(), trunc().

& SQRT()
  Function: sqrt(<number>)
 
  Returns the square root of <number>.  <number> may be a floating point
  number, and a floating point result is returned.  <number> may not be
  negative.
 
  Examples:
    > say sqrt(2)
    You say "1.414214"
    > say sqrt(100)
    You say "10"
    > say sqrt(0)
    You say "0"
    > say sqrt(-1)
    You say "#-1 SQUARE ROOT OF NEGATIVE"
  See also: power().

& POWER()
  Function: power(<number>, <power>)
 
  Returns the result of raising <number> to the <power>'th power.
  <number> may not be negative.  <number> and <power> may be floating point
  numbers, and a floating point result is returned.
 
  Examples:
    > say power(2,3)
    You say "8"
    > say power(9, 0.5)
    You say "3"
    > say power(100,pi())
    You say "1919487.587204"
    > say power(5, 0)
    You say "1"
    > say power(0, 0)
    You say "1"
    > say power(2,-3)
    You say "0.125"
    > say power(-2,3)
    You say "#-1 POWER OF NEGATIVE"
  See also: exp(), ln(), log(), sqrt()

& LN()
  Function: ln(<number>)
 
  Returns the result of taking the natural logarithm (base e) of <number>.
  <number> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say ln(0)
    You say "#-1 LN OF NEGATIVE OR ZERO"
    > say ln(1)
    You say "0"
    > say ln(e())
    You say "1"
    > say ln(10)
    You say "2.302585"
  See also: e(), exp(), log(), power().

& LOG()
  Function: log(<number>[,<base>])
 
  If <base> is not specified, this returns the result of taking the
  common logarithm (base 10) of <number>. If <base> is specified, 
  then this returns the result of taking the log base <base> of
  <number>. To take the natural log of a number, make its base e().
  <number> may be a floating point number, and a floating point result
  is returned.
 
  Examples:
    > say log(0)
    You say "#-1 LOG OF NEGATIVE OR ZERO"
    > say log(1)
    You say "0"
    > say log(100)
    You say "2"
    > say log(e())
    You say "0.434294"
    > say log(32,2)
    You say "5"
 
  See also: e(), exp(), ln(), power().

& EXP()
  Function: exp(<power>)
 
  Returns the result of raising the numeric constant e to <power>.
  <power> may be a floating point number, and a floating point result
  is returned.
 
  Examples: 
    > say exp(0)
    You say "1"
    > say exp(1)
    You say "2.718282"
    > say exp(2)
    You say "7.389056"
  See also: e(), log(), ln(), power().
& PARSE()
  Function:  parse(<list>, <eval>[, <delim>][, <output delim>])
 
  This function behaves identically to iter(), except that successive
  calls of it cannot be nested. The replacement of the '##' and '#@'
  tokens is "blind", i.e., it simply goes through the evaluation string
  without regard for nesting. As a result, it handles escapes in a
  different manner than iter().
 
  This function is provided for backwards compatibility.
 
  See also: iter(), map(), list(), loop().
 
& sees()
  Function:  sees(<object>,<victim>)
 
  If <victim> would show up in the list of room contents, if <object>
  was looking at <victim>'s location, this function returns 1; note
  that <object> never sees himself in the contents so if <object> and
  <victim> are the same this function returns 0.
 
  This function checks a lot of things: whether or not the object is a
  disconnected player, the status of the Light and Dark flags, whether
  or not <object> controls <victim>'s location, and more.
 
  If either <object> or <victim> are not valid objects, this function
  returns 0.

& findable()
  Function:  findable(<object>,<victim>)
 
  Returns 1 if <object> can locate <victim>, or 0 otherwise. This checks
  wizard status of <object>, UNFINDABLE status of <victim>, and other
  related factors.
 
& visible()
  Function:  visible(<object>,<victim>[/<attr>])
 
  Returns 1 if <object> can examine <victim>, or 0 otherwise. If
  <object> or <victim> do not exist, 0 is returned.
 
  If an object-attribute pair is provided, 1 is returned if <object>
  can see <attr> on <victim>. If <attr> is not present on <victim>,
  1 is returned if <object> can examine <victim>.
 
& controls()
  Function: controls(<object>,<victim>)
 
  Returns 1 if <object> controls <victim>, 0 otherwise.
 
  Examples:
  > say controls(me,me)
  You say "1"
  > say controls(me,#1)
  You say "0"
  > say controls(#1,me)
  You say "1"
 
  See also: CONTROL.

& map()
  Function: map([<obj>/]<attr>, <list>[, <delim>][, <output delim>])
  
  This function is nearly identical to an iter() operating on u() function.
  Each member of <list> is passed to the result of fetching <attr> as %0, and
  the results are used to form a new list. <delim> (the input delimiter) is
  used to separate strings within the list. The results are separated by
  <output delimiter> if it is specified, or by <input delimiter> if
  it is not. The input delimiter defaults to a space if not specified.
  
  Examples: 
  > &ADD_ONE object=add(%0,1)
  > say map(object/add_one,1 2 3 4 5)
  You say "2 3 4 5 6"
  > say map(object/add_one,1 2 3 4 5,,-)
  You say "2-3-4-5-6"
  > say map(object/add_one,1-2-3-4-5,-,+)
  You say "2+3+4+5+6"
  > say map(object/add_one,1 2 3 4 5,-,@@)
  You say "23456"
  
  See also: filter(), fold(), iter(), step(), u().

& filter()
  Function: filter([<obj>/]<attr>, <list>[, <delim>][, <output delim>])

  This function evaluates the contents of <attr> for each element of <list>,
  passing it in as %0.  An <output delim>-separated list is returned of those
  elements for which the evaluation returns the value 1.

  <delim> and <output delim> may be used to specify delimiters other than
  spaces.
  
  Examples:
    > &IS_ODD object=mod(%0,2)
    > say filter(object/is_odd,1 2 3 4 5)
    You say "1 3 5"
    > say filter(object/is_odd,1-2-3-4-5,-)
    You say "1-3-5"
    > say filter(object/is_odd,1 2 3 4 5,,+)
    You say "1+3+5"
    > say filter(object/is_odd,1-2-3-4-5,-,.)
    You say "1.3.5"
 
  See also: filterbool(), u(), map(), fold()
 
& filterbool()
  Function: filter([<obj>/]<attr>, <list>[, <delim>][, <output delim>])
 
  This function works identically to filter(), except that it returns
  all elements of the list for whom the evaluation returns a boolean
  truth value.
 
  Example:
    > &IS_JUMPOK object=[hasflag(%0,Jump_OK)]
    > say filterbool(object/IS_JUMPOK,#10 #25 #-1 #6)
    You say "#25 #6"   [assuming those rooms are jump_ok]
 
& fold()
  Function: fold([<obj>/]<attr>, <list>[, <base-case>[, <delim>])

  This function iteratively processes a list through a function, feeding
  the result of one step into the next step as %0, passing in the next element
  from the list as %1.

  If a base case is provided, it is used as the initial %0.  If not, the first
  list element is passed as %0 and the second is passed as %1, and subsequent
  iterations proceed normally.
  
  <delimiter> may be used to specify a delimiter other than space, but you
  must specify a base case in order to specify the delimiter.
 
  Examples:
    > &REP_NUM object=[%0][repeat(%1,%1)]
    > say fold(object/rep_num,1 2 3 4 5,->)
    You say "->122333444455555"
    > &ADD_NUMS object=add(%0,%1)
    > say fold(object/add_nums,1 2 3 4 5)
    You say "15"
  See also: u(), iter(), map(), filter()

& RJUST()
  Function: rjust(<string>, <length>[, <fill>])
 
  This function pads a string with leading <fill> characters, or with spaces
  if no fill character is given) ("right-justifies") so it is <length> long.
  If <string> is longer than <length>, the <string> is returned; it is not
  truncated.
 
  Examples:
    > say -[rjust(foo,6)]-
    You say "-   foo-"
    > say %r0[rjust(foo,6)]7%r01234567
    You say "
    0   foo7
    01234567"
    > say =[rjust(bar,5,.)]=
    You say "=..bar="
  See also: ljust(), strlen().

& LJUST()
  Functions: ljust(<string>, <length>[, <fill>])
 
  This function pads a string with trailing <fill> characters, or with spaces
  if no fill character is given) ("left-justifies") so it is <length> long.
  If <string> is longer than <length>, the <string> is returned; it is not
  truncated.
 
  Examples:
    > say -[ljust(foo,6)]-
    You say "-foo   -"
    > say %r0[ljust(foo,6)]7%r01234567
    You say "
    0foo   7
    01234567"
    > say =[ljust(bar,5,.)]=
    You say "=bar..="
  See also: rjust(), strlen().
 
& LINK()
  Function: link(<object>,<destination>)
 
  This side-effect function links an object to a location, behaving
  identically to the command '@link <object>=<destination>'.
 
& TEL()
  Function: tel(<object>,<destination>)
 
  This side-effect function teleports an object from one place to another,
  behaving identically to the command '@tel <object>=<destination>'.
 
& WIPE()
  Function: wipe(<object>[/<wild-attr>])
 
  This side-effect function erases some or all attributes from an object,
  behaving identically to the command '@wipe <object>[</wild-attr>]'.
 
& SET()
  Function: set(<arg 1>,<arg 2>)
 
  This acts identically to the command '@set <arg 1>=<arg 2>'. An
  empty string is always returned, regardless of the success or
  failure of the attempted set.
 
  Common cases of use of this function:
	set(<object>,[!]<flag>)
	set(<object>,<attribute>:<value>)
	set(<object>,<attribute>:_<fromobj>/<fromattr>)
	set(<object>/<attr>,[!]<attrflag>)

& R()
  Function: r(<number>)
 
  The r() function is used to access "local registers", and returns
  the contents of the specified register. There are ten such registers,
  numbered 0 through 9.  The local registers are normally cleared at the
  start of each command, but are preserved across the commands that compose
  an actionlist, as well as commands that directly trigger actionlists, such
  as @switch, @trigger, and @dolist.
 
  This is equivalent to the substitution %q<number>; i.e., "r(0)" == "%q0".
 
  See also: setq(), setx(), x().

& SETQ()
  Function: setq(<number>,<string>)
 
  The setq() function is used to copy strings into local registers.
  It returns a null string; it is a purely "side effect" function.

  There are ten local registers, numbered 0 through 9. They are cleared
  at the start of each command. They are most useful for storing complex
  function evaluations which are used repeatedly within a single command.
  The local registers may be read via the r() function or the %q substitution,
  and a common use of setq()/r() is to temporarily store the result of a
  complex evaluation whose result is needed more than once.
 
  setq() can be used to improve the readability of MUSH code, as well as to
  cut down the amount of time needed to do complex evaluations.
 
  Example:
    > &TEST me=Test on [mudname()] at [time()].
    > say [setq(0,u(TEST))]'[r(0)]' has length [strlen(r(0))].
    You say "'Test on TestMUSH at Tue Feb 23 17:00:51 1993.' has length 45."
 
  See also: setr(), r(), setx(), x().
 
& SETR()
  Function: setr(<number>,<string>)
 
  This function behaves identically to the setq() function, except
  that it returns the string being copied in the register.
 
  Example:
    > &TEST me=Test on [mudname()] at [time()].
    > say '[setr(0,u(TEST))]' has length [strlen(%q0)].
    You say "'Test on TestMUSH at Tue Feb 23 17:00:51 1993.' has length 45."
 
  See also: setq(), r(), setx(), x().
 
& SETX()
  Function:  setx(<variable name>,<value>)
 
  This function sets the value of a variable associated with the
  calling object. Using an empty <value> will unset the variable. For
  reasons of memory consumption, variables should ALWAYS be explicitly
  unset when they are not immediately needed. This function does not
  return anything.
 
  Example:
    > say Testing [setx(temp,abc)][x(temp)] - [strlen(x(temp))].
    You say "Testing abc - 3."
 
  See also: x(), lvars(), clearvars(), xvars(), let(), regparse().
 
& X()
  Function:  x(<variable name>)
 
  This function retrieves a temporary variable associated with the object
  making the function call.
  
  The variable can also be retrieved via the more efficient percent
  substitution, For variable names of a single letter or digit (A - Z,
  0 - 9), this is %_<variable name> -- x(a) is equivalent to %_a, x(0) is
  equivalent to %_0, and so forth. Multi-letter variable names can also
  be accessed in this way, if the variable name is enclosed in angle
  brackets -- x(foo) is equivalent to %_<foo>, x(test) is equivalent
  to %_<test>, etc.
 
  See also: setx(), lvars(), setq(), setr(), r().
 
& XVARS()
  Function:  xvars(<list of variables>,<list of strings>[,<delim>])
 
  This side-function takes the list of strings, and sets each string into 
  the corresponding variable from the list. If <list of strings> is empty,
  then all variables in the list will be unset. If <delim> is specified, the
  list of strings is considered to be <delim>-separated; the list of
  variables is always space-separated. 
 
  Example:
    > say [xvars(foo bar baz,apple peach cherry)][x(foo)]-[x(bar)]-[x(baz)]
    You say "apple-peach-cherry"
    > say [xvars(foo bar baz,apple|peach|cherry,|)][x(bar)]
    You say "peach"
 
  See also: x(), setx(), let(), lvars(), clearvars(), regparse().
 
& LET()
  Function:  let(<list of variables>,<list of strings>,<expression>[,<delim>])
 
  This side-effect function does three things:
 
  First, it takes the list of strings, and sets each string into the
  corresponding variable from the list. If <list of strings> is
  empty, then the values of the variables will be unchanged. If <delim> is 
  specified, the list of strings is considered to be <delim>-separated;
  the list of variables is always space-separated. Then, it evaluates
  <expression>. Finally, it restores the original values of the
  <list of variables>. If <list of variables> is empty, the function
  does nothing.
 
  This is useful for temporary variable use and cleanup, as it effectively
  allows variables to be passed-by-value, and limits their scope to the
  local "block" of the let() -- it functions in a way roughly akin to the
  way localize() does for r-registers.
 
  Continued in 'help let2'.
 
& LET2
 
  Examples:
 
    > say [setx(foo,old)][x(foo)]*[let(foo z,new A,[x(z)] [x(foo)])]*[x(foo)]
    You say "old*A new*old
 
    > say [setx(a,old)]%_a - [let(a b c,1|2|3,%_a+%_b+%_c,|)] - %_a
    You say "old - 1+2+3 - old"
 
  See also: x(), setx(), regparse().
 
& LVARS()
  Function:  lvars()
 
  Returns a space-separated list of all variable names associated with
  the calling object. This is potentially computationally expensive and
  should be avoided if possible.
 
  See also: x(), setx(), lvars(), clearvars().
 
& CLEARVARS()
  Function:  clearvars()
 
  Unsets all variables associated with the calling object. This is
  potentially computationally expensive, and should be avoided if
  possible.
 
  See also: x(), setx(), lvars().
 
& PEMIT()
  Function:  pemit(<list of dbrefs>,<string>)
 
  This side-effect function sends a message to the list of dbrefs, just
  as if the command '@pemit/list <list of dbrefs>=<string>' had been
  invoked.
 
& SQL()
  Function:  sql(<SQL statement>[, <delim>][, <field delim>])
 
  This function sends a SQL statement to an external SQL database and
  returns the results. The user must be God or have the use_sql power
  (note that even having a Wizard flag is not sufficient). If there is
  a problem with executing the SQL statement, the function returns #-1.
 
  If multiple rows are returned, each row will be delimited by <delim>;
  if <delim> is not specified, a space will be used. If multiple fields
  are returned, each field will be delimited by <field delim> if specified,
  or <delim> if not, or a space by default.
 
  Note that MUSH treats parentheses and commas as special characters
  within functions. You may need to be careful about escaping special
  characters.
 
  Continued in 'help SQL2'.
 
& SQL2
 
  The nature of what constitutes a valid SQL statement will depend on
  the type of back-end SQL database. Note that the character ' is used
  for quotes around field values. Thus, if your value for a field contains
  quote marks, make sure to escape them out (use \' to do this).
 
  Example (using mSQL syntax, see 'help mSQL' for details):
 
  > @sql CREATE TABLE test( player_name char(16) not null,
         race char(8) not null, dbref_num int )
  > @sql CREATE UNIQUE INDEX idx_by_dbref ON test (dbref_num)
  > @sql INSERT INTO test (player_name, race, dbref_num)
         VALUES('Nos', 'Vampire', 4)
  > @sql INSERT INTO test VALUES('Rufus', 'Werewolf', 672)
  > @sql INSERT INTO test VALUES('Caine', 'Vampire', 389)
 
  (The above commands all output, "SQL query touched 1 row.")
  
  Continued in 'help SQL3'.
 
& SQL3
 
  (Example continued)
 
  > SELECT player_name, dbref_num FROM test WHERE race='Vampire'
  Row 1, Field 1: Nos
  Row 1, Field 2: 4
  Row 2, Field 1: Caine
  Row 2, Field 2: 389
 
  > &VAMPS me = SELECT player_name, dbref_num FROM test WHERE race='Vampire'
                ORDER BY player_name
  > say [sql(v(VAMPS))] -- [sql(v(VAMPS),|)]
  You say "Caine 389 Nos 4 -- Caine|389|Nos|4"
 
  > @sql UPDATE test SET race='Vampire' WHERE dbref_num=672
  SQL query touched 1 row.
 
  > say [sql(v(VAMPS),|,)] -- [sql(v(VAMPS),|,/)]
  You say "Caine 389|Nos 4|Rufus 672 -- Caine/389|Nos/4|Rufus/672"
 
  Continued in 'help SQL4'.
 
& SQL4
 
  Because connectivity between the MUSH and the external SQL database is
  not guaranteed (there could be network issues, issues with the database
  server, etc., and no atomic way to test to ensure that connectivity is
  up and functioning), one must be careful to check for the #-1 return
  code (which indicates an error, including possibly the database 
  connection being unavailable) when reading or writing data from the
  external SQL database.
 
  This functionality is most useful if you have a need to export MUSH
  data to the outside world, or vice versa. You should NOT use the
  external database as the preferred storage mechanism; for the vast
  majority of MUSH applications, the game's own internal database
  access is significantly faster. Indeed, because of this, if you have
  data in the SQL database that you use very frequently within the
  game, you should store that data within the game as well, and simply
  mirror it to the SQL database as it changes.
 
& REMIT()
  Function:  remit(<list of dbrefs>,<string>)
 
  This side-effect function sends a message to the list of dbrefs, just
  as if the command '@pemit/list/contents <list of dbrefs>=<string>' had
  been invoked.
 
  The function takes its name from the '@remit' command, which is an
  alias for '@pemit/contents'.
 
& SQUISH()
  Function:  squish(<string>[,<character>])
 
  This function will trim multiple occurrences of <character> (or a space, if 
  <character> is not specified) down to a single occurrence of <character>.
  This is useful for getting rid of big internal spaces, and the like.
 
  Examples:
    > @force me=@va me=Test\[space(5)\]Test   (which becomes 'Test     Test')
    > say squish(%va)
    You say "Test Test"
    > say squish(---ack-----oof---,-)
    You say "-ack-oof-"
 
  See also:  trim()

& TRIM()
  Function: trim(<string> [,<trim style> [,<trim character>]])
 
  This function will trim trailing and/or lead characters on the string
  that you specify.  <trim character> specifies the character to trim (default
  is space), and <trim style> tells the kind of trimming to perform (default
  is trim both sides of the string).
 
  The following values for <trim style> are recognized:
      'b' :   Trim both ends of the string (default)
      'l' :   Trim the left end of the string.
      'r' :   Trim the right end of the string.
  Note: anything else specified for <trim style> will trim both sides.
 
  Example:
    > say trim(;;;Wacka;;;,b,;)
    You say "Wacka"
    > say trim(%b%b%b Polly Parrot %b%b%b%b,r)
    You say "    Polly Parrot"
    > say trim(---Trim Rules!---,l,-)
    You say "Trim Rules!---"
  See also: center(), ljust(), rjust().

& CENTER()
  Function: center(<string>,<width>[,<fill>])
 
  This function will center a string in a string <width> characters wide,
  using <fil> characters for padding on either end of the string for
  centering.  If no fill character is specified then a space is used.
  If <string> is longer than <width> characters, the string is returned
  unmodified.
 
  Example:
    > say center(a,5,-)
    You say "--a--"
    > say center(*BAMF*,15)
    You say "    *BAMF*     "

& INSERT()
  Function: insert(<list>, <pos>, <word>[, <sep>])
 
  This function inserts a word into <list> so that the word becomes the
  <pos>'th element of the list, and all subsequent list elements are moved
  down.  This means that it appears between the <pos-1>'th and <pos>'th
  elements of the original list.  This function may not be used to append
  a word to a list.
 
  <delim> may be used to specify a delimiter other than a space.
 
  Examples:
    > say insert(This is a test, 4, new)
    You say "This is a new test"
    > say insert(Yet@Another@List, 3, Funky, @)
    You say "Yet@Another@Funky@List"
  See also: extract(), ldelete(), replace().

& REPLACE()
  Function: replace(<list>, <pos>, <word>[, <sep>])
 
  This function inserts a word into <list> so that the word becomes the
  <pos>'th element of the list, and the word previously in that position
  is removed.  This means that it appears between the <pos-1>'th and
  <pos+1>'th elements of the original list, replacing the word at that
  position.  This function may not be used to append a word to a list.
 
  <delim> may be used to specify a delimiter other than a space.
 
  Examples:
    > say replace(This is a test, 4, quiz)
    You say "This is a quiz"
    > say replace(Yet@Another@Mundane@List, 3, Funky, @)
    You say "Yet@Another@Funky@List"
  See also: extract(), insert(), ldelete().

& LDELETE()
  Function: ldelete(<list>, <pos>[, <sep>])
 
  This function removes a word from <list> by position.
  <delim> may be used to specify a delimiter other than a space.
 
  Examples:
    > say ldelete(This is not a test, 3)
    You say "This is a test"
    > say ldelete(Yet@Another@Mundane@List, 3, @)
    You say "Yet@Another@List"
  See also: extract(), insert(), replace().

& ISDBREF()
  Function: isdbref(<string>)
 
  This function will return 1 if the string passed to it is a valid dbref.
  To be a valid dbref the string must begin with '#' and be followed by an
  integer.  Also, the dbref must exist in the current database as a valid
  object.  If the object fails either of these criteria, then a 0 is
  returned.
 
  Example:
     > say isdbref(#-1)
     You say "0"
     > say isdbref(#1)
     You say "1"
     > say isdbref(This is not a dbref)
     You say "0"

& ISNUM()
  Function: isnum(<string>)
 
  This function will return 1 if the argument is a valid number and 0
  if it is not.
 
  Example:
     > say isnum(22223.0000)
     You say "1"
     > say isnum(77)
     You say "1"
     > say isnum(22 L)
     You say "0"
     >say isnum(Bad Numbers!)
     You say "0"

& ISWORD()
  Function: isword(<string>)
 
  This function will return 1 if every character in <string> is a letter,
  and 0 if this is not true.
 
  Example:
     > say isword(Test)
     You say "1"
     > say isword(Test123)
     You say "0"

& FOREACH()
  foreach([<object>/]<attribute>,<string>[,<start token>][,<end token>])
 
  Maps a function onto a string.
 
  Each character in <string> has the user-defined function of the first
  argument performed on it; the character is passed to the function as
  %0. The results are concatenated.
 
  If <start token> is specified, only characters that occur after that
  single-character token will be evaluated, though characters prior to
  that will be copied. If <end token> is also specified, characters that
  occur after that single-character token will not be evaluated, though
  they will be copied. The tokens themselves are not copied.
 
  Continued in 'help foreach2'.
 
& FOREACH2
  The tokens can be alternated, so that things not between them are
  copied but not evaluated. The tokens can also be the same character.
  Note that only the occurrence of the tokens in their specific start
  and end contexts will cause them to be skipped. This means, for
  example, if an end token is encountered before a start token is
  encountered, the end token will be copied as-is.

  Examples:
 
    > &add_one me=[add(%0,1)]
    > say [foreach(add_one, 54321)]
    You say "65432"
    > say [foreach(add_one,12<34>56,<,>)]
    You say "124556"
    > say [foreach(add_one,12#34#56,#)]
    You say "1245167"                        [The add() counts '#' as '0'.]
    > say [foreach(add_one,12<34>56,#,>)]
    You say "12<34>45"
  
& MIX()
 
  mix([<object>/]<attribute>,<list 1>,<list 2>[,<list N>][,<delim>])
 
  This function is similar to MAP(), except that it takes the elements
  of several lists, one by one, and passes them to the user-defined function
  as %0, %1, %2, etc.respectively, for elements of <list 1>, <list 2>, etc.
  <delim> is used to separate elements; if it is not specified, it defaults
  to a space. The lists do not need to have the same number of elements;
  shorter lists will be padded out with nulls. If more than two lists are
  specified, the last argument MUST be a delimiter.
  
  Examples:
 
  > &add_nums me=[add(%0,%1)]
  > say [mix(add_nums,1 2 3 4 5,2 4 6 8 10)]
  You say "3 6 9 12 15"
  > say [mix(add_nums,1:3:5:7,0:2:4:6,:)]
  You say "1:5:9:13"
 
  > &add_nums me=[add(%0,%1,%2,%3,%4)]
  > say [mix(add_nums,1 2,3 4,5 6,7 8,9 10,)]
  You say "25 30"
 
& STEP()
  step([<object>/]<attribute>,<list>,<step size>[,<delim>[,<output delim>]])
 
  This function takes elements of <list>, <step size> elements at a time,
  and passes them to the function defined by <attribute>, as %0, %1, %2,
  etc. The number of elements in the list does not need to be evenly
  divisible by the step size. If no delimiters are provided, a space is
  used as the delimiter. The step size must be at least 1, and no greater
  than 10. Calling this function with a step size of 1 is equivalent to
  using map().
 
  Example:
 
    > &print_line me = %r%0 -- %1 -- %2
    > say [step(print_line,1 2 3 4 5 6 7 8,3)]
    You say "
    1 -- 2 -- 3
    4 -- 5 -- 6
    7 -- 8 --"
 
& DOING()
  doing(<player name>)
 
  This function returns the @doing string of a connected player. If the
  player does not exist, or is not connected, this function returns an
  empty string.
 
& PROGRAMMER()
  programmer(<player name>)
 
  This function returns the dbref of the object which is calling a @program
  on a player, where the player is specified by player name or by dbref.
  If the target player is not connected, or is not in a @program, this
  function returns #-1. You must be able to examine the player, or
  this function returns #-1.
 
& PORTS()
  ports(<player name>)
 
  This function returns the list of descriptors ("ports") that a player,
  specified by full player name, or by dbref, is connected to. Only Wizards
  may use this function; if a user lacks the privileges, or the player is
  not connected, an empty list is returned. Otherwise, a list of ports is
  returned in order of most recent connection to least recent connection.
  These ports correspond to those given by the SESSION command.
  
& HASATTR()
  hasattr(<object>,<attribute>)
 
  Returns '1' if <object> has named <attribute> (and the attribute can be
  seen by the invoker), or 0 if not. If the specified object is invalid,
  "#-1 NO MATCH" will be returned. Note that this does not check the
  <object>'s parents for the presence of the attribute; use hasattrp()
  to do that.
 
& SORTBY()
  sortby([<obj>/]<attrib>,<list>[,<delimiter>][,<output delim>])
 
  This sorts an arbitrary list according to the u-function <obj>/<attrib>.
  This u-function should compare two arbitrary elements, %0 and %1, and
  return zero (equal), a negative integer (element 1 is less than element 2)
  or a positive integer (element 1 is greater than element 2).
 
  A simple example, which imitates a normal alphabetic sort:
    > &ALPHASORT test=[comp(%0,%1)]
    > say [sortby(test/ALPHASORT,foo bar baz)]
    You say "bar baz foo"
 
  A slightly more complicated sort. #1 is "God", #2 is "Amby", "#3" is "Bob":
    > &NAMESORT me=[comp(name(%0),name(%1))]
    > say [sortby(NAMESORT,#1 #2 #3)]
    You say "#2 #3 #1"
 
  Warning: the function invocation limit applies to this function. If
  this limit is exceeded, the function will fail _silently_. List and
  function sizes should be kept reasonable.
 
& MUNGE()
  munge([<object>/]<attribute>,<list 1>,<list 2>[,<delim>][,<output delim>])
  
  This function takes two lists of equal length. It passes the entirety of
  <list 1> to the user-defined function as %0. Then, this resulting list
  is matched with elements in <list 2>, and the rearranged <list 2> is
  returned. This is useful for doing things like sorting a list, and then
  returning the corresponding elements in the other list. If a resulting
  element from the user-defined function doesn't match an element in the
  original <list 1>, a corresponding element from <list 2> does not appear
  in the final result.
 
  For example: Consider attribute PLACES, which contains "Fort Benden Ista",
  and another attribute DBREFS, which contains the dbrefs of the main JUMP_OK
  location of these areas, "#20 #9000 #5000". We want to return a list of
  dbrefs, corresponding to the names of the places sorted alphabetically. The
  places sorted this way wouuld be "Benden Fort Ista", so we want the final
  list to be "#9000 #20 #5000". The functions, using munge(), are simple:
 
  > &sort_alpha me=[sort(%0)]
  > say [munge(sort_alpha,v(places),v(dbrefs))]

& ALPHAMAX()
  Function: alphamax(<string1>, <string2>, ..., <stringN>)
 
  Takes up to ten strings, and returns the string which is 
  lexicogrpahically biggest.
 
& ALPHAMIN()
  Function: alphamin(<string1>, <string2>, ..., <stringN>)
 
  Takes up to ten strings, and returns the string which is 
  lexicogrpahically smallest.
 
& ART()
  Function: art(<string>)
 
  This function returns the proper article, "a" or "an", based on
  whether or not <string> begins with a vowel.
 
& BEEP()
  Function: beep()
 
  This function simply outputs the beep charater, which will "ring the
  bell" on terminals with sound. Only Wizards may use this function.
 
& CASE()
  Function: case(<str>[,<pat1>,<res1>]...[,<dflt>])
 
  This function is similar to switch(), save that it looks for an exact
  match between the patterns and the string, rather than doing a 'wildcard'
  match (case-insensitive match with '*' and '?'), and the '#$' token
  replacement is not done. It performs marginally faster than switch().
 
  See also:  @switch, switch(), ifelse(), match().
 
& CHILDREN()
  Function: children(<object>)
 
  This function returns a list of objects that are parented to <object>.
  It may only be used by Wizards or Royalty.
 
& COLUMNS()
  Function: columns(<list>, <width>[, <delim>[, <indent>]])
 
  This function displays <list> formatted into columns <width>-characters
  wide; i.e., each element of <list> will appear in a column <width> wide.
  As many columns as possible will be fit onto the screen, which is
  considered to be 78 characters wide; thus, you can calculate the number
  of columns that will appear by dividing 78 by <width>.
 
  If a string is too long for the width of a column, the string will
  be truncated to fit.
 
  If <indent> is specified, each line will be indented by that number
  of spaces.
 
  If <delim> is specified, it will be as an input delimiter only; i.e.,
  the delimiter will be used to separate the elements of the list, but
  will not appear in the output.
 
& COMMAND()
  Function: command(<command>[,<arg 1>[,<arg 2>]])
 
  This function executes <command> with the given arguments. <command>
  is presently limited to @chown, @clone, @destroy, @link, @lock, @name,
  @parent, @teleport, @unlink, @unlock, and @wipe.
 
  For example, to get the equivalent of '@name object = new', you
  would use '@eval command(@name,object,new)'.
 
  If you have overridden any of these commands via @addcommand, you
  will not be able to access that command via this function.
 
& CREATE()
  Function: create(<object name>, <cost>[, <type>])
 
  This creates an object named <object name>, with the specified <cost>.
  This object is normally a thing. If the optional <type> parameter is
  'r', it will be a room; if it is 'e', an exit; it assumed to default
  to 't', thing.
 
  'create(<object>,<cost>,t)' is equivalent to '@create <object>=<cost>'.
  'create(<object>,<cost>,r)' is equivalent to '@dig <object>'.
  'create(<object>,<cost>,e)' is equivalent to '@open <object>'.
 
  See also: @create, @dig, @open
 
& CWHO()
  Function: cwho(<channel>)
 
  If the comsys is enabled, this function returns a list of dbrefs
  of players who are connected, and on that channel. <channel> is
  the full name of the channel, and is case-sensitive. This function
  is limited to Wizards and channel owners.

& DECRYPT()
  Function: decrypt(<text>,<key>)
 
  Decrypts <text> using <key>. <key> should be the same one used to encrypt
  the text, and is case sensitive.
 
& ENCRYPT()
  Function: encrypt(<text>,<key>)
 
  Encrypts <text> using <key>. The text can only be unlocked with <key>, and
  <key> is case-sensitive.
 
& EVAL()
  Function: eval(<object>,<attribute)
            eval(<string>)
 
  The first form of this function is identical to get_eval(), but
  splits the <object> and <attribute> into two arguments, rather
  than having an <object>/<attribute> pair. It is provided for
  PennMUSH compatibility.
 
  The second form of this function simply evaluates <string>.
 
& GREP()
  Function: grep(<object>, <attrs>, <string>)
 
  This function returns a list of attributes on <object>, which
  contain <string>. <attrs> is a wildcard attribute pattern; to
  search all attributes on the object, use '*'.
 
  Please note that this function does parse its arguments; thus,
  any 'special' characters in <string> need to be escaped out.
 
  <string> is case-sensitive; for a case-insensitive search, use
  grepi() instead.
 
& GREPI()
  Function: grepi(<object>, <attrs>, <string>)
 
  This function is identical to grep(), but <string> is searched for
  in a case-insensitive manner.
 
& HASATTRP()
  Function: hasattrp(<object>, <attribute>)
 
  Returns '1' if <object> or its parent(s) has the named <attribute>
  (and the attribute can be seen by the invoker), or 0 if not. If the
  specified object is invalid, "#-1 NO MATCH" will be returned.
  To check only the object itself for the attribute, use hasattr()
  instead.
 
& HASPOWER()
  Function: haspower(<object>, <power>)
 
  Returns 1 if <object> has the power <power> set on it, and 0 otherwise.
  You must be able to examine <object>.
 
& HASTYPE()
  Function: hastype(<object>, <type>)
 
  Returns 1 if <object> is of type <type>, and 0 otherwise. Valid
  types are: ROOM, EXIT, THING, and PLAYER. If an invalid type is
  given, the function returns #-1.
 
& INZONE()
  Function: inzone(<object>)
 
  Returns a list of room dbrefs, in the zone defined by <object>.
  This function can only be used by Wizards and Royalty.
 
& LPARENT()
  Function: lparent(<object>)
 
  This function returns the list of dbrefs of the object's "parent
  chain", including itself: i.e., its own dbref, the dbref of the
  object it is @parent'd to, its parent's parent (grandparent),
  and so forth. Note that the function will always return at least one 
  element, the dbref of the object itself.
 
  This function will not show the parents of objects that the player
  cannot examine.
 
& PLAYMEM()
  Function: playmem(<player>)
 
  Returns the sum total of the size, in bytes, of all objects in the 
  database that are owned by <player> (equivalent to doing an objmem()
  on everything that player owns). You must be a Wizard, or have the
  Search power, in order to use this on another player.
 
& PMATCH()
  Function: pmatch(<player>)
 
  Given the partial name of a player, it returns that player's dbref
  number. This partial name completion works identically to the partial
  name completion of the "page" command - i.e. it first attempts to match
  the normal names of all players (connected or not), and if that fails,
  it tries to match the partial names of connected players. If no player
  is matched, it returns "#-1". If more than one match is possible for
  a partial name, it returns "#-2".
 
  pmatch() will also accept *<player> or #<dbref>. If given a non-player
  dbref, pmatch() will return #-1.
 
& PFIND()
  Function: pfind(<object>)
 
  If <object> is a dbref, if the dbref is valid, that dbref will be returned.
  If the dbref is not valid, #-1 will be returned.
 
  If given the name of a player (NOT preceeded by a '*'), the player name
  will be looked up. This includes checking the connected players that 
  the caller can see on the WHO list, for partial matches to the name. If
  the entire player name is found, or a unique partial match is found, the
  dbref of that player will be returned. Otherwise, #-1 NO MATCH will be
  returned.
 
& STRCAT()
  Function: strcat(<string1>, <string2>, ..., <stringN>)
 
  Concatenates between two and ten strings together, with no spaces
  between them. This function is provided for PennMUSH compatibility.
 
  Example:
    > say [strcat(foo,bar,baz)]
    You say "foobarbaz"
 
& STRTRUNC()
  Function: strtrunc(<string>, <number>)
 
  This function truncates <string> to a length of <number> characters.
  If <number> is greater than the length of <string>, this simply
  returns <string>.
 
  See also: mid(), delete(), left(), right()
 
& VALID()
  Function: valid(<option>, <string>)
 
  This function returns 1 if <string> is valid for <option>, and 0
  if it is not.
 
  Currently, the only valid <option> is "name"; if <string> is a valid
  object name, this function will return 1, and 0 if it is not.
 
  If a valid option is not specified, this function returns #-1.
 
  This function is provided for PennMUSH compatibility.
 
& XGET()
  Function: xget(<object>, <attribute>)
 
  This function is identical to get(), except that it breaks <object>
  and <attribute> into two separate arguments, rather than having
  <object>/<attribute>.
 
  This function is provided for PennMUSH compatibility.
 
& ZFUN()

  Undocumented.
 
& ZONE()
  Function: zone(<object>)
 
  Returns the dbref of <object>'s zone (the dbref of the master object
  which defines the zone).
 
& ZWHO()
  Function: zwho(<object>)
 
  Returns a list of the dbrefs of players who are in the zone defined
  by <object>. This function can only be used by Wizards and Royalty.
 
& CHOMP()
  Function: chomp(<string>)
 
  If <string> ends with a carriage-return/newline ('%r'), that trailing
  carriage-return/newline will be chopped off. This is particularly useful
  for nibbling extra newlines off piped ('%|') output.
 
& FORCE()
  Function: force(<object>, <action>)
 
  This side-effect function behaves identically to the command
  '@force <object>=<action>'.
 
  Note that <action> is threaded normally onto the command queue, and
  is thus not instantaneously executed.
 
& NULL()
  Function: null(<string>)
 
  This function returns an empty string, effectively "eating" <string>.
  This is useful if you're doing something involving side-effects and
  want to obliterate that output.
 
& TRIGGER()
  Function: trigger(<object>/<attribute>,<arg 0>,<arg 1>,...,<arg N>)
 
  This side-effect function behaves identically to the command
  '@trigger <object>/<attribute>=<arg 0>,<arg 1>,...<arg N>'
 
  Note that the triggered actions are threaded normally onto the command
  queue, and are thus not instantaneously executed.
 
& WAIT()
  Function: wait(<timer>,<command>)
 
  This side-effect function behaves identically to the command
  '@wait <timer>=<command>'. See 'help @wait' for the possible forms
  that <timer> can take.
  
& WHILE()
  while([<uobj>/]<uattr>,[<cobj>/]<cattr>,<list>,<str>[,<delim>[,<output d>]])
 
  This function evaluates the elements of <list>, until a termination
  condition is reached or the end of the list is reached.
 
  [<uobj>/]<uattr> is an attribute or object/attribute pair, like the first
  argument of map(). The <list> is passed to that function element-by-element
  (based on the input <delim> delimiter) as %0, just as if map() were being
  called, and the output is returned <output d>-delimited, again just as if
  map() were being called.
 
  However, for each element, after that evaluation is done, a second
  evaluation is done, to check a "termination value". [<cobj>/]<cattr>
  is an attribute or object/attribute pair, again like map(), and the
  same list elements are passed to that function as %0. However, the
  result of this evaluation is not kept; instead, it is compared to
  <str>, and if it matches exactly (case-sensitive, no wildcards),
  the no further elements of the list are processed.
 
  Continued in 'help while2'.
 
& WHILE2
 
  If the contents of [<uobj>/]<uattr> and [<cobj>/]<cattr> are the
  same, the element is not evaluated twice; the result of the first
  evaluation is directly compared against <str>. (Note that the
  two object/attributes don't have to be the same -- just their
  contents need to be the same, since this function treats the
  pair like map(), not like u().)
 
  Examples:
    > &EVAL_FN me = [reverse(%0)]
    > &COND_FN me = [strlen(%0)]
    > say [while(EVAL_FN,COND_FN,foo bar meep flibble baz,4)]
    You say "oof rab peem"
    > SAY [while(EVAL_FN,COND_FN,foo|bar|meep|flibble|baz,4,|,-)]
    You say "oof-rab-peem"
 
& PUSH()
  Function: push([<object>,]<data>)
 
  Pushes an item (the arbitrary string <data>) onto the top of an
  object's stack. If <object> is not specified, the calling object is
  assumed. An empty string is returned.
  
  For example, if the current stack is (top to bottom) 4, 3, 2, 1,
  and a 'push(5)' is used, the new stack becomes 5, 4, 3, 2, 1.
 
  See also: STACK FUNCTIONS.

& DUP()
  Function: dup([<object>,][<position>])
 
  Duplicates an item from <object>'s stack, placing it on top of the
  stack. If <object> is not specified, the calling object is assumed.
  If <position> is not specified, the top item is assumed. Positions
  are counted from top to bottom, starting from zero.
 
  Example:
    > say [lstack()]
    You say "5 4 3 2 1"
    > say [dup()][lstack()]
    You say "5 5 4 3 2 1"
    > say [dup(me,4)]
    You say "2 5 5 4 3 2 1"
 
  See also: STACK FUNCTIONS.

& SWAP()
  Function: swap([<object>])
 
  Swaps the top two items on <object>'s stack. If <object> is not
  specified, the calling object is assumed. The stack must have
  at least two items on it. This function returns an empty string.
 
  Example:
    > say [lstack()]
    You say "4 3 2 1"
    > say [swap()]
    You say "3 4 2 1"
 
  See also: STACK FUNCTIONS.

& POP()
  Function: pop([<object>,]<position>)
 
  Pulls an item from <object>'s stack. If <object> is not specified, the
  calling object is assumed. If <position> is not specified, the top item
  is popped off. Otherwise, the item in <position> (counting down from the
  top item being position 0) is pulled. The function returns that item.
 
  Example:
    > say [lstack()]
    You say "6 5 4 3 2 1"
    > say [pop()]
    You say "6"
    > say [lstack()]
    You say "5 4 3 2 1"
    > say [pop(me,3)]
    You say "2"
    > say [lstack()]
    You say "5 4 3 1"
  
  See also: popn(), STACK FUNCTIONS.

& POPN()
  Function: popn(<object>,<position>,<N items>[,<delim>])
 
  Pulls one or more items from <object>'s stack, returning the value
  of those items in a <delim>-separated list. If <delim> is not
  specified, a space is assumed.
 
  See also: pop(), STACK FUNCTIONS.
 
& TOSS()
  Function: toss([<object>,]<position>)
 
  Silently removes an item from <object>'s stack. Essentially, it behaves
  identically to pop(), except that it always returns an empty string,
  instead of the value of that item on the stack.
 
  Example:
    > say [lstack()]
    You say "6 5 4 3 2 1"
    > say [toss()]
    You say ""
    > say [lstack()]
    You say "5 4 3 2 1"
    > say [toss(me,3)]
    You say ""
    > say [lstack()]
    You say "5 4 3 1"
 
& EMPTY()
  Function: empty([<object>])
 
  Empties the stack on <object>, clearing all items from it. If <object>
  is not specified, the calling object is assumed. This function returns
  an empty string.
 
  See also: STACK FUNCTIONS.
 
& LSTACK()
  Function: lstack([<object>][,<delim>])
 
  This function returns the items on <object>'s stack in the form of
  a <delim>-separated list. The items are returned in top-to-bottom
  order. If <object> is not specified, the calling object is assumed.
  If <delim> is not specified, a space is assumed. This function does
  not modify the stack.
 
  See also: STACK FUNCTIONS.

& ITEMS()
  Function: items([<object>])
 
  This function returns the number of items in <object>'s stack. If
  <object> is not specified, the calling object is assumed.
 
  See also: STACK FUNCTIONS.

& PEEK()
  Function: peek([<object>][,<position>])
 
  This function returns the value of an item on <object>'s stack.
  If <object> is not specified, the calling object is assumed. If
  <position> is not specified, the top item is assumed. Positions
  are counted down from the top, with the top item being position
  zero; i.e., the second item on the stack is position 1, and so
  forth. This function does not modify the stack.
 
  Example:
    > say [lstack()] -- [peek()]
    You say "5 4 3 2 1 -- 5"
    > say [peek(me,3)]
    You say "2"
    > say [lstack(Object)] -- [peek(Object)]
    You say "c b a -- c"
 
  See also: STACK FUNCTIONS.

& @power

  Command: @power <object>=[!]<power>
 
  This is a command that allows the granting of special powers to objects of
  any type.
 
  See also: powers list
  
& powers list
 
  announce		Can use the @wall command.
  boot			Can use the @boot command.
  builder		Can build, if the builder power is enabled.
  chown_anything	Can @chown anything to anyone.
  comm_all		Like a wizard with respect to channels.
  control_all		Can modify any object in the database. (God-set only.)
  expanded_who		Sees the wizard WHO, and SESSION commands.
  find_unfindable	Can locate unfindable people.
  free_money		Unlimited money.
  free_quota		Unlimited quota.
  guest			Is this a guest character?
  halt			Can @halt anything, and @halt/all.
  hide			Can set themselves DARK.
  idle			No idle timeout.
  link_variable		Can @link an exit to "variable".
  link_to_anything	Can @link to any (non-variable) destination.
  long_fingers		Can get, look, whisper, etc from a distance.
 
{ 'help powers list2' for more }
 
& powers list2
 
  monitor		Can set or reset monitor flag.
  no_destroy		Cannot be @toad'ed.
  open_anywhere		Can @open an exit from any location.
  poll			Can set the @poll.
  prog			Can use @program on players other than themself.
  search		Can @search anyone.
  see_all		Can examine and see attributes like a wizard.
  see_hidden		Can see hidden (DARK) players on WHO, etc.
  see_queue		Can @ps/all or @ps any player.
  stat_any		Can @stat any player.
  steal_money		Can give negative money.
  tel_anywhere		Can teleport anywhere.
  tel_anything		Can teleport anything (includes tel_anywhere)
  unkillable		Cannot be killed with the 'kill' command.
  use_sql		Can call the SQL() function. (God-set only.)
 
  See also: @power
 
& comsys
 
  Commands for the MUSH comsystem:
 
  addcom	allcom		comlist		comtitle	clearcom
  delcom
 
  @cboot	@ccreate	@cdestroy	@cemit		@channel
  @clist	@cwho
 
  See 'help comsys intro' for an introduction ot the comsys.
  See 'help comsys aliases' for details on how to use comsys aliases.
  See 'help <name of command>' for details on specific commands.
 
& comsys intro
 
  Topic: COMSYS INTRO
 
  Depending on the configuration of the MUSH, there may be public and
  private chat channels available. Normally, new players automatically
  join the "Public" channel upon creation (default alias 'pub'), while
  guest characters join the "Guests" channel when they connect (default
  alias 'g').
 
  Each player may associate a given channel with one or more aliases.
  Typically, one talks on a channel using '<alias> <message>'. For
  example, the default alias for the Public channel is normally 'pub',
  allowing you to type 'pub Hello.' to say "Hello." to everyone on
  the Public channel. However, if you want your alias to be something
  else, you can change it.
 
  Channels can be used by both players and things, though there can be
  restrictions placed on who can join, receive, and transmit on a channel.
  These restrictions can be imposed by object type, or they can be locks.
 
  Continued in 'help comsys intro2'.
 
& comsys intro2
 
  The comsys commands you will find most useful are the following:
 
  '@clist'        -- Lists all available channels.
  'comlist'       -- Lists all the channels you are on, and their aliases.
                     Channel names and aliases are case-sensitive. You
                     can have more than one alias for a channel.
  '<alias> who'   -- Lists the people on the channel associated with <alias>.
                     For example, if your Public channel alias is 'pub', then
                     'pub who' will list everyone on the Public channel.
  '<alias> on'    -- Begin listening to the channel associated with <alias>.
  '<alias> off'   -- Stop listening to the channel associated with <alias>.
  '<alias> <msg>' -- Say a message to the channel associated with <alias>.
                     The ':' and ';' pose-tokens can be used.
 
  You can add an alias using 'addcom <alias>=<channel>'; if this is the
  first alias you have for that channel, you will automatically join that
  channel. You can remove an alias using 'delcom <alias>'; if this is the
  only alias you have for that channel, you will automatically leave it. 
 
  Continued in 'help comsys intro3'.
 
& comsys intro3
  
  For example:
 
  > pub off
  You leave channel Public.
 
  > pub on
  [Public] Foobar has joined this channel.
 
  > pub who
  -- Players --
  Foobar(#23PWc)
  Wizard(#1PWc)
  -- Objects --
  -- Public --
 
  > pub Hello world!  
  [Public] Foobar says, "Hello world!"
 
See the individual help entries for comsys commands for details.
 
& @cboot
 
  Command: @cboot[/quiet] <channel>=<object>
 
  This command is restricted to Wizards, those with the Comm_All power,
  and the owner of <channel>. It removes <object> from <channel>,
  deleting all of <object>'s alias for <channel>. <object> can be
  specified as a dbref, *<player>, or the name of a nearby object.
 
  The object will be notified who booted it off the channel. Other
  people on the channel will also be notified that you have booted
  the object off the channel, unless the /quiet switch is specified,
  in which case, it will be treated like the object had simply left
  the channel.
  
& addcom
 
  Command: addcom <alias>=<channel>[,<title>]
 
  This command adds <alias> as an association for <channel>; if you
  specify <title>, messages to that channel using that alias will
  prefix <title> to your name. You can have multiple aliases for a
  channel. You can have different titles for each aliases.
 
  If this is your first alias for <channel>, you will join <channel>.
  Note that the on/off status of <channel> is not affected by adding
  additional aliases.
 
  See also: delcom, comlist, comtitle, comsys aliases.
 
& comsys aliases
 
  Command: <channel alias> <on|off|who|message|:pose|;pose>
   
  If you select 'on', you will begin listening to messages on the channel
  associated with <alias>.
 
  If you select 'off', you will stop listening to messages on the channel
  associated with <alias>. However, that alias remains active and useful
  for other comsystem commands.
 
  If you select 'who', you will be shown a list of players and objects
  currently active on the channel associated with <alias>.
 
  You may send a message over the channel with <alias> <text>, where <text>
  is the message to be sent; you can pose on a channel with <alias> :<text>
  or <alias> ;<text>
  
  See also: allcom, comlist, addcom, delcom.
 
& allcom
 
  Command: allcom <on|off|who>
         
  This works like using a single alias, except it does an action for every
  alias you have. You can turn every alias on, or off, or see who is on
  every channel you subscribe to. 
  
  See also: comsys aliases, comtitle, delcom, addcom.
 
& comlist
 
  Command: comlist
 
  Displays all of your comsystem aliases, the channels that they are
  associated with, and whether or not you are 'on' (listening) to each
  of them. It also shows the titles associated with each alias.
  
  See also: comtitle, addcom, comsys aliases, delcom.
 
& comtitle
 
  Command: comtitle <alias>=<title>
 
  This command allows you to prefix your name on a channel with a title.
  Titles are associated with specific aliases, so if you have multiple
  aliases associated with a single channel, you can have different titles
  for each alias.
 
  For example:
  > comtitle pub=The Great and Powerful
  Title set to 'The Great and Powerful' on channel Public.
  > pub :waves to everyone.
  [Public] The Great and Powerful Foobar waves to everyone.
 
  See also: comlist, addcom, comsys aliases, delcom.
 
& clearcom
 
  Command: clearcom
 
  Removes all your aliases for channels. You should be extremely careful
  about this command, as it will wipe out all of your channel information.
  
  See also: addcom, delcom.
 
& delcom
 
  Command: delcom <alias>
 
  Deletes <alias> from your list of channel aliases. If <alias> was the only
  alias you had for a certain channel, you will leave that channel, and
  will need to addcom a new alias for it, if you need to use it in the
  future.
  
  See also: addcom, comlist, clearcom.
 
& @ccreate
 
  Command: @ccreate <channel name>
 
  Creates a channel with default settings. Only Wizards and those with
  the Comm_All power can create a channel.
   
  See also: @cdestroy, @clist, @channel.
 
& @cdestroy
 
  Command: @cdestroy <channel>
 
  Deletes <channel> permanently from the comsystem database. This removes
  all aliases that are associated with <channel>.
 
  See also: @clist, @ccreate, @channel.
 
& @clist
 
  Command: @clist[/full] [<channel name>]
 
  When given an argument, if you are a Wizard, have the Comm_All power,
  or the owner of the channel, this will display the flag information,
  locks, and description of the channel.
 
  Without any switches or arguments, this command will display the list of
  channels, together with the names of their owners, and their descriptions.
  With the /full switch, this command will display the list of channels,
  together with some more detailed information about them. The channels
  displayed are limited to Public ones, unless you are a Wizard or have
  the Comm_All power.
 
  See also: @ccreate, @cdestroy, @channel.
 
& @cwho
 
  Command: @cwho[/all] <channel>
 
  If you are a Wizard, have the Comm_All power, or own <channel>, this
  command displays a list of all objects and connected players on the
  channel. If the /all switch is specified, all objects and players
  are displayed. Note that the connect status of hidden players is
  protected.
 
  See also: @clist.
 
& @channel
  @channel/owner <channel>=<new owner>
  @channel/charge <channel>=<charge>
  @channel/desc <channel=<description>
  @channel/set <channel>=[!]<flag>
  @channel/lock/<join | transmit | receive> <channel>=<lock>
 
  This command allows a Wizard, someone with the Comm_All power, or
  the owner of the channel, to manipulate the channel settings.
  
  Changing the channel owner is straightforward; <new owner> is specified
  as a dbref or player name.
 
  Changing the cost of sending a message on the channel is also
  straightforward; <charge> is the cost in MUSH money. Every time
  someone sends a message on the channel, that person pays <charge>
  to the channel owner.
 
  Similarly, <description> is any string of text; if none is specified,
  the channel's description is cleared.
 
  Continued in 'help @channel2'.
 
& @channel2
 
  The channel flags available are:
 
    public     -- All players see this on a @clist.
    loud       -- People on the channel see when someone on the channel
                  connects or disconnects.
    p_join     -- Any player can join this channel.
    p_transmit -- Any player can transmit on this channel.
    p_receive  -- Any player can receive on this channel.
    o_join     -- Any object can join this channel.
    o_transmit -- Any object can transmit on this channel.
    o_receive  -- Any object can receive on this channel.
 
  The available channel locks are join, transmit, and receive. They
  are specified like regular object locks. To unlock, simply specify
  a blank string for <lock>. Channel locks are evaluated with respect
  to the channel's owner.
 
  Channel flags always override channel locks. In other words, if a
  channel has a p_join flag, the join lock is never checked for players.
 
& @cemit
 
  Command: @cemit[/noheader] <channel>=<message>
 
  This command allows a Wizard, someone with the Comm_All power, or
  the owner of <channel>, to send <message> to everything listening
  to <channel>. If the /noheader switch is specified, then the channel
  name is not prepended to the message.
 
& @malias
 
  Command: @malias
  
  This allows you to generate and maintain mailing lists with the mail
  system. All mail aliases start with '*', and are case-sensitive. (*dir is
  different than *Dir).  There are two kinds of mail aliases, Personnal
  and Global. Global mailing lists are owned and maintained by the god (#1)
  char and are available for anyone to use.  Generally there will be
  *Wizards, *Admin, *Roleplay, and things of that nature.  Personal mailing
  aliases are mailing lists that you have defined with the @malias commad.
  Currently there is no limit to the number of people you can have on a
  mailing alias.
 
  To begin sending mail to a mailing list, use @mail *<alias>=subject.
  
  Usage:
  
  @malias                   Displays a list of all mail aliases.
  @malias *<alias>          Displays a list of people on that alias.
  @malias *<alias>=<list>   Creates that mailing list, using <list>.
  
  For more help, see the following help topics.  All errors can be
  sent to *Bugs, or Lauren.
 
Continued in 'help @malias2'.
 
& @malias2
 
  You can add, remove, rename, chown, redescribe, and delete mailing lists
  with a switch.
  
  @malias/remove *<alias>=<player>     Removes <player> from *<alias>.
  @malias/desc *<alias>=<description>  Changes the description for *<alias>. 
  @malias/add *<alias>=<player>        Adds <player> to *<alias>.
  @malias/rename *<alias>=<name>       Renames that alias. Names must always
                                       begin with '*'.
  @malias/delete *<alias>              Deletes <alias>.
  @malias/chown *<alias>=<player>      Changes the owner of <alias> to
                                       <player>.
 
  Wizards can use all of the malias commands on any mail alias. Instead of
  trying to figure out different mailing lists with the same name, wizards
  may use #<MALIAS NUMBER> instead of *alias in regards to the command.
  Remember that the alias commands will only recognize aliases owned by #1,
  owned by you, or by number.
  
  @malias/list                         When invoked by a wizard, it will
                                       list all mailing aliases currently
                                       defined by their number.
 
& @mail

  @mail[/<switches>] <player-list> = <subject>
  @mail[/<switches>] [<msg-list> [= <target>]]
 
  @mail invokes the built-in MUSH mailer, which allows players to send
  and receive mail. Pronoun/function substitution is performed on
  any messages you may try to send.
 
  See 'help mail-players' for an explanation of what constitutes a
  valid player list.
 
  See 'help mail-messages' for an explanation of what constitutes a
  valid message list.

  See the following topics for more details:
 
    mail-sending    mail-reading     mail-folders      mail-other
    mail-admin      @malias          mail-reviewing    mail-examples
 
& mail-players
  Topic: Mail Player Lists
 
  A <player-list> is a space-separated list of recipients, which may be:
 
        Player names (names with spaces in them should be put in double
                      quotes, ex: "Foo Bar")
 
        Player dbref #'s
 
	Message numbers to be replied to.
 
	A mix of the above, and mail aliases (see @malias)
 
& mail-messages
  Topic: Mail Message Lists
 
  A <msg-list> is one of the following:

        A single msg # (ex: 3)
 
        A message range (ex: 2-5, -7, 3-)
 
        A sender (ex: *lauren)
 
        An age of mail in days (ex: ~3 (exactly 3), <2, >1)
           "days" here means 24-hour periods from the current time.
 
        One of the following: "read", "unread", "cleared", "tagged", "urgent"
 
        For certain commands, "all".
 
& mail-reviewing
   
  @mail/review <player>
	Reviews the messages you have sent to <player>.
 
  @mail/review <player>=<msglist>
	Reads the messages you have sent to <player>.
 
  @mail/retract <player>=<msglist>
	Retracts (deletes) unread messages you have sent to <player>.
 
& mail-reading
 
  @mail <msg #>
  @mail/read <msg-list>
        This displays messages which match the msg# or msg-list from
        your current folder.
 
  @mail
  @mail <msg-list, but not a single msg #>
        This gives a brief list of all mail in the current folder,
        with sender name, a list of receiving players, subject, and
        message status.
  @mail/list [<msg-list>]
        This gives the same list, but with time sent instead of subject.
        The status field is a set of characters (ex: NC-UF+) which mean:
                N = New (unread) message
                C = Cleared message
                U = Urgent message
                F = Forwarded message
                + = Tagged message
        The opposites of these (read messages, etc.) are indicated with a
        '-' in the status field in that position.
 
& mail-sending
 
  @mail/quick <player-list>/<subject> = <message>
	Sends <message> to the list of players.
 
  @mail[/switch] <player-list> = <subject>
	This begins a message to all players in <player-list>.
	-<text> adds text to the message in progress, for example
		-This is a test
	would add the text 'This is a test' to the end of your @mail
	message, likewise, ~<text> prepends the text.
 
  @mail/send
	This sends the message that is currently in progress.
	-- is the equivalent of @mail/send. @mail/urgent sends
	the message as urgent, and should not be used often.
 
  @mail/cc <player-list>
        This replaces the currect player list with a new one for carbon
        copying. It does _not_ add onto the existing list.
 
  Continued in 'help mail-sending2'.
 
& mail-sending2
 
  @mail/proof
	This shows you the message that is currently in progress, as
	it would be read by whomever received it.
  
  @mail/edit <old text> = <new text>
	Like @edit, but edits the message in process.
 
  @mail/abort
	This aborts the message currently in progress, allowing you
	to start a new one.
 
  @mail/fwd <msg> = <player-list>
        This sends a copy of <msg> to all the players in <player-list>.
        The copy will appear to have been sent by you (not the original
        sender), and its status will be "Forwarded". Note that this places
        the message to be forwarded into your mail buffer, where you can
        edit it with @mail/edit, add text with '-', or prepend text with
        '~'. You have to use '--' or @mail/send to send the message.
 
  Continued in 'help mail-sending3'.
 
& mail-sending3
 
  @mail/reply[/quote] <msg>
	This sends a reply to the person who sent you <msg>. The
	subject line will be 'Re: <original subject line>'. If you
	specify the /quote switch, the original message will be quoted
	back at the beginning of your mail message.
 
  @mail/replyall[/quote] <msg>
	This sends a reply to the person who sent you <msg>, as well
	as all other recipients of <msg>. The subject line will be
	'Re: <original subject line>'. If you specify the /quote switch,
	the original message will be quoted back at the beginning of
	your mail message.
 
& mail-other

  @mail/clear [<msg-list | all>]
  @mail/unclear [<msg-list> | all>]
        These commands mark mail in the current folder as cleared or uncleared.
        Mail marked for clearing is deleted when you disconnect, or
        if you use @mail/purge. If no msg-list is specified, all
        mail in your current folder is cleared. If "all" is given instead
        of a msg-list, all mail in *all* folders is cleared/uncleared.
 
  @mail/purge
        Actually deletes all messages marked for clearing with @mail/clear.
        This is done automatically when you log out.
 
  @mail/tag [<msg-list | all>]
  @mail/untag [<msg-list> | all>]
        These commands tag or untag mail in the current folder.
        Tagged mail can be later acted on en masse by using "tagged" as
        the msg-list for other commands (which does *not* untag them
        afterward). If no msg-list is specified, all messages in the
        current folder are tagged/untagged. If "all" is given as the
        msg-list, all mail in *all* folders is tagged/untagged.
        (Ex: To clear all mail from Lauren and Crusade, @mail/tag *lauren,
        @mail/tag *crusade, @mail/clear tagged, @mail/untag all).
 
{ 'help mail-other2' for more }
& mail-other2
 
  @mail/safe [<msg-list> | all>]
        This command marks a message as being safe from mail expiration. It
        should be used sparingly and only for very imporatant messages.
 
& mail-folders

  The MUSH mail system allows each player 16 folders, numbered from
  0 to 15. Mail can only be in 1 folder at a time. Folder 0 is
  the "inbox" where new mail is received. Most @mail commands
  operate on only the current folder.
 
  @mail/folder
        This commands lists all folders which contain mail, telling
        how many messages are in each, and what the current folder is.
 
  @mail/folder <folder#|foldername>
        This command sets your current folder to <folder#>.
 
  @mail/folder <folder#> = <foldername>
        This command gives <folder#> a name.
 
  @mail/file <msg-list>=<folder#>
        This command moves all messages in msg-list from the current
        folder to a new folder, <folder#>.

& mail-admin
 
  The @mail command can also take the following switches:
 
    @mail/stats [<player>]    --  Basic mail statistics.
    @mail/dstats [<player>]   --  Also provides read/unread count.
    @mail/fstats [<player>]   --  Does all that, plus gives space usage.
 
    @mail/debug <action>[=<player>]
    @mail/nuke
 
  Only wizards may stats players other than themselves. The mail statistics
  commands are computationally expensive, and thus are subject to "daytime"
  restrictions. They also cost the same as a @find (100 credits).
 
  The /debug switch does sanity checking on the mail database, and may only
  be used by a wizard. "@mail/debug sanity" just does the check; the command
  "@mail/debug clear=<player name or dbref number>" wipes mail for an object.
  "@mail/debug fix" attempts to repair problems noted in the sanity check.
 
  The /nuke switch destroys the post office, erasing all @mail everywhere.
  It may only be used by a wizard.
 
  Also, admin may set the @amail attrib on their char.  When somebody sends
  you mail, it will trigger that attrib if it exists.

& mail-examples
 
  Here is an example of mailing a player, where is the player will be "bob",
  and sending the mail.
 
  > @mail bob = The MUSH              - This is the Subject line. 
 
  Sending mail to player 'Bob'
  > -Hi bob.                         - This is where you will enter the body
                                       of the message.
  Text Added.
  > @send                            - Basically, sends the @mail.
 
  MAIL: You sent your message to 'Bob'.   
 
& @amail

  Command: @amail <player> = <command-list>
  Attribute: Amail
 
  Sets the actions to be taken after a player receives @mail. This should
  *never* @mail another player, as this could cause an infinite loop.
 
  Example: @amail me=@mail/file [mail()]=2
           This would place all incoming messages in folder #2.
  See also: @mailsucc, @signature, @mail.
 
& @mailsucc

  Command: @mailsucc <player> = <message>
  Attribute: Mailsucc
 
  Sets a message to be displayed to the sender whenever <player> receives
  mail.
 
  Example: @mailsucc me=Thanks for the mail.
  See also: @amail, @signature, @mail.
 
& @signature

  Command: @signature <player> = <message>
  Attribute: Signature
 
  Sets a message to be appended to ever @mail message you send. It is
  appended directly at the end of the message, so if you wish to start the
  signature on a new line you should begin it with a %r.
 
  Example: @signature me=%rThis is a mail signature. (Note: You might want 
  to include the %r at the front of the signature, other wise it will be 
  combined with the @mail message.)

  See also: @mailsucc, @amail, @mail.
 
& MAIL()

  mail(<mail message #>)
  mail(<player name>)
  mail(<player>, <mail message #>)
  mail()

  The first form returns a message corresponding to that mail message
  number in your MUSH mailbox. This function can be used to forward
  mail, or as a way to simply transfer mail messages to attributes
  on an object.
 
  The second form returns three numbers, corresponding to the number of
  read, unread, and cleared messages <player> has.
  The third form returns <player>'s <mail message #>. It works like
  the first form except it applies to another player.
  The last form returns the number of messages the evaluating player has.
  Only wizards can use the second and third forms of the function
  on other players.
 
& MAILFROM()

  Function: mailfrom(<msg #>)
 
  Returns the dbref # of the player who sent you <msg #>. Wizards may
  specify mailfrom(<player>,<msg #>).
 
& STRUCTURE()
  Function:  structure(<struct>,<names>,<types>,<defaults>[,<sep>[,<delim>]])
 
  This function creates a structure definition called <structure>. <names>
  is a space-separated list of component names. <types> is a space-separated
  list of data types. <defaults> is a <sep>-separated list of the default
  values for each of the components. <delim> is the default delimiter
  used by load() and unload().
 
  The valid data types are 'a' ("any", untyped), 'c' (single character),
  'd' (dbref), 'i' (integer), 'f' (floating-point number), and 's' (string
  without any whitespace in it).
 
  The function returns 0 on failure and 1 on success. You cannot re-define
  an already-defined structure; you must unstructure() it first. Typically,
  you will want to put your structure definitions in a @startup, rather than
  declaring them each time they are needed within a code block.
 
  Example: 'structure(grid,xcoord ycoord,i i,0 0)' defines a structure named
  "grid" with two integer components, xcoord and ycoord, which both have a
  default value of 0.
 
& UNSTRUCTURE()
  Function:  unstructure(<struct>)
 
  This function removes the structure definition <struct>, and returns
  1 on success and 0 on failure. There cannot be any instances of
  <struct> currently in existence.
 
  See also: STRUCTURE FUNCTIONS
 
& CONSTRUCT()
  Function:  construct(<instance>,<struct>[,<names>,<values>[,<delim>]])
 
  This function creates an instance of <struct> named <instance>. If
  <names> and <values> are specified, they are used instead of the
  default values for the named components; any components not specified
  in <names> are initialized to their default values. <names> is a
  space-separated list. <values> is a <delim>-separated list (or
  space-separated, if <delim> is not specified).
 
  The function returns 1 on success and 0 on failure. You cannot re-create
  an instance that already exists; you must destruct() it first. Make sure
  to always destruct() instances as soon as they're not needed!
 
  Example:
    > @eval [structure(grid,xcoord ycoord zcoord,i i i,0 0 0)]
    > @eval [construct(blank,grid)]
    > say [unload(blank)]
    You say "0 0 0"
    > @eval [construct(space,grid,xcoord ycoord,2|5,|)]
    > say [unload(space)]
    You say "2 5 0"
 
& DESTRUCT()
  Function:  destruct(<instance>)
 
  Removes the named <instance> of a structure. You should always clean up
  unneeded instances in this way, as soon as they are no longer needed
  (i.e., after the code block that uses them). 
 
  This function returns 1 on success and 0 on failure.
 
  See also: STRUCTURE FUNCTIONS
 
& LOAD()
  Function:  load(<instance>,<struct>,<raw text>[,<delim>])
 
  This function creates a new instance of <struct> named <instance>.
  It loads <raw text> into the components of the structure, where
  <raw text> is a <delim>-separated list; if <delim> is not specified,
  the default delimiter for that structure will be used. The function
  returns 1 on success and 0 on failure. As with construct(), you cannot
  re-create an instance that already exists; you must destruct() it first.
 
  Example:
    > @eval [structure(grid,xcoord ycoord zcoord,i i i,0 0 0)]
    > @eval [load(space,grid,3 4 5)]
    > say [z(space,ycoord)]
    You say "4"
 
  See also: STRUCTURE FUNCTIONS
 
& UNLOAD()
  Function:  unload(<instance>[,<delim>])
 
  This function prints the values of the components in <instance>; the
  list will be <delim>-separated if <delim> is specified, or separated
  by the default delimiter for that structure. If <instance> does not
  exist, an empty string will be returned.
 
  Example:
    > @eval [structure(grid,xcoord ycoord zcoord,i i i,0 0 0)]
    > @eval [load(space,grid,3 4 5)]
    > say [unload(space,|)]
    You say "3|4|5"
 
  See also: STRUCTURE FUNCTIONS
 
& Z()
  Function:  z(<instance>,<component>)
 
  This function retrieves the value of <component> in <instance>. If
  <instance> or <component> do not exist, this function returns nothing.
 
  Example:
    > @eval [structure(grid,xcoord ycoord,i i,2 3)]
    > @eval [construct(space,grid)]
    > say [z(space,ycoord)]
    You say "3"
 
  See also: STRUCTURE FUNCTIONS
 
& MODIFY()
  Function:  modify(<instance>,<component>,<new value>)
 
  This function changes the value of <component> in <instance> to
  <new value>. Type-checking is performed; if the type-check fails,
  the value is unchanged. The function returns 1 on success and 0 on
  failure.
 
  Example:
    > @eval [structure(grid,xcoord ycoord,i i,0 0)]
    > @eval [construct(space,grid)]
    > @eval [modify(space,xcoord,5)]
    > say [z(space,xcoord)]
    You say "5"
 
  See also: STRUCTURE FUNCTIONS
 
& LSTRUCTURES()
  Function:  lstructures()
 
  Returns a space-separated list of all structure names associated with
  the calling object. This is potentially computationally expensive and
  should be avoided if possible.
 
  See also: STRUCTURE FUNCTIONS
 
& LINSTANCES()
  Function:  linstances()
 
  Returns a space-separated list of all defined structure instances
  associated with the calling object. This is potentially computationally
  expensive and should be avoided if possible.
 
  See also: STRUCTURE FUNCTIONS
 
& mSQL
 
Topic: mSQL
 
This is a very brief reference to the mSQL 2.0 query language. Please
consult the mSQL home page at http://www.hughes.com.au/ for details.
 
CREATE		DELETE		DROP		INSERT
SELECT		UPDATE		Operators	Variables
 
See 'help mSQL <topic>' for details.
 
& mSQL Operators
 
The valid basic mSQL operators are: =, <, >, <=, >=, <> ("not equal"))
 
mSQL also supports the LIKE operator, the CLIKE operator (identical to
LIKE, but ignores case), and the RLIKE operator (does a more Unix-style
regular expression match).
 
The regular expressions supported by LIKE and CLIKE are SQL regexps;
'_' is used to match a single character, '`' is used to match zero
or more characters, and all other characters match themselves.
 
RLIKE's regular expressions use '.' to match a single character, 
'*' to match zero or more characters, '^' to anchor a pattern at the
beginning, '$' to anchor a pattern at the end, and characters enclosed
in brackets to match a range.
 
& mSQL CREATE
 
Syntax:
 
CREATE TABLE table_name ( col_name col_type [ not null ] 
                          [, col_name col_type [ not null ] ] )
 
CREATE [UNIQUE] INDEX index_name ON table_name ( field_name [, field_name ] )
 
CREATE SEQUENCE ON table_name [ STEP step_val ] [ VALUE initial_val ] 
 
Valid column types are:  char(len), text(len), int, real
 
Examples:
 
CREATE TABLE nametab ( name char(16) not null, dbnum int )
CREATE UNIQUE INDEX num_index on nametab (dbnum)
CREATE SEQUENCE ON nametab STEP 2 VALUE 4
 
& mSQL DELETE
 
Syntax:
 
DELETE FROM table_name WHERE column OPER value [ AND | OR column OPER value ]
 
OPER can be any standard mSQL operator.
 
Example:
 
DELETE FROM nametab WHERE name='Wizard' AND dbnum=3
 
& mSQL DROP
 
Syntax:
 
DROP TABLE table_name
DROP INDEX index_name FROM table_name
DROP SEQUENCE FROM table_name 
 
Examples:
 
DROP TABLE nametab
DROP INDEX num_index FROM nametab
DROP SEQUENCE FROM nametab
 
& mSQL INSERT
 
Syntax:
 
INSERT INTO table_name [ ( column [, column ] ) ] VALUES (value [, value] ) 
 
Examples:
 
INSERT INTO nametab (name, dbnum) VALUES ('Wizard', '3')
INSERT INTO nametab VALUES('Wizard', '3')
 
& mSQL SELECT
 
Syntax:
 
SELECT [DISTINCT] [table.]column [ , [table.]column ]
       FROM table [ = alias] [ , table [ = alias] ]
       [ WHERE [table.] column OPERATOR VALUE 
       [ AND | OR [table.]column OPERATOR VALUE] ]
       [ ORDER BY [table.]column [DESC] [, [table.]column [DESC] ] 
 
Examples:
 
SELECT dbnum FROM nametab WHERE name='Wizard'
 
SELECT DISTINCT name, dbnum FROM nametab WHERE dbnum > 10 ORDER BY name DESC
 
SELECT nametab.dbnum infotab.history FROM nametab, infotab
       WHERE nametab.name='Wizard' AND nametab.dbnum=infotab.dbnum
 
& mSQL UPDATE
 
Syntax:
 
UPDATE table_name SET column=value [ , column=value ]
       WHERE column OPERATOR value 
       [ AND | OR column OPERATOR value ]
 
 
Examples:
 
UPDATE nametab SET dbnum=10 WHERE dbnum=3
 
UPDATE nametab SET name='Number_One' WHERE dbnum=1
 
& mSQL Variables
 
_rowid:  This is the unique identifier for a row in a table.
 
_seq:  This is the current sequence value of a table.
 
_sysdate:  Current time and date.
 
_timestamp: Last modified time and date (in epoch time seconds) for a row.
 
& TCL

Topic: TCL
 
Tcl (pronounced "tickle") -- the Tool Command Language -- is a 
simple, easily extensible, scripting language. It is a popular
language for embedding in applications, and commonly used in
World-Wide Web development. It is included as part of TinyMUSH
in an effort to provide an alternative to making direct server
modifications for sophisticated tasks.
 
A complete discussion of the Tcl language is beyond the scope
of these help files. Interested readers are directed to the
Tcl/Tk website at http://sunscript.sun.com/ for details.
Basic Tcl syntax and functions are given in "help Tcl Primer".
 
Tcl is called through the use of MUSH functions, and is accessible
only by privileged users. This is "Safe TCL", which means that 
file operations and other dangerous primitves are disabled.
See "help Tcl Functions" for details.
 
WARNING: This has not been implemented in TinyMUSH 3.0, yet.
 
& Tcl Functions
 
Topic: Tcl Functions
 
Not all MUSHes will support the use of Tcl. To use these functions,
the object must have the TICKLER flag. 
 
MUSH functions:
 
  TclClear()	TclEval()	TclParams()	TclRegs()
 
Tcl built-ins:
 
  Tcl pemit	Tcl mushfunc	Tcl getattrib	Tcl setattrib
 
See the help for each individual function for details.
 
& TclClear()

Function: TclClear()
 
Each object can be considered to have its own private version
of the Tcl interpreter. The interpreter is persistent for the
duration of the MUSH's uptime, unless specifically cleared
for that object.
 
This function creates a "fresh" interpreter for the executing
object. The previous interpreter instance, if any, is flushed;
all variables, procedures, etc. associated with it will be
removed.
 
& TclRegs()
 
Function: TclRegs()
 
This function "imports" the current value of the global registers (%q0
through %q9) into the current instance of the executing object's Tcl
interpreter, as the array 'mushregs'.
 
For example, if you use: '[setq(0,foo)] [TclRegs()]' then
'$mushregs(0)' will be the string 'foo'.
 
& TclParams()
 
Function: TclParams(<arg 0>[, <arg2>, ..., <arg 9>])
 
This function "imports" its arguments into the current instance of the
executing object's Tcl interpreter, as the array 'mushparams'.
 
For example '[TclParams(foo, bar, baz)]' would set $mushparams(0) to
'foo', $mushparams(1) to 'bar', and $mushparams(2) to 'baz'.
 
This function is thus very useful for passing arbitrary useful
data to the Tcl interpreter; for example, this is a good way to
pass arguments to commands and the like.
 
& TclEval()
 
Function: TclEval(<object>/<attribute>[,<arg 0>,...,<arg 9>])
 
This function executes the Tcl script contained in <attribute> on
<object>.
 
The variable $me is automatically set to the object number of the
calling object (equivalent to '%!' with the leading '#' sign stripped),
and the variable $enactor is automatically set to the object number
of the enactor (equivalent to '%#' with the leading '#' sign stripped).
Any additional arguments are passed as the array $in(0) through $in(9).
 
Please note that invocations of the interpreter are dangerous. There
are no time limits placed upon the execution of a given command; if
you set up an infinite loop, the MUSH will hang.
 
& Tcl pemit
 
Tcl Command:  pemit <dbref> <text>
 
This command can be used from within a Tcl script to send a message
back to a MUSH object. Note that the target is a dbref, not a number,
and therefore needs a leading '#' sign. <text> can be any string.
 
The Tcl command 'pemit #$enactor "This is a test."' is equivalent to
the MUSH command '@pemit %# = This is a test.'
 
& Tcl getattrib
 
Tcl Command:  getattrib <dbref> <attribute>
 
This command can be used from within a Tcl script to retrieve the
value of an attribute on a MUSH object. Note that the object is
specified as a dbref (with a leading '#'), not as a number.
 
The Tcl command 'getattrib #$enactor TEST' is equivalent to the MUSH
function invocation '[get(%#/TEST)]'.
 
& Tcl setattrib
 
Tcl Command:  setattrib <dbref> <attribute> <text>
 
This command can be used from within a Tcl script to set the value of
an attribute on an object. Note that the object is specified as a dbref
(with a leading '#'), not as a number. <attribute> is any value attribute
name. <text> is any arbitrary string.
 
The Tcl command 'setattrib #$me TEST "This is a test string."' is
equivalent to the MUSH command '&TEST %! = This is a test string.'
or '&TEST me = This is a test string.'
 
& Tcl mushfunc
 
Tcl Command:  mushfunc <MUSH function name> <param 1> <param 2> <etc.>

This command can be used from within a Tcl script to execute a MUSH
function (except for MUSH Tcl functions). <function name> is the name
of the MUSH function, and the parameters are remaining arguments to
the Tcl command.
 
For example, the Tcl command 'mushfunc lnum 2 6' is equivalent to
the MUSH function 'lnum(2,6)' and produces '2 3 4 5 6' as a result.
 
& Tcl Primer
 
The following topics contain a very brief summary of the Tcl language.
 
Arrays		Control Structures	Errors		Expressions
Info		Lists			Procedures	Strings
Tracing		Variables
 
See "help Tcl <topic name>" for details.
 
& Tcl Variables
 
Topic: Tcl Variables
 
Everything in Tcl is treated as a string. Anything placed with double
quotes is grouped; expressions within double quotes are
evaluated. Anything placed within curly braces is grouped, but
expressions within the curly braces are not grouped. Statements are
separated with semi-colons. Comments begin with a # and extend to the
end of the line.
 
Variables are set with: set VariableName "String"
Variables are unset with: unset VariableName
Variables are accessed with $VariableName
To use a literal dollar sign in an expression, escape it:  \$
 
All commands return values. To evaluate a command and use its
return value inside an argument to another command, enclose the
command in square brackets.
  
Continued in 'help Tcl Variables2'.
 
& Tcl Variables2
 
Topic: Tcl Variables (continued)
 
There is also a special command, 'incr', which adds a number to the
value of a variable, and then sets the variable.  For example,
"incr x 1" increases the value of x by 1; "incr x -1" decreases the
value of x by 1. "incr" with only one argument increments the
variable by 1.
 
Examples of valid syntax (commands executed in order):
 
  set name "Joe Smith";			==> returns Joe Smith
  set a 1;				==> returns 1
  set b 2;				==> returns 2
  set sum "[expr $a + $b]";		==> returns 3
  set x $sum				==> returns 3
  incr a				==> returns 2
  incr b -1				==> returns 1
  incr x "[expr $a + $b]";		==> returns 6
  
& Tcl Expressions
 
Topic: Tcl Expressions
 
Mathematical expressions are essentially strings that have values.
The usual mathematical operators (+ - * / %) are available, as
are mathematical functions such as sin(), cos(), floor(), ceil(),
and so forth.
 
For comparison purposes, || (or), && (and), and ! (not) are available,
as are == (equal to), != (not equal to), <= (less than or equal to),
and >= (greater than or equal to).
 
Mathematical expressions are not commands, however. They must be
evaluated, through the use of the 'expr' command. For example:
 
set sum "Sum: 1 + 2"		==> Returns "Sum: 1 + 2"
set sum "Sum: [ 1 + 2 ]"	==> Returns an error
set sum "Sum: [ expr 1 + 2]"	==> Returns "Sum: 3"
set x "[ expr (1 + 2) * 3 ]"	==> Returns "9"
 
To force a string to evaluate as a command, use:  eval String
 
& Tcl Control Structures
 
Topic: Tcl Control Structures
 
There are a number of loop and other control structures in Tcl.
They are treated like standard Tcl commands.
 
IF/THEN/ELSE
 
if { Expression } {			if { $x < 0 } {
	# Commands				set out "Less than zero";
} elseif { Expression } {		} elseif { $x == 0 } {
	# Commands				set out "Equal to zero";
} else {				} else {
	# Commands				set out "Greater than zero";
}					}
 
Continued in 'help Tcl Control2'.
 
& Tcl Control2
 
Topic: Tcl Control Structures (continued)
 
SWITCH
 
switch Option VariableName \		switch -exact $sum \
	String1 {				1 { set out "One" }
		# Action 1			2 { set out "Two" }
	} String2 {				3 { set out "Three" }
		# Action 2			default { set out "Error" };
	} default {
		# Default action
	}
  
The option for the switch command must be -exact (match exactly),
-glob (match wildcards), or -regexp (match regular expressions).
 
Continued in 'help Tcl Control3'.
 
& Tcl Control3
 
Topic: Tcl Control Structures (continued)

WHILE LOOP
 
while { Expression } {			while { $i < $total } {
	# Commands				incr x 5;
}						incr i;
					}
 
FOR LOOP

for { Start Command } { Test Expression } { Next Command } {	
	# Commands
}

for { set i 0 } { $i < 5 } { incr i } {
	set sum "[expr $sum * $i]";
}

Continued in 'help Tcl Control4'.

& Tcl Control4
 
Topic: Tcl Control Structures (continued)
 
It is possible to prematurely exit a loop with the 'break' and
'continue' commands. The 'break' command causes the loop to
immediately exit; the 'continue' command causes control to
return to the top of the loop, for the next iteration to
execute.
 
Example of 'break' (and equivalent 'for' loop):
 
set x 0;			for { set x 0 } { $x <= 5 } { incr x } {
while { 1 } {				incr y 2;
	incr x;			}
	incr y 2;
	if ($x > 5) break;
}
 
Continued in 'help Tcl Control5'.
 
& Tcl Control5
 
Topic: Tcl Control Structures (continued)
 
Example of 'continue' (only adds odd numbers):
 
for { set x 0 } { $x < 100 } { incr x } {
	if { $x % 2 == 0 } continue;
	incr y 1;
	incr sum x;
}
 
& Tcl Procedures
 
Topic: Tcl Procedures
 
It is possible to define procedures, which act just like built-in
commands; every procedure returns a value.  Procedures are defined by
the 'proc' command, with the following syntax:
 
proc ProcedureName { Arg1 Arg2 ... ArgN } {
	# Commands
	return Value;
}
 
If the 'return' statement is ommitted, the return value is that of
the last statement in the procedure.

Variables in procedures are passed by value, and variables used within
a procedure are local to that procedure unless specificied otherwise
with the 'global' command.
 
Continued in 'help Tcl Proc2'.
 
& Tcl Proc2
 
Topic: Tcl Procedures (continued)
 
The 'global' command specifies that the value of a variable inside the
procedure is the same as its value outside that procedure. It can take
multiple arguments; for example, "global x y z;" is a valid statement.
 
For example, the following would compute the area of two circles:
 
set pi 3.14159;
proc circle_area { radius } {
	global pi;
	expr $pi * $radius * $radius;
}
set little_circle "[ circle_area 4 ]";
set big_circle "[ circle_area 10 ]";
 
Continued in 'help Tcl Proc3'.
 
& Tcl Proc3
 
Topic: Tcl Procedures (continued)
 
It is possible to make a variable visible outside of its normal scope
with the "upvar" command, thus making it possible to implement
pass-by-reference in procedures. The command takes the following syntax:
 
upvar Referred-To Referred-Through
   
For example, "upvar old new" means that if "new" is changed, "old"
will also be changed: "set new 1" will set "new" to 1 inside the
procedure, and "old" to 1 in the caller of the procedure.
 
It is also possible to use the command "uplevel Command" to
evaluate a command in the scope of the calling procedure.
 
& Tcl Lists
 
Topic: Tcl Lists
 
Like MUSH, Tcl has a concept of a "list", a space-separated set of
words. For example, "a b c d e" is a list of five elements. Unlike
MUSH, however, Tcl numbers its list elements starting from zero,
not one.
 
It is possible to have lists of lists, usually written by enclosing
each set of elements within curly braces, as in the following example:
set biglist { a b {c d { e f g }} {h i j} k}
 
A variety of commands exist for list manipulation, as well as a
special loop construct, which takes the following syntax:
 
foreach VariableName List {		foreach elem "1 2 3 4 5" {
	# Commands				incr sum $elem;
}					}
 
Continued in 'help Tcl Lists2'.
 
& Tcl Lists2
 
Topic: Tcl Lists (continued)
 
list Element1 Element2 ... ElementN
    Takes the arguments and makes them into a list, i.e.,
    'list a b c d' returns "a b c d". This will preserve
    lists-within-lists.
concat "List1" "List2" ... "ListN"
    Takes the arguments and turns them into a single list.
lappend Variable Arg1 Arg2 ... ArgN
    Appends the arguments to the end of an existing list stored
    in the variable, i.e., 'set x "a b c"; lappend x d e' returns
    'a b c d e'.
split String Separators
    Splits a string into a list, using the characters specified as
    separators to delimit the original string, i.e., 'split a:b:c:d :'
    returns the list 'a b c d'.
join "List" Separator
    Joins elements of a list together, with Separator as the delimiter,
    i.e., 'join "a b c" :' returns 'a:b:c'.
 
Continued in 'help Tcl Lists3'.

& Tcl Lists3
 
Topic: Tcl Lists (continued)
 
llength "List"
    Returns the length of a list, i.e, 'llength "a b c"' is 3.
    Equivalent to MUSH 'words(a b c)'.
lsort SortTypes "List"
    Returns the list in sorted order. Sort type switches may optionally
    be specified: -ascii (lexicographical order), -integer (as integers).
    -real (as floating-points), -command (using a comparison command),
    -increasing (increasing order), and -decreasing (decreasing order).
    The default is ascii and increasing.
 
lindex "List" Number
    Returns the element in that position of the list, i.e.,
    'lindex "a b c" 1' returns 'b'.
lrange "List" Begin End
    Returns the elements in that range of positions in the list, i.e.,
    'lrange "a b c d e" 1 3' returns 'b c d'.
 
Continued in 'help Tcl Lists4'.

& Tcl Lists4
 
Topic: Tcl Lists (continued)
 
lsearch "List" Element
    Returns the index of the first element in the list which matches
    Element, i.e., 'lsearch "a b c d e" c' returns '2'.
 
linsert "List" Number Arg1 Arg2 ... ArgN
    Inserts the arguments before the Number'd element in the original list,
    i.e., 'linsert "a b f g" 2 c d e' returns 'a b c d e f g'.
lreplace "List" Begin End Arg1 Arg2 ... ArgN
    Deletes the arguments from element positions Begin to End, inserting
    the arguments in their place, i.e., 'lreplace "a b x y z f g" 2 4 c d e'
    returns 'a b c d e f g'.
 
& Tcl Strings
 
Topic: Tcl Strings
 
Tcl has a number of build-in commands for string manipulation.
String positions are numbered starting from zero.
 
append Variable String1 String2 ... StringN
    Takes the string in Variable, and appends the other strings to it, i.e.,
    'set str "xyz"; append str "abc" "def"' returns 'xyzabcdef'.
format FormatString Arg1 Arg2 ... ArgN
    Takes a format string and prints the arguments appropriately. Equivalent
    to C's sprintf() function, i.e., 'format "X: %3d" x' where x is 12,
    returns 'X:  12'.
scan String FormatString Var1 Var2 ... VarN
    Takes a string, and breaks it down according to the format given,
    placing the results in the named variables. Equivalent to C's
    sscanf() function, i.e., 'scan "abc 15 xy" "%s %d %s" str1 num str2'
    returns str1 as 'abc', str2 as 'xy', and num as '15'.
 
Continued in 'help Tcl Strings2'.

& Tcl Strings2
 
Topic: Tcl Strings (continued)
 
string compare String1 String2
    Returns -1, 0, or 1, depending on which string is lexicographically
    greater; 0 indicates identical strings. Equivalent to MUSH comp().
string match Pattern String
    Returns 1 if the string matches the wildcard pattern, 0 if not.
    This is like MUSH strmatch(), but with the argument order reversed.
 
string index String Position
    Returns the character at that position in the string, i.e.,
    'string index abcde 2' returns '2'.
string range String Begin End
    Returns the characters between those positions in the string, i.e.,
    'string range abcde 1 3' returns 'bcd'.
 
Continued in 'help Tcl Strings3'.

& Tcl Strings3
 
Topic: Tcl Strings (continued)
  
string first Substring String
    Returns the first position in the string, that substring occurs at.
    If the substring is not in the string, -1 is returned. For example,
    'string first man superman' returns '5'.
string last Substring String
    Returns the last position in the string, that substring occurs at,
    i.e. 'string last abc abc123abc456' returns '6'.
 
string trim String Characters
    Removes, from the beginning and end of the string, any of the
    specified characters. For example, 'string trim -*-POW-*- *-'
    returns 'POW'.
string trimleft String Characters
    Like string trim, but only removes from the beginning of the string.
string trimright String Characters
    Like string trim, but only removes from the end of the string.
 
Continued in 'help Tcl Strings4'.

& Tcl Strings4
 
Topic: Tcl Strings (continued)
 
string tolower String
    Returns the string with all letters lowercased, like MUSH lcstr().
string toupper String
    Returns the string with all letters uppercased, like MUSH ucstr().
 
& Tcl Arrays
 
Topic: Tcl Arrays
 
Tcl has arrays, indexed by arbitrary strings. An array element
is a variable of the format VariableName(Index); for example,
players(0), players(1), players(2), players(Zod) are all valid
variable names for elements of an array.
 
Because array indexes are arbitrary strings, they can contain
whitespace, and it is possible to simulate multi-dimensional
arrays by placing a comma within the index:  for example,
players(5,12) is valid.
 
Array variables are set and retrieved just like ordinary
variables, i.e.:

set objects(0) "Limbo"			if { $objects(limbo) != 0 } {
set objects(1) "Wizard"				set errstr "Error!";
set objects(2) "Master Room"		}
set objects(limbo) 0
 
Continued in 'help Tcl Arrays2'.

& Tcl Arrays2
 
Topic: Tcl Arrays (continued)
 
Unsetting an array variable name unsets the entire array; i.e., the 
command 'unset objects' removes objects(0), objects(1), etc.
 
There are also two special commands which provide information about
arrays:
 
array size ArrayName
    Returns the number of elements in the array.
array names ArrayName
    Returns a list of element names in the array.
 
& Tcl Info
 
Topic: Tcl Info
 
The 'info' set of commands provides various bits of information
on the current state of the interpreter.
 
info exists VariableName
    Returns 1 if a variable exists, 0 if it does not.
info vars Pattern
    Returns a list of all local and global variables. If a wildcard
    pattern is specified, it will only return those variables whose
    names match the pattern.
info locals Pattern
    Like info vars, but returns only local variables.
info globals Pattern
    Like info vars, but returns only global variables.
info level Number
    With no arguments, this returns the stack depth. With an argument of 0,
    it returns the command and arguments of the current procedure; an 
    argument of -1 gives this info for the calling procedure, -2 the
    info for the procedure beyond that, and so forth.
 
& Tcl Errors
 
Topic: Tcl Errors
 
Tcl has a variety of exception-handling mechanisms for dealing with errors.
 
catch { Procedure Arg1 Arg2 ... ArgN } Variable
    If the procedure succeeds, 'catch' returns 0. If a variable name is
    specified, the return result of the procedure is set in that variable.
error String
    If this command is given, the string will be stored in the optional
    variable name specified to 'catch', and 'catch' will return 1.
 
The gloable variable errorInfo can be used to give a more detailed
description of the error, for debugging purposes; it lists the
commands and procedures on the stack leading to the error.
 
& Tcl Tracing
 
Topic: Tcl Tracing
 
trace variable VariableName Type Procedure
    Invokes a procedure whenever the named variable is "r"ead,
    "w"ritten to, or "u"nset/goes out of scope. One of these options
    must be specified as the type of trace).
 
The procedure must be declared as:  proc Procedure { Variable Element Type }
where the first parameter is the variable to trace, the second the
element of the array (if the variable is an array), and the third the
type, specified as r, w, or u.
 
Note that due to the scope of the procedure being executed, it will
usually be necessary to do an 'upvar' to get the variable being
traced from the caller's scope. 
 
& About TinyMUSH
 
  TinyMUSH 3.0 is the result of converging the development paths of
  TinyMUSH 2.2 and TinyMUX. It was designed to be a stable, efficient,
  highly-configurable, feature-rich code version, offering users a full
  array of 2.2 and MUX features, as well as substantial enhancements to
  functionality and performance.
 
  TinyMUSH 3.0 is under active development, and is the standard supported
  version of TinyMUSH for the forseeable future. Lydia Leong ("Amberyl")
  and David Passmore ("Lauren") are the primary developers of the codebase.
  Robby Griffin ("Alierak") joined the development team as of 3.0 beta 18.
 
  See 'help Patchlevel' for notes on TinyMUSH 3.0 changes.
  See 'help Writing News' for an explanation of how to write news files.
  See 'help Support' for URLs to TinyMUSH 3.0 announcements and resources.
  See 'help Mailing Lists' for a list of TinyMUSH-related mailing lists.
  
& Mailing Lists
 
  Support for TinyMUSH 3.0 is done via 'tinymush-support@godlike.com',
  a mailing list. The list's home page, subscription tool, and archives
  are at http://www.godlike.com/mailman/listinfo.cgi/tinymush-support
 
  Announcements of new server versions, new games, and other information
  of interest to the general MUSH community, is available through
  mush-announce@godlike.com, a moderated mailing list with low traffic.
  We highly encourage all users to subscribe to it through its home page
  at http://www.godlike.com/mailman/listinfo.cgi/mush-announce
  Archives are also available through that page.
 
  There is an unofficial MUSH programmer's list, 'softcode@legendary.org'.
  Go to http://www.legendary.org/mailman/listinfo.cgi/softcode to subscribe.
 
  There is a mailing list for MUSH administrators, 'gods@godlike.com'.
  Go to http://www.godlike.com/mailman/listinfo.cgi/gods to subscribe
  or to peruse the archives.
 
  An informal meeting grounds for MUSH administrators, called The
  Godlike Edge, is located at edge.godlike.com 6250. 
 
& Support
 
  TinyMUSH 3.0 announcements and related support information can be found
  at the official TinyMUSH 3.0 home, http://www.godlike.com/tinymush-3.0/
 
  The MUSH Manual can be found at http://www.godlike.com/mushman/
 
  General information about MUDs and a MUSH list can be found on the
  MUD Resource Collection, at http://www.godlike.com/muds/
 
  Users may also be interested in the TinyFugue client, available from
  laurel.actlab.utexas.edu, in /pub/tinyfugue.
 
  Also useful is the LogEdit program, a tool for quickly editing logs,
  available from pennmush.tinymush.org, in /pub/DuneMUSH/Accessories. 
 
& Writing News
 
The format of a news entry file is simple. A news entry begins with
"& <topic name>", where <topic name> is whatever you want that news
entry to be called. Topics with similar names should be placed in
alphabetical order; i.e., "Magic" should come before "Magic Weapons".
Topic names are not case-sensitive.
 
News entries are displayed "as is". No special formatting is done.
Blank lines are normally "eaten"; to get a blank line into a news
file, enter a line with a single space on it. You may want to avoid
"tab" characters in news files, since some terminal types are confused
by them. You will probably want to make individual news topics no more
than 23 lines long, in order to accomodate screen sizes.
 
Percent-substitutions are evaluated inside news files, so you can use
ANSI color codes in them. Be aware that this means you will need to
escape certain special characters, such as the backslash and percent.
 
You must use the 'mkindx' program to re-index the news file when it
is changed. If you change any text files while the game is running,
a Wizard must do a @readcache from within the game.
 
& Patchlevel
 
TinyMUSH 3.0 starts out from a fusion of the TinyMUSH 2.2.5 and TinyMUX 1.6
code bases. In the future, this entry will contain TinyMUSH 3.0 ongoing
changes.
 
