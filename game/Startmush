#!/bin/sh
#
#	Startmush - Kick off the netmush process.
#
PATH=/usr/ucb:/bin:/usr/bin:.; export PATH
LTDL_LIBRARY_PATH=./modules:./bin:.:../src:../src/modules:../src/.libs; export LTDL_LIBRARY_PATH
#
. mush.config
#
#	Make sure there isn't aready a MUSH running.
#
if [ -r mush.pid ]; then
	oldpid=`cat mush.pid`
	if [ $oldpid -gt 1 ]; then
		nmush=`ps | grep $oldpid | grep netmush | wc -l`
		if [ $nmush -gt 0 ]; then
			echo "The MUSH already seems to be running."
			exit 0
		fi
	fi
fi

#
#	Make sure the indexes are up-to-date.
#
./Index

echo "Checking for database files and creating backups of old files."

#
#	Refuse to start if a restart.db is present.
#
if [ -r restart.db ]; then
    echo "There is a restart database, restart.db, present."
    echo "Please delete it before attempting to start the MUSH."
    exit 1
fi

#
#	Handle a KILLED database. If it's complete, we have a flatfile
#	that we can Restore from. Otherwise we should rename it as
#	corrupt and move on.
#	
if [ -r $DATA/$INPUT_DB.KILLED ]; then
	echo
	DBDATE=`date +%m%d-%H%M`
	end="`tail -1 $DATA/$INPUT_DB.KILLED`"
	if [ "$end" = "***END OF DUMP***" ]; then
		if [ -d $BACKUP_DIR ]; then
			NEWFILE=$BACKUP_DIR/$GAMENAME.$DBDATE
		else
			NEWFILE=$GAMENAME.$DBDATE
		fi
		mv $DATA/$INPUT_DB.KILLED $NEWFILE
		echo "A non-corrupt $INPUT_DB.KILLED file was present."
		echo "This means that a flatfile was successfully saved after the reception"
		echo "of a SIGTERM, possibly due to a machine reboot."
		echo "This file has been renamed to $NEWFILE"
		echo "Please type:  ./Restore $NEWFILE"
		echo "If this restoration is successful, you can then type ./Startmush again."
		exit 1
	else
		if [ -d $BACKUP_DIR ]; then
			NEWFILE=$BACKUP_DIR/$GAMENAME.$DBDATE.CORRUPT
		else
			NEWFILE=$GAMENAME.$DBDATE.CORRUPT
		fi
		mv $DATA/$INPUT_DB.KILLED $NEWFILE
		echo "A corrupt $INPUT_DB.KILLED file was present."
		echo "This means that there was an unsuccessful attempt to save a flatfile"
		echo "after the reception of a SIGTERM, likely due to a machine reboot."
		echo "This file has been renamed to $NEWFILE"
		echo "You may wish to check for potential problems, and run ./Backup"
		echo "before continuing and typing ./Startmush again."
		exit 1
	fi
fi

#
#	Handle a CRASH database. This is a flatfile created when we 
#	encounter something fatal and attempt to automatically restart.
#	The file might not be current, though, even if it's non-corrupt.
#	If it is corrupt, we've got to cope with that, too.
#
if [ -r $DATA/$CRASH_DB ]; then
	echo
	end="`tail -1 $DATA/$CRASH_DB`"
	if [ "$end" = "***END OF DUMP***" ]; then
		echo "A non-corrupt $CRASH_DB file is present."
		echo "This indicates a flatfile was successfully saved during a panic-restart."
		echo "This file might not be newer your current database."
		echo "Please check the file modification times:  ls -l $DATA"
		echo "If your current database is newer than the crash file, you should:"
		echo "  * Remove the crash file:  rm -f $DATA/$CRASH_DB"
		echo "  * Backup your data:  ./Backup"
		echo "If the crash file is newer, you should:"
		echo "  * Rename the crash file:  mv -f $DATA/$CRASH_DB ./$GAMENAME.flat"
		echo "  * Restore from backup:  ./Restore ./$GAMENAME.flat"
		echo "If this is successful, you can then type ./Startmush again."
		exit 1
	else
		DBDATE=`date +%m%d-%H%M`
		if [ -d $BACKUP_DIR ]; then
			NEWFILE=$BACKUP_DIR/$GAMENAME.$DBDATE.CORRUPT
		else
			NEWFILE=$GAMENAME.$DBDATE.CORRUPT
		fi
		mv -f $DATA/$CRASH_DB $NEWFILE 
		echo "A corrupt $CRASH_DB file is present."
		echo "This indicates an unsuccessful flatfile save during a panic-restart."
		echo "This file has been renamed to $NEWFILE"
		echo "You may wish to check for potential problems, and run ./Backup"
		echo "before continuing and typing ./Startmush again."
		exit 1
	fi
fi

#
#	Save a copy of the previous input databases.
#
if [ -r $DATA/$INPUT_DB ]; then
	mv -f $DATA/$INPUT_DB $DATA/$SAVE_DB
else
	echo "No previous input database."
fi

if [ -r "comsys.db" ]; then
	cp -f comsys.db comsys.db.old
elif [ -r "$DATA/comsys.db" ]; then
	cp -f $DATA/comsys.db $DATA/comsys.db.old
else
	echo "No previous comsys database."
fi

if [ -r "mail.db" ]; then
	cp -f mail.db mail.db.old
elif [ -r "$DATA/mail.db" ]; then
	cp -f $DATA/mail.db $DATA/mail.db.old
else
	echo "No previous mail database."
fi

#	Handle Linux sh brokenness; this isn't supposed to be an environment
#	variable, but somehow it stays set.
make_db=""

#	If we have a good checkpoint database, make it the input database.
#	If not, use the backup of the input database.
#
if [ -r $DATA/$NEW_DB ]; then
	mv $DATA/$NEW_DB $DATA/$INPUT_DB
else
	if [ -r $DATA/$SAVE_DB ]; then
		echo "No recent checkpoint db. Using older db."
		cp $DATA/$SAVE_DB $DATA/$INPUT_DB
	else
		echo "No recent db. Will initialize new database."
		make_db="-s"
	fi
fi
#
#	Remove the start db if there is one.
#
if [ -r restart.db ]; then
	rm -f restart.db
fi
#
#	Cleanup the old logfiles.
#
./Logclean
#
#	Kick off MUSH
#
touch $LOGNAME
(nohup $BIN/netmush $make_db -c $GAMENAME.conf -l $LOGNAME >>$LOGNAME 2>&1 & echo $! >mush.pid)
echo "Process `cat mush.pid`"
tail -f $LOGNAME | awk '{ print $0 }; /Cleanup completed/ { exit };'
